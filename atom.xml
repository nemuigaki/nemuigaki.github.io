<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sadalsuud🥝</title>
  
  
  <link href="https://www.sadalsuud.cn/atom.xml" rel="self"/>
  
  <link href="https://www.sadalsuud.cn/"/>
  <updated>2024-06-16T11:06:44.969Z</updated>
  <id>https://www.sadalsuud.cn/</id>
  
  <author>
    <name>Yoshida🥝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis十大数据类型</title>
    <link href="https://www.sadalsuud.cn/posts/dfb5c41c.html"/>
    <id>https://www.sadalsuud.cn/posts/dfb5c41c.html</id>
    <published>2024-06-16T11:00:16.000Z</published>
    <updated>2024-06-16T11:06:44.969Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis十大数据类型</h1><h2 id="类型">类型</h2><blockquote><p>这里的类型是Value，Key一般都是String</p></blockquote><ul><li>Strings</li><li>Lists</li><li>Sets</li><li>Sorted Sets （ZSET）</li><li>Hashes</li><li>Streams</li><li>Geospatial</li><li>HyperLogLog</li><li>Bitmaps</li><li>Bitfields</li></ul><h4 id="String-字符串">String 字符串</h4><ul><li>Redis中最基本的类型，一个Key可以对应一个Value</li><li>二进制安全的（可以包含任何数据，比如图片或者序列化的对象）</li><li>一个Redis中的字符串value最多可以是512M</li></ul><h4 id="List-列表">List 列表</h4><ul><li>简单的字符串列表，按照被插入的顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li><li>底层是个双端链表，最多可以包含2^32-1个元素（4294967295，超过40亿个元素）</li><li>对两端操作性能很高，通过索引下标操作中间节点性能会比较差</li></ul><h4 id="Set-集合">Set 集合</h4><ul><li>String类型的集合</li><li>不允许重复 + 无序</li><li>集合对象的编码可以是intset和hashtable（底层）</li><li>通过<strong>哈希表</strong>实现的，所以查询、删除、添加的时间复杂度都是O(1)</li><li>可以包含2^32-1个元素（4294967295，超过40亿个元素）</li><li>应用场景<ul><li>微信抽奖小程序（sadd/spop/srandmember）</li><li>朋友圈的点赞</li><li>QQ可能认识的人</li></ul></li></ul><h4 id="Sorted-Set-ZSet-有序集合">Sorted Set /ZSet 有序集合</h4><ul><li>与Set一样是String类型的集合</li><li>不同的是每个元素都会关联一个double类型的分数（给Redis从小到大排序用的）<ul><li>value变成了一个键值对：score1 value1</li><li>key1 score1 value1 key2 score2 value2</li></ul></li><li>ZSet的成员是唯一的，但分数（score）可以重复</li><li>通过<strong>哈希表</strong>实现的，所以查询、删除、添加的时间复杂度都是O(1)</li><li>可以包含2^32-1个元素（4294967295，超过40亿个元素）</li><li>应用场景<ul><li>各种排行榜</li></ul></li></ul><h4 id="Hash-哈希表">Hash 哈希表</h4><ul><li>K-V 键值对</li><li>可以包含2^32-1个元素（4294967295，超过40亿个元素）</li></ul><h4 id="GEO-地理空间">GEO 地理空间</h4><ul><li>原理（实际上是个ZSet，score变成了经纬度）<ul><li>核心思想：将球体转换为平面，区块转换为一点</li><li>主要分为3步：<ul><li>将三维地球变为二维坐标</li><li>将二维坐标转换为一维的点块</li><li>将一维的点块转换为二进制再通过base32编码</li></ul></li></ul></li><li>主要用于存储地理位置信息，并对存储的信息进行操作，包括<ul><li>添加地理位置的坐标</li><li>获取地理位置的坐标</li><li>计算两个位置之间的距离</li><li>……</li></ul></li><li>应用场景<ul><li>美团地图位置附近的酒店</li><li>高德地图附近的核酸点</li></ul></li></ul><h4 id="HyperLogLog-基数统计">HyperLogLog 基数统计</h4><ul><li>用完做基数统计的算法<ul><li>基数：是一种数据集，去重后的真实个数</li><li>基数统计：用于统计一个几乎中不重复的元素的个数，就是对集合去重后剩余元素的计算，即<strong>去重脱水后的真实数据</strong></li></ul></li><li>优点是在输入元素的数量或者体积特别大时，计算基数所需的空间总是固定且很小的<ul><li>每个HyperLogLog键只需要12kb内存，就可以计算出接近2^64个不同的元素的基数</li><li>这和元素越多耗费内存越多的集合产生了鲜明的对比</li></ul></li><li>但HyperLogLog并不会记录每个元素的具体值</li><li>可用于统计某个网站/文章的UV、用户搜索🔍关键词的数量、用户每天搜索不同词条的个数<ul><li>UV unique visitor 独立访客（一般为用户IP）</li></ul></li></ul><h4 id="Bitmap-位图">Bitmap 位图</h4><ul><li>Bit arrays（or simply bitmaps）Bitmap是用String作为底层数据结构实现的一种统计二值状态的数据类型</li><li>一个字节占8位（1 byte = 8 bit）</li><li>由0和1组成的二进制位的<strong>bit数组</strong>（1 bit 只能存1个0/1）</li><li>一般用于状态记录📝<ul><li>用户是否登陆过</li><li>电影广告是否被点击播放过</li><li>上下班打卡统计</li></ul></li></ul><h4 id="BitField-位域">BitField 位域</h4><ul><li>可以一次性操作多个比特<strong>位域</strong>（连续的多个比特位），它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果（其实就是一次性对多个比特位进行操作）</li></ul><h4 id="Stream-流">Stream 流</h4><ul><li>Redis 5.0 新增的数据结构 : <strong>MQ消息中间件+阻塞队列</strong></li><li>主要用于<strong>消息队列</strong>（MQ，Message Queue）<ul><li>支持消息队列的持久化</li><li>支持自动生成全局唯一ID</li><li>支持ack确认消息的模式</li><li>支持消费组（多个消费者）模式等</li></ul></li><li>Redis本身有一个发布/订阅来实现消息队列的功能，但他的缺点是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃<ul><li>即发布/订阅可以分发消息，但无法记录历史消息</li></ul></li><li>Redis的Stream提供了消息的持久化以及主从备份复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失，让消息队列更加稳定和可靠</li></ul><h2 id="常用命令">常用命令</h2><h4 id="key-操作指令">key 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left"><strong>备注</strong></th></tr></thead><tbody><tr><td style="text-align:left">key *</td><td style="text-align:left">查看当前库所有key</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">exists key</td><td style="text-align:left">判断某个key是否存在</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">type key</td><td style="text-align:left">查看某个key的类型</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">del key</td><td style="text-align:left">删除指定的key</td><td style="text-align:left">原子的</td></tr><tr><td style="text-align:left">unlink key</td><td style="text-align:left">非阻塞删除（仅将key从keyspace元数据中移除）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">ttl key</td><td style="text-align:left">查看还有多少秒过期（-1表示永不过期，-2表示已过期）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">expire key 秒钟</td><td style="text-align:left">为给定的key设置过期时间</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">move key dbindex</td><td style="text-align:left">将当前数据库的key移动到给定的数据库db中（dbindex的值为0-15）</td><td style="text-align:left">默认0</td></tr><tr><td style="text-align:left">dbsize</td><td style="text-align:left">查看当前数据库key的数量</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">flushdb</td><td style="text-align:left">清空当前库</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">flushall</td><td style="text-align:left">清空全部库</td><td style="text-align:left"></td></tr></tbody></table><h4 id="String-操作指令">String 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th></th></tr></thead><tbody><tr><td style="text-align:left">set key value [<code>NX</code></td><td style="text-align:left"><code>XX</code>] [<code>GET</code>][<code>EX seconds</code></td><td style="text-align:left"><code>PX milliseconds</code></td><td><code>EXAT unit-time-milliseconds</code></td></tr><tr><td style="text-align:left">批处理</td><td style="text-align:left">mset key value [key value …]</td><td style="text-align:left">同时设置多个值</td><td></td></tr><tr><td style="text-align:left">mget key value [key value …]</td><td style="text-align:left">同时获取多个值</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">msetnx key value</td><td style="text-align:left">key不存在才设置</td><td style="text-align:left">所有的key都不存在才会设置成功</td><td></td></tr><tr><td style="text-align:left">getrange key <code>start</code> <code>end</code></td><td style="text-align:left">获取指定区域内的值</td><td style="text-align:left"><code>start</code> 开始下标（从0开始）<code>end</code> 结束下标</td><td></td></tr><tr><td style="text-align:left">setrange key <code>offset</code> <code>vaue</code></td><td style="text-align:left">设置指定区域内的值</td><td style="text-align:left"><code>offset</code> 开始下标<code>vaue</code> 设置数量</td><td></td></tr><tr><td style="text-align:left">数值增减（必须是数字才行）</td><td style="text-align:left">INCR key</td><td style="text-align:left">递增数字</td><td></td></tr><tr><td style="text-align:left">INCRBY key <code>increment</code></td><td style="text-align:left">增加减少指定的参数</td><td style="text-align:left"><code>increment</code> 指步长</td><td></td></tr><tr><td style="text-align:left">DECR key</td><td style="text-align:left">递减数值</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">DECRBY key <code>decrement</code></td><td style="text-align:left">减少指定的参数</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">STRLEN key</td><td style="text-align:left">获取字符串长度</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">APPENG key value</td><td style="text-align:left">内容追加</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">分布式锁（原子操作）</td><td style="text-align:left">setnx key value</td><td style="text-align:left">key不存在才设置</td><td>nx: set if not exsit</td></tr><tr><td style="text-align:left">setex key <code>seconds</code> value</td><td style="text-align:left">同时设置值和过期时间</td><td style="text-align:left">ex: set with expire</td><td></td></tr><tr><td style="text-align:left">getset key value</td><td style="text-align:left">先get后set</td><td style="text-align:left">等价于 set key value get</td><td></td></tr></tbody></table><h4 id="List-操作指令">List 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">lpush key value</td><td style="text-align:left">从左边👈设置/添加</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">rpush key value</td><td style="text-align:left">从右边👉设置/添加</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lrange key <code>start</code> <code>stop</code></td><td style="text-align:left">从左边👈开始遍历</td><td style="text-align:left"><code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标<code>lrange key 0 -1</code> 表示遍历全部</td></tr><tr><td style="text-align:left">lpop</td><td style="text-align:left">弹出最左边的值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">rpop</td><td style="text-align:left">弹出最右边的值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lindex</td><td style="text-align:left">按照索引下标获得元素（从上到下）</td><td style="text-align:left">左（上）右（下）</td></tr><tr><td style="text-align:left">llen</td><td style="text-align:left">获取list中的元素个数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lrem key <code>N</code> value</td><td style="text-align:left">删除N值为value的元素</td><td style="text-align:left"><code>N</code> 表示删除值的个数</td></tr><tr><td style="text-align:left">ltrim key <code>start</code> <code>stop</code></td><td style="text-align:left">截取指定索引范围的值再赋值给key</td><td style="text-align:left"><code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标</td></tr><tr><td style="text-align:left">rpoplpush key1 key2</td><td style="text-align:left">从key1中弹出最右边的，加入到key2的最左端并返回</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lset key <code>index</code> value</td><td style="text-align:left">将key中序号为<code>index</code>的值设置为value</td><td style="text-align:left"><code>index</code> 要设置的值的序号（没有该序号则会报错）</td></tr><tr><td style="text-align:left">linsert key before/after <code>pivot</code> <code>element</code></td><td style="text-align:left">在key中值为<code>pivot</code>的元素前/后插入值为<code>element</code>的元素</td><td style="text-align:left"><code>pivot</code> 已有值<code>element</code> 插入值从上向向下👇第一个等于<code>pivot</code>的值</td></tr></tbody></table><h4 id="Set-操作指令">Set 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th></th></tr></thead><tbody><tr><td style="text-align:left">sadd key <code>member</code> [<code>member</code>…]</td><td style="text-align:left">添加元素</td><td style="text-align:left">自动去重</td><td></td></tr><tr><td style="text-align:left">smembers key</td><td style="text-align:left">遍历所有元素</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">sismember key <code>member</code></td><td style="text-align:left">判断元素是否在集合中</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">srem key <code>member</code>[<code>member</code>…]</td><td style="text-align:left">删除元素</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">scard key</td><td style="text-align:left">获取集合里面的元素个数</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">srandmember key [<code>n</code>]</td><td style="text-align:left">从集合中随机展现<code>n</code>个元素，不删除</td><td style="text-align:left"><code>n</code> 展示元素的个数</td><td></td></tr><tr><td style="text-align:left">spop key [<code>n</code>]</td><td style="text-align:left">从集合中随机弹出/删除<code>n</code>个元素</td><td style="text-align:left"><code>n</code> 弹出/删除元素的个数</td><td></td></tr><tr><td style="text-align:left">smove key1 key2 [<code>value</code>]</td><td style="text-align:left">将key1中的某个值<code>value</code>赋值给key2</td><td style="text-align:left"><code>value</code>：key1中的某个值</td><td></td></tr><tr><td style="text-align:left">集合运算</td><td style="text-align:left">sdiff key [key…]</td><td style="text-align:left">差集运算 A - B</td><td></td></tr><tr><td style="text-align:left">sunion key [key…]</td><td style="text-align:left">并运算 A U B</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">sinter key [key…]</td><td style="text-align:left">交运算 A n B</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">sintercard numkeys key [key…] [limit <code>num</code>]</td><td style="text-align:left">只返回基数（去重统计数）</td><td style="text-align:left"><code>num</code> 返回个数</td><td></td></tr></tbody></table><h4 id="ZSet-操作指令">ZSet 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">zadd key [<code>NX</code></td><td style="text-align:left"><code>XX</code>] [<code>GT</code></td><td style="text-align:left"><code>LT</code>] [<code>CH</code>] [<code>INCR</code>] score member [score member …]</td></tr><tr><td style="text-align:left">zrange key <code>start</code> <code>stop</code> [<code>withscores</code>]</td><td style="text-align:left">按照元素分数从小到大的顺序，返回索引从start到stop之间的所有元素</td><td style="text-align:left"><code>withscores</code> 带分数<code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标</td></tr><tr><td style="text-align:left">zrevrange key <code>start</code> <code>stop</code> [<code>withscores</code>]</td><td style="text-align:left">zrange的反转（从大到小）</td><td style="text-align:left"><code>withscores</code> 带分数<code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标</td></tr><tr><td style="text-align:left">zrangebyscore key <code>min</code> <code>max</code> [<code>withscores</code>][<code>limit offset count</code>]</td><td style="text-align:left">获取指定分数范围的元素</td><td style="text-align:left"><code>(min</code> 不包含<code>limit offset count</code> 从<code>offset</code>开始取<code>count</code>个</td></tr><tr><td style="text-align:left">zscore key member</td><td style="text-align:left">获取元素的分数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zcard key</td><td style="text-align:left">获取集合中元素的数量</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zrem key <code>member</code></td><td style="text-align:left">删除值为指定分数的元素</td><td style="text-align:left"><code>member</code> 要删除元素的value值</td></tr><tr><td style="text-align:left">zincrby key <code>increment</code> member</td><td style="text-align:left">增加某个元素的分数</td><td style="text-align:left"><code>increment</code> 增加的值</td></tr><tr><td style="text-align:left">zcount key <code>min</code> <code>max</code></td><td style="text-align:left">获取指定分数范围内的元素个数</td><td style="text-align:left"><code>min</code> 开始<code>max</code> 结束</td></tr><tr><td style="text-align:left">zmpop</td><td style="text-align:left">从键名列表中的第一个非空排序集中弹出一个或多个元素，他们是成员分数对</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zrank key values</td><td style="text-align:left">获取下标值（从0开始）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zrevrank key values</td><td style="text-align:left">逆序获取下标值</td><td style="text-align:left"></td></tr></tbody></table><h4 id="Hash操作指令">Hash操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th></th></tr></thead><tbody><tr><td style="text-align:left">hset key <code>field value</code> [<code>field value</code>…]</td><td style="text-align:left">添加/设置</td><td style="text-align:left"><code>field value</code> 也是某个元素内的属性键值对</td><td></td></tr><tr><td style="text-align:left">hget key field</td><td style="text-align:left">获取键为key的元素中的field属性的值</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">批处理</td><td style="text-align:left">hmset key <code>field value</code> [<code>field value</code>…]</td><td style="text-align:left">批量添加/设置</td><td></td></tr><tr><td style="text-align:left">hget key <code>field</code> [<code>field</code> …]</td><td style="text-align:left">批量获取</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hgetall key</td><td style="text-align:left">获取键为key的元素中的全部属性</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hlen key</td><td style="text-align:left">获取某个key内的全部数量</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hexists key</td><td style="text-align:left">判断是否存在键值为key值（0不存在）</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hkeys key</td><td style="text-align:left">获取键值为key值元素的所有字段名（<code>field</code>）</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hvals key</td><td style="text-align:left">获取键值为key值元素的所有字段值（<code>value</code>）</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hincrby/hincrbyfloat key <code>field</code> <code>increment</code></td><td style="text-align:left">给键值为key值元素中<code>field</code>的字段值加<code>increment</code></td><td style="text-align:left">hincrby 加整数hincrbyfloat 加小数</td><td></td></tr><tr><td style="text-align:left">hsetnx key <code>field value</code> [<code>field value</code>…]</td><td style="text-align:left">不存在才会新建成功</td><td style="text-align:left"></td><td></td></tr></tbody></table><h4 id="GEO-操作指令">GEO 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">geoadd key</td><td style="text-align:left">添加经纬度坐标</td><td style="text-align:left">出现中文乱码，redis-cli启动时加个<code>--raw</code></td></tr><tr><td style="text-align:left">geopos</td><td style="text-align:left">从键里面返回所有给定元素的位置（经纬度）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">geodist key <code>member1</code> <code>member2</code> [<code>m</code></td><td style="text-align:left"><code>km</code></td><td style="text-align:left"><code>ft</code></td></tr><tr><td style="text-align:left">georadius key <code>longitude</code> <code>latitude</code> <code>radius</code> `m</td><td style="text-align:left">km</td><td style="text-align:left">ft</td></tr><tr><td style="text-align:left">georadiusbymember key member <code>radius</code> `m</td><td style="text-align:left">km</td><td style="text-align:left">ft</td></tr><tr><td style="text-align:left">geohash</td><td style="text-align:left">返回坐标的geohash表示</td><td style="text-align:left">geohash算法生成的base32编码值</td></tr></tbody></table><h4 id="HyperLogLog-操作指令">HyperLogLog 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">pfadd key <code>element</code> [<code>element</code>]…</td><td style="text-align:left">添加指定的元素</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">pfcount key [key …]</td><td style="text-align:left">返回给定的基数估计值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">pfmerge <code>destkey</code> <code>sourcekey</code> [<code>sourcekey</code>…]</td><td style="text-align:left">合并统计</td><td style="text-align:left"></td></tr></tbody></table><h4 id="Bitmap-操作指令">Bitmap 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">setbit key <code>offset</code> <code>value</code></td><td style="text-align:left">为键为key的元素序号为<code>offset</code>的值设置值为<code>value</code></td><td style="text-align:left"><code>offset</code> 偏移量（从0开始）<code>value</code> 值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">getbit key <code>offset</code></td><td style="text-align:left">获取指定key的第<code>offset</code>位</td><td style="text-align:left"></td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">strlen key</td><td style="text-align:left">统计字节数占用多少（按字节）</td><td style="text-align:left"></td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">bitcount key <code>start</code> <code>end</code></td><td style="text-align:left">返回指定范围[<code>start</code>, <code>end</code>]内值为1的数量</td><td style="text-align:left"><code>start</code> 开始序号<code>end</code> 结束序号</td><td style="text-align:left">O(n)</td></tr><tr><td style="text-align:left">bitop <code>operation</code> <code>destkey</code> key</td><td style="text-align:left">对不同的二进制存储数据进行位运算（AND、OR、NOT、XOR）</td><td style="text-align:left"><code>operation</code> 包括AND、OR、NOT、XOR<code>destkey</code> 新产生的值的key</td><td style="text-align:left">O(n)</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">从十大数据类型入手Redis，Let&#39;s Go!</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis的单线程和多线程</title>
    <link href="https://www.sadalsuud.cn/posts/ec752e67.html"/>
    <id>https://www.sadalsuud.cn/posts/ec752e67.html</id>
    <published>2024-06-16T11:00:16.000Z</published>
    <updated>2024-06-16T11:11:21.365Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis的单线程和多线程</h1><blockquote><p>Redis到底是多线程还是单线程？</p></blockquote><h5 id="简单回答">简单回答</h5><p>Redis 是从4开始慢慢支持多线程的，直到 Redis6/7 后才稳定</p><h5 id="详解">详解</h5><p>这种问法其实并不严谨，单线程还是多线程需要视<strong>版本</strong>而定。</p><p>Redis的版本很多3.X、4.X、6.X，版本不同架构也是不同的，<strong>不限定版本</strong>问是否单线程也不太严谨。</p><p>版本3.×（最早版本），也就是大家口口相传的Redis是单线程；</p><p>版本4.×，严格意义来说也不是单线程，而是负责处理客户端请求的线程单线程，但是开始加了点多线程的东西（异步删除）；</p><p>版本6.x 开始，<strong>全面支持</strong>多线程。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910297.png" alt="img"></p><h6 id="Redis的“单线程”">Redis的“单线程”</h6><p>Redis的“单线程”主要是指Redis的<strong>网络IO</strong>和<strong>键值对读写</strong>是由<strong>一个线程</strong>来完成的，Redis在处理客户端的请求时包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个<strong>顺序串行的主线程处理</strong>（第一篇介绍过的那些原子的命令），这也是Redis对外提供键值存储服务的主要流程。</p><p>Redis采用<strong>Reactor模式</strong>的网络模型，对于一个客户端请求，主线程负责一个完整的处理过程，如下图：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910736.png" alt="img"></p><p>补充：</p><p>Reactor 模式是一种<strong>并发模型</strong>，在这种模型中，**主线程（Reactor）**避免了由于等待一或多个并发事件（比如 I/O 操作）的完成而无法继续工作的阻塞。通过使用非阻塞 I/O 操作和事件通知，主线程在并发操作完成时得到通知。</p><p>一般来说，Reactor 模式的工作流程如下：</p><ol><li>应用程序将需要<strong>监听的 I/O 事件</strong>（比如 socket 的可读、可写事件）注册到 Reactor 中，并且关联对应的处理事件。</li><li>Reactor 不断地<strong>轮询</strong>这些事件，当某个事件到达的时候（比如 socket 中有数据可读），Reactor 将这个事件对应的处理事件唤醒，交由一个工作线程（或者称之为 EventHandler）去处理。</li><li>工作线程处理完相应的事件后，通知 Reactor <strong>继续监听</strong>这个事件。</li></ol><p>这种模型非常适合于<strong>大并发，少逻辑</strong>的网络程序中，比如 Nginx 中就用到了这种设计模式。通过这种方式，一个线程可以处理很多连接的事件，而不需要为每个连接都创建一个线程，这样就可以避免线程切换的开销，并且可以更有效地使用系统资源。</p><p>但Redis的其他功能，比如持久化RDB、AOF、异步删除、集群同步数据等都是由额外的线程执行的，因此整个Redis可以看作是多线程的。</p><h6 id="Redis为什么选择单线程？">Redis为什么选择单线程？</h6><p>准确的说，应该是Redis 4.0之前一直采用单线程</p><p>主要原因有：</p><ul><li>使用单线程模型使Redis的<strong>开发和维护更简单</strong></li><li>虽然使用的是单线程，但也可以<strong>并发处理多客户端的请求</strong>（IO多路复用和非阻塞IO）</li><li>对于Redis系统来说，主要的性能瓶颈是<strong>内存</strong>/<strong>网络带宽</strong>，而非CPU</li></ul><h6 id="后来Redis为什么又逐渐加入了多线程特性？">后来Redis为什么又逐渐加入了多线程特性？</h6><ul><li><p>硬件的发展</p></li><li><ul><li>CPU并不是Redis的瓶颈，通常Redis要不受内存限制要不受网络限制，但是随着计算机硬件的发展，多核CPU已经成为常态，为了更大限度的利用CPU</li></ul></li><li><p>单线程的缺点</p></li><li><ul><li>Redis使用单线程也是有一定缺点的，比较典型的就是使用del指令删除大key数据时（比如包含了成千上万个元素的hash集合，关于大key的问题我们会在Redis系列的下一篇专门介绍，这里先简单举个例子），del指令就会造成主线程卡顿。</li><li>由于Redis3.x完全是单线程的，del指令删除时会等待⌛️很久才释放，如果再加上高并发场景(˶‾᷄ ⁻̫ ‾᷅˵)额。。这就是Redis3.x单线程时代最经典的故障，大key删除的头疼问题，于是Redis4.0就新增了多线程模块，也主要是为了解决这个问题。</li><li>此外例如flushdb还有flushall在数据量达到一定程度时，也会造成卡顿，因此一开始Redis就是把某些时间复杂度高，占主线程CPU时间片较高，造成主线程卡顿的操作使用多线程来处理（bio子线程），以减少主线程阻塞时间，从而减少那个诸如del操作导致性能和稳定性的问题。</li></ul></li></ul><p>总的来说，就是<strong>与时俱进</strong>(￣∇￣)/🎉～～～</p><h4 id="Redis为什么快？">Redis为什么快？</h4><h5 id="回答">回答</h5><p>Redis 3.0 单线程时代依旧很快的原因：</p><ul><li><strong>基于内存操作</strong>：Rdis的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高</li><li><strong>数据结构简单</strong>：Rdis的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是O(1)，因此性能比较高</li><li><strong>多路复用和非阻塞I/O</strong>：Redis使用多路复用功能来监听多个socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的</li><li><strong>避免上下文切换</strong>：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程</li></ul><p>现在Redis快的原因</p><p>在上面原因的基础上</p><ul><li><strong>IO多路复用</strong> + <strong>epoll函数</strong>使用</li></ul><p>接下来我们详细介绍下IO多路复用</p><h3 id="IO多路复用">IO多路复用</h3><p>IO多路复用（IO multiplexing）是Unix网络编程的5种IO模型之一。</p><h4 id="Unix网络编程的5种IO模型">Unix网络编程的5种IO模型</h4><ul><li>Blocking IO 阻塞IO</li><li>NoneBlocking IO 非阻塞IO</li><li>IO multiplexing IO 多路复用</li><li>signal driven IO 信号驱动IO</li><li>asynchronous IO 异步IO</li></ul><p>Redis一直被大家熟知的就是它的单线程架构，虽然从Redis4.0开始使用了多线程，也是为了处理数据删除、快照删除等耗时操作，从网络IO处理到实际的读写命令处理都是由主线程独自处理的（心疼下主线程）。</p><p>在Redis 6/7中，Redis全面支持了多线程。这是由于随着硬件性能的提升，Redis的性能瓶颈主要出现在网络IO上，就是完全靠单个主线程处理网络请求的速度跟不上底层网络硬件的速度，于是采用多个线程处理网络IO，提高网络请求处理的并行度。</p><p>但是，<strong>Redis的多IO线程只是用来处理网络请求</strong>的，对于<strong>读写操作命令 Redis 仍然使用单线程</strong>来处理。这是因为，Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程互斥加锁机制了（不管加锁操作处理），这样一来，Redis 线程模型实现就简单了。</p><h4 id="主线程和IO线程怎么协作完成请求处理的">主线程和IO线程怎么协作完成请求处理的</h4><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910462.png" alt="img"></p><h5 id="四个阶段">四个阶段</h5><ul><li>阶段一：服务端和客户端建立Socket连接，并分配处理线程 首先，<strong>主线程</strong>负责接收<strong>建立连接请求</strong>，当有客户端请求和实例建立Socket连接时，主线程会<strong>创建和客户端的连接</strong>，<strong>并把Socket放入全局等待队列中</strong>，紧接着，<strong>主线程通过轮询方法把Socket连接分配给IO线程</strong>。</li><li>阶设二：IO线程读取并解折请求 主线程一旦把Socket分配给IO线程，就会进入阻塞状态，等待IO线程完成客户端请求的读取和解析，因为有多个IO线程在并行处理，所以，这个过程很快就可以完成。</li><li>阶段三：主线程执行请求操作 等到IO线程解析完请求，<strong>主线程</strong>还是会以单线程的方式<strong>执行这些命令操作。</strong></li><li>阶设四：IO线程回写Socket和主线程清空全局队列 当<strong>主线程执行完请求操作后，会把需要返回的结果写入缓冲区</strong>，然后，<strong>主线程会阻塞等待IO线程</strong>，把这些结果回写到Socket中，并返回给客户端。和IO线程读取和解析请求一样，IO线程回写Socket时，也是有多个线程在并发执行，所以回写Socket的速度也很快。等到IO线程回写Socket完毕，主线程会清空全局队列，等待客户端的后续请求。</li></ul><h4 id="浅谈IO多路复用">浅谈IO多路复用</h4><p>由于IO多路复用（IO multiplexing）是Unix网络编程的5种IO模型之一，我们先介绍下Linux的相关内容，便于理解（熟悉的人可以直接跳到下一趴）。</p><p>在Linux中，一切皆文件，这就要提到“文件描述符”这个概念了。</p><h5 id="文件描述符（FileDescriptor-FD）">文件描述符（FileDescriptor, FD）</h5><p>文件描述符是计算机科学中的一个术语，是一个用于表述<strong>指向文件的引用</strong>的抽象化概念。</p><p>文件描述符在形式上是一个非负整数，实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符。</p><p>在程序设计中，文件描述符这一概念往往只适用于UNIX或者Linux这样的操作系统。</p><h5 id="什么是IO多路复用">什么是IO多路复用</h5><p>一种同步的IO模型，实现一个线程监视多个文件句柄，一旦某个文件句柄就绪，就能通知到对应程序进行相应的读写操作，没有文件句柄就绪时，就会阻塞应用程序，从而释放CPU资源。</p><p>我们来介绍几个概念：</p><ul><li><p>I/O</p></li><li><ul><li>网络I/O，尤其在操作系统层面指数据在内核态和用户态之间的读写操作</li></ul></li><li><p>多路</p></li><li><ul><li>多个客户端连接（连接就是套接字描述符，即socket或者channel）</li></ul></li><li><p>复用</p></li><li><ul><li>复用一个或者几个线程连接</li></ul></li><li><p>IO多路复用</p></li><li><ul><li>也就是说一个或者一组线程处理多个TCP，使用单进程就能实现同时处理多个客户端的连接，无需创建或者维护过多的进程/线程</li></ul></li></ul><p>总结</p><ul><li>一个服务端进程可以同时处理多个套接字描述符</li><li>实现多路复用的模型有3种：可以分select-&gt;poll-&gt;epoll3个阶段来描述</li></ul><h5 id="场景模拟">场景模拟</h5><p>不知道大家有没有注意过麻辣烫店是怎么做煮麻辣烫的，他们可不是一碗一碗单独的锅单独的灶煮的（太费💰），一般是有一个方形大锅，整个锅里加满水，下面一个灶加热，大锅里分成一个个小格子（就类似重庆火锅那种九宫格），每个小格子里煮一个客人选的菜。</p><p>基本流程就是，客人选完菜去收银那里称斤付款（人多则需要排队），服务员每收到一个客人选的菜，就把它们倒进一个小格子里煮，然后再回来收下一位的……还会时不时看看哪个小格子里的菜熟了，就把它盛到碗里，端回给客人</p><p>我们根据模拟情景来简单概括下IO多路复用模型：</p><p>将用户Socket对应的文件描述符（FileDescriptor）注册进epoll，然后epoll帮你监听哪些Socket上有消息到达，这样就避免了大量的无用操作，此时的Socket应该采用非阻塞模式，这样整个过程只在调用select、poll、epoll这些函数是才会阻塞，收发客户消息是不会阻塞的，整个进程/线程就会被充分利用起来，这就是事件驱动，所谓的reactor反应模式。</p><p>在单个线程通过<strong>记录跟踪每一个Socket（I/O流）的状态</strong>来同时管理多个I/O流，一个服务端进程可以同时处理多个套接字描述符，以此来<strong>提高服务器的吞吐能力</strong>。</p><p>大家都用过nginx，nginx使用epoll接收请求，ngnix会有很多链接进来，epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。Redis类似同理，这就是IO多路复用原理，有请求就响应，没请求不打扰。</p><p>IO多路复用达到的效果就是只使用一个服务端进程可以同时处理多个套接字描述符连接。</p><p>客户端请求服务端时，实际就是在服务端的Socket文件中写入客户端对应的文件描述符（FileDescriptor），如果有多个客户端同时请求服务端，为每次请求分配一个线程，类似每次来就new一个太耗费服务端资源，因此，只使用一个线程来监听多个文件描述符，即IO多路复用。</p><p>采用IO多路复用技术可以让单个线程高效的处理多个连接请求，一个服务端进程可以同时处理多个套接字描述符。</p><p>从Rdis6开始，就新增了多线程的功能来提高I/O的读写性能，他的主要实现思路是<strong>将主线程的IO读写任务拆分给一组独立的线程去执行</strong>，这样就可以使多个Socket的读写可以并行化了，采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗)，将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910584.png" alt="img"></p><p>于是，网络IO操作就变成多线程了，其他核心操作仍然是主线程单独处理（线程安全）</p><h4 id="总结">总结</h4><ul><li>Redis的工作线程是单线程的，但是整个Redis是多线程的</li><li>Redis6/7将网络数据读写、请求协议解析通过多个IO线程来处理，真正执行命令的线程仍然是主线程单独进行操作（单线程），一举两得，既解决网络IO问题（多个IO线程），有保证了线程安全且处理方式简单（单线程执行命令）</li></ul><h3 id="Redis-7-默认设置是否开启了多线程？">Redis 7 默认设置是否开启了多线程？</h3><p>如果你在实际应用中，发现Redis实例的CPU开销不大但吞吐量却没有提升，可以考虑使用Reds7的多线程机制（默认关闭，需手动开启），加速网络处理，进而提升实例的吞吐量。</p><p>Redis7将所有的数据放在内存中，内存的响应时长大约为100纳秒，对于小数据，Redis服务器可以处理8W到10W的QPS（实验室数据，极限），但是对于大部分的公司已经够用了，所以在Redis6.0以后，多线程机制默认是关闭的，如果需要使用，则要在redis.conf配置文件中修改，主要改两个地方：</p><ol><li>设置io-threads-do-redis配置项为yes，表示启动多线程</li><li>设置线程个数，io-threads 个数，关于个数的设置，官方的建议是如果为4核的CPU，建议线程数设置为2或3，如果为8核CPU建议线程数设置为6（线程数一定要小于机器核数，并非越大越好）</li></ol><h3 id="总结-2">总结</h3><p>Redis基于<strong>内存操作</strong>、<strong>数据结构简单</strong>、<strong>多路复用</strong>和<strong>非阻塞I/O</strong>等特性，避免了不必要的上下文切换，在单线程的环境下依旧很快。但对于大数据的key删除还是会卡顿，因此在4.0版本中引入了多线程unlink key/flushall async等命令，主要用于Redis数据的异步删除。而在Redis6/7中引入了I/O多线程的读写，增加了吞吐量，而<strong>命令的执行依旧是有主线程串行执行的</strong>，因此在多线程下操作Redis既<strong>能保持良好的性能</strong>和<strong>响应速度</strong>，并且<strong>不会出现线程安全的问题</strong>。</p><h3 id="相关链接">相关链接</h3><p><a href="https://blog.csdn.net/aqin1012/article/details/131944713">【Redis】高级篇： 一篇文章讲清楚Redis的单线程和多线程_redis的i文件描述符-CSDN博客</a></p>]]></content>
    
    
    <summary type="html">Redis到底是多线程还是单线程？</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>无职转GO？入了Golang的坑就要好好看不起Java</title>
    <link href="https://www.sadalsuud.cn/posts/745a3632.html"/>
    <id>https://www.sadalsuud.cn/posts/745a3632.html</id>
    <published>2024-06-16T10:50:07.000Z</published>
    <updated>2024-06-16T11:00:26.822Z</updated>
    
    <content type="html"><![CDATA[<h1>无职转GO？入了Golang的坑就要好好看不起Java</h1><h2 id="Part-1-Go的优势？"><em><strong>Part.1 Go的优势？</strong></em></h2><p>Go是一种由谷歌公司开发的编程语言，也被称为Golang。相较于其他编程语言，Go有一些明显的优势：</p><p>1.并发处理能力：Go天生支持并发，应用于Web<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065">服务器</a>开发中非常合适。</p><p>2.快速编译：Go编译器可以快速生成机器码，大大提高了开发效率。</p><p>3.内存管理：Go拥有高效的垃圾回收机制，确保了程序运行时的稳定性。</p><p>以上优势使得Go适合用于高并发的Web服务和分布式系统开发，而这正是字节跳动所必须面对的。</p><h2 id="Part-2-架构设计？"><em><strong>Part.2 架构设计？</strong></em></h2><p>字节跳动在选择Go作为服务器端开发语言后，还进行了架构设计。在这个设计中，主要有以下几个方面的考虑：</p><p>1.高可扩展性：采用分布式架构，加上云服务的支持，在用户规模激增时依然能保证服务的平稳运行。</p><p>2.模块化开发：对于大型项目，采用模块化开发能有效地提高开发和维护的效率。</p><p>3.可重用性：将一些常用的代码封装成工具包，可以在别的项目中重用，从而避免重复工作。</p><p>4.监控和异常处理：在系统运行过程中，需要对运行情况进行监控和异常处理，这是重要的工作之一。</p><p>以上架构设计方案，使得字节跳动的Go开发团队能更好地应对业务需求的复杂性和日益增长的用户规模。</p><h2 id="Part-3-应用场景？"><em><strong>Part.3 应用场景？</strong></em></h2><p>在字节跳动的基础设施中，Go年日处理能力已经达到了几千万级别。此外，在字节跳动的多个应用场景中，Go也展现出了非常良好的性能表现：</p><p>1.推送服务：字节跳动在推送服务中使用了Go，不仅性能出色，而且可以轻松实现服务的扩展。</p><p>2.搜索服务：在搜索服务中，Go的高并发处理能力和快速编译速度得到了充分发挥。</p><p>3.<a href="https://cloud.tencent.com/product/vts?from_column=20065&amp;from=20065">视频转码</a>服务：通过Go的协程和通道特性，可以很好地实现视频转码的任务并发处理。</p><p>以上应用场景可以看出，Go作为服务器端开发语言，在高并发和大规模业务应用场景下有着非常出色的表现。</p><p>选择一种优秀的服务器端开发语言是非常重要的。Go是一种适合高并发Web服务和分布式系统开发的语言，而且具有快速编译、内存管理和并发处理等诸多优势。字节跳动选择Go作为服务器端开发语言，并进行了相应的架构设计和优化，从而实现了高可扩展性、模块化开发、可重用性和监控异常处理等目标。在多个场景应用中，Go也展现出了非常良好的性能表现。选择Go，是字节跳动成功发展的关键之一。</p><h2 id="Part-4-Go语言的高并发特性？"><em><strong>Part.4  Go语言的高并发特性？</strong></em></h2><h3 id="1-引言：Go语言高并发的背景和意义"><strong>1. 引言：Go语言高并发的背景和意义</strong></h3><p>随着互联网发展，由于大量的用户并发访问，高并发成为了应用程序的一个大问题。Go语言因为其设计的简洁性、优良的并发特性、强大的语法等特点而受到了广泛的欢迎。Go语言的高并发特性为开发者处理高并发问题提供了便捷的手段，极大地提高了程序的运行效率。</p><h3 id="2-Goroutine：Go语言高并发的基石"><strong>2. Goroutine：Go语言高并发的基石</strong></h3><h4 id="2-1-Goroutine是什么？"><em><strong>2.1 Goroutine是什么？</strong></em></h4><p>Goroutine是Go语言中实现并发的一种机制，可以理解为“轻量级线程”，相较于传统的线程，它的创建和销毁的开销都非常小，可以同时运行上万个 goroutine 而不会占用过多的内存。在 Go 语言中，通过 go 关键字就可以启动一个 goroutine。</p><h4 id="2-2-Goroutine的调度器"><em><strong>2.2 Goroutine的调度器</strong></em></h4><p>Go语言的 Goroutine 调度器是 Go 语言运行时系统的一部分，采用的是协程和线程的混合调度方式（M：N调度），可根据硬件真实线程资源进行动态调整，保证了并发和性能之间的平衡。</p><h4 id="2-3-Goroutine的轻量级"><em><strong>2.3 Goroutine的轻量级</strong></em></h4><p>Goroutine 的创建和销毁非常轻量级，在 go 语言中可以在短时间内创建大量的 Goroutine。Goroutine 的栈空间大小只有2KB，因此每个 Goroutine 的内存占用非常小。</p><h3 id="3-Channel：多Goroutine之间通讯的桥梁"><strong><strong>3. Channel：多Goroutine之间通讯的桥梁</strong></strong></h3><h4 id="3-1-Channel的定义和声明"><em><strong>3.1 Channel的定义和声明</strong></em></h4><p>Go 语言内置了两种类型的Channel，分别为带缓冲区的和不带缓冲区的，以下是带缓存Channel的定义和声明：</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">make</span>(chan <span class="title class_">Type</span>, bufferSize)</span><br></pre></td></tr></table></figure><h4 id="3-2-Channel的用法"><em><strong>3.2 Channel的用法</strong></em></h4><p>Go语言的Channel在Goroutine协作上有着极大的作用，可以在其中一个Goroutine卡主等待其协程取走，或者多个Goroutine之间进行数据传递与同步，比如：</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// go程之间通信，初始化一个channel类型变量</span></span><br><span class="line">    msg := <span class="title function_">make</span>(chan string, <span class="number">1</span>)</span><br><span class="line">    go <span class="title function_">func</span>(<span class="params"></span>) &#123; msg &lt;- <span class="string">&quot;Hello World&quot;</span> &#125;()</span><br><span class="line">    <span class="comment">// 读取信息</span></span><br><span class="line">    res := <span class="language-xml">&lt;-msg</span></span><br><span class="line"><span class="language-xml">    fmt.Println(res)</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Channel的底层实现"><em><strong>3.3 Channel的底层实现</strong></em></h4><p>可以将channel看作一个队列，先进先出，底层是由互斥锁和条件变量实现的。在有缓冲的情况下，队列容量不会扩张，超出容量部分的元素向队列内添加时将会阻塞作者Goroutine，队列为空时在读取队列中的元素时也会阻塞执行者Goroutine。在无缓存模式下，通道没有额外的缓冲区，每个接收者都会阻塞，直到发送者将值发送到通道中。</p><h3 id="4-select：多路复用的神器"><strong>4. select：多路复用的神器</strong></h3><h4 id="4-1-select的基本语法和作用"><em><strong>4.1 select的基本语法和作用</strong></em></h4><p>select 语句是Go语言中用于处理异步 IO 操作的一个关键子句，使用 select 可以监听多个 channel 的数据流动，一旦其中某个 channel 有数据流动，则对应的case分支就会被执行。</p><h4 id="4-2-select和Channel的结合"><em><strong>4.2 select和Channel的结合</strong></em></h4><p>在读写Channel时可以结合使用select语句，比如：</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="title function_">customSleep</span>(<span class="params">s int</span>) &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="language-xml">&lt;-time.After(time.Duration(s) * time.Second):</span></span><br><span class="line"><span class="language-xml">        return</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">func main() &#123;</span></span><br><span class="line"><span class="language-xml">    fmt.Println(&quot;Start&quot;)</span></span><br><span class="line"><span class="language-xml">    customSleep(5)</span></span><br><span class="line"><span class="language-xml">    fmt.Println(&quot;End&quot;)</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码通过 select 监听 time.After() 的 channel，当该 channel 被触发，则 customSleep() 中的 goroutine 将会退出。</p><h3 id="5-并发安全的特性"><strong>5. 并发安全的特性</strong></h3><h4 id="5-1-原子操作和互斥锁"><em><strong>5.1 原子操作和互斥锁</strong></em></h4><p>Go语言的并发特性支持原子操作和互斥锁来保证程序的并发安全。可以通过 atomic 包实现原子操作，通过 sync 包实现互斥锁，从而解决多个 Goroutine 同时访问共享资源的问题。</p><h4 id="5-2-WaitGroup和Once的使用"><em><strong>5.2 WaitGroup和Once的使用</strong></em></h4><p>sync 包中提供的 WaitGroup 和 Once 分别用于等待组和执行一次的场景。比如WaitGroup可以用来等待所有 Goroutine 完成后再执行下一步操作，Once可以用来确保某个函数只被执行一次。</p><h4 id="5-3-其他的并发安全特性"><em><strong>5.3 其他的并发安全特性</strong></em></h4><p>Go语言还提供了一些其他的并发安全的特性，比如Mutex、RWMutex等，这些特性允许多个 Goroutine 同时读取一个资源，但是只允许一个 Goroutine 写入数据，在写入数据时，所有 Goroutine 都需要等待，从而避免了并发写入造成的数据竞争和语义混乱的情况。</p><p>本文详细介绍了Go语言高并发的特点和优势，主要包括Goroutine、Channel、select、并发安全等多个方面。Go语言的高并发特性在应对互联网大规模并发访问方面提供了极大的便利，让程序员能够很方便地编写高效、稳定的并发程序。</p><h2 id="总结">总结</h2><p>Go语言（Golang）由谷歌开发，具有并发处理能力强、编译速度快和内存管理高效等优势，非常适用于高并发Web服务和分布式系统。字节跳动采用Go语言，并通过模块化开发、高可扩展性和监控异常处理等架构设计，实现了高效的推送、搜索和视频转码服务，成功应对了复杂业务需求和用户增长。Go语言的Goroutine、Channel和select等特性极大地提高了程序的并发处理能力和运行效率。</p>]]></content>
    
    
    <summary type="html">无职转GO？入了Golang的坑就要好好看不起Java。字节的业务已经大部分转向Go，在公司技术发展中，选择一种适合自己的开发语言非常重要。那么，为什么字节跳动选择了Go作为服务器端开发语言呢？</summary>
    
    
    
    <category term="Go" scheme="https://www.sadalsuud.cn/categories/Go/"/>
    
    
    <category term="Go" scheme="https://www.sadalsuud.cn/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>SQL基础知识总结</title>
    <link href="https://www.sadalsuud.cn/posts/badad45e.html"/>
    <id>https://www.sadalsuud.cn/posts/badad45e.html</id>
    <published>2024-06-15T10:49:31.000Z</published>
    <updated>2024-06-15T11:03:41.105Z</updated>
    
    <content type="html"><![CDATA[<h1>SQL基础知识总结</h1><h2 id="一、SQL-概述">一、SQL 概述</h2><h3 id="1、什么是-SQL">1、什么是 SQL</h3><p>==SQL（Structured Query Language）==是“结构化<a href="https://so.csdn.net/so/search?q=%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80&amp;spm=1001.2101.3001.7020">查询语言</a>”，它是对关系型数据库的操作语言。它可以应用到所有关系型数据库中，例如：MySQL、Oracle、SQL Server 等。SQL 标准（ANSI/ISO）有：</p><ul><li>SQL-92：1992 年发布的 SQL 语言标准；</li><li>SQL:1999：1999 年发布的 SQL 语言标签；</li><li>SQL:2003：2003 年发布的 SQL 语言标签；</li></ul><p>这些标准就与 JDK 的版本一样，在新的版本中总要有一些语法的变化。不同时期的数据库对不同标准做了实现。</p><p>虽然 SQL 可以用在所有<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&amp;spm=1001.2101.3001.7020">关系型数据库</a>中，但很多数据库还都有标准之后的一些语法，我们可以称之为“方言”。例如 MySQL 中的 LIMIT 语句就是 MySQL 独有的方言，其它数据库都不支持！当然，Oracle 或 SQL Server 都有自己的方言。</p><h3 id="2、语法要求">2、语法要求</h3><ul><li>SQL 语句可以单行或多行书写，以分号结尾；</li><li>可以用空格和缩进来来增强语句的可读性；</li><li>关键字不区别大小写，建议使用大写；</li></ul><hr><h2 id="二、SQL-分类">二、SQL 分类</h2><ul><li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</li><li>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</li><li>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</li><li>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）</li></ul><h2 id="三、DDL（Data-Definition-Language）：数据定义语言">三、DDL（Data Definition Language）：数据定义语言</h2><h3 id="基本操作">基本操作</h3><p>查看所有数据库：show databases；</p><p>切换数据库：use mydb1，切换到 mydb1 数据库；</p><h3 id="1-操作数据库">1.操作数据库</h3><ol><li>创建数据库：CREATE DATABASE [IF NOT EXISTS] mydb1；</li></ol><p>例如：<code>CREATE DATABASE mydb1</code>，创建一个名为 mydb1 的数据库。如果这个数据已经存在，那么会报错。<br>例如 <code>CREATE DATABASE IF NOT EXISTSmydb1</code>，在名为 mydb1 的数据库不存在时创建该库，这样可以避免报错。</p><hr><ol><li>删除数据库：DROP DATABASE [IF EXISTS] mydb1；</li></ol><p>例如：<code>DROP DATABASE mydb1</code>，删除名为 mydb1 的数据库。如果这个数据库不存在，那么会报错。DROP DATABASE IF EXISTS mydb1，就算 mydb1不存在，也不会的报错。</p><hr><ol><li>修改数据库编码：ALTER DATABASE mydb1 CHARACTER SET utf8</li></ol><p>修改数据库 mydb1 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都<br>不能使用中间的<code>“-”</code>，即 UTF-8 要书写为 UTF8。</p><hr><h3 id="2-数据类型">2.数据类型</h3><p>MySQL 与 Java、C 一样，也有数据类型MySQL 中数据类型主要应用在列上。<br>常用类型：</p><ul><li><strong>int</strong>：整型</li><li><strong>double</strong>：浮点型，例如 double(5,2)表示最多 5 位，其中必须有 2 位小数，即最大值为 999.99；</li><li><strong>decimal</strong>：泛型型，在表单线方面使用该类型，因为不会出现精度缺失问题；</li><li><strong>char</strong>：固定长度字符串类型；(当输入的字符不够长度时会补空格)</li><li><strong>varchar</strong>：固定长度字符串类型；</li><li><strong>text</strong>：字符串类型；</li><li><strong>blob</strong>：字节类型；</li><li><strong>date</strong>：日期类型，格式为：yyyy-MM-dd；</li><li><strong>time</strong>：时间类型，格式为：hh:mm:ss</li><li><strong>timestamp</strong>：时间戳类型；</li></ul><h3 id="3-操作表">3.操作表</h3><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">列名 列类型, </span><br><span class="line">列名 列类型,</span><br><span class="line">...... </span><br><span class="line">);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>例如，创建stu表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">sid <span class="type">CHAR</span>(<span class="number">6</span>), </span><br><span class="line">sname <span class="type">VARCHAR</span>(<span class="number">20</span>), </span><br><span class="line">age <span class="type">INT</span>, </span><br><span class="line">gender <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>查看表的结构</p><p>DESC 表名；</p><p>删除表</p><p>DROP TABLE 表名；</p><p>修改表</p><ol><li>添加列：给 stu 表添加 classname 列<br><code>ALTER TABLE stu ADD (classname varchar(100));</code></li><li>修改列的数据类型：修改 stu 表的 gender 列类型为 CHAR(2)<br><code>ALTER TABLE stu MODIFY gender CHAR(2);</code></li><li>修改列名：修改 stu 表的 gender 列名为 sex<br><code>ALTER TABLE stu change gender sex CHAR(2);</code></li><li>删除列：删除 stu 表的 classname 列<br><code>ALTER TABLE stu DROP classname;</code></li><li>修改表名称：修改 stu 表名称为 student<br><code>ALTER TABLE stu RENAME TO student;</code></li></ol><hr><h2 id="四、DML（Data-Manipulation-Language）：数据操作语言">四、DML（Data Manipulation Language）：数据操作语言</h2><h3 id="1-插入数据">1.插入数据</h3><p>语法 1：<br><code>INSERT INTO 表名(列名 1,列名 2, …) ;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(sid, sname,age,gender) <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1001&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(sid, sname) <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1001&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>语法 2：<br><code>INSERT INTO 表名 VALUES(值 1,值 2,…);</code><br>因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1002&#x27;</span>, <span class="string">&#x27;liSi&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意：所有字符串数据必须使用单引用！</strong></p><h3 id="2-修改数据">2.修改数据</h3><p>语法：<br><code>UPDATE 表名 SET 列名 1=值 1, … 列名 n=值 n [WHERE 条件];</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’zhangSanSan’, age<span class="operator">=</span>’<span class="number">32</span>’, gender<span class="operator">=</span>’female’ <span class="keyword">WHERE</span> sid<span class="operator">=</span>’s_1001’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’liSi’, age<span class="operator">=</span>’<span class="number">20</span>’<span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">50</span> <span class="keyword">AND</span> gender<span class="operator">=</span>’male’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’wangWu’, age<span class="operator">=</span>’<span class="number">30</span>’<span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">60</span> <span class="keyword">OR</span> gender<span class="operator">=</span>’female’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> gender<span class="operator">=</span>’female’<span class="keyword">WHERE</span> gender <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> sname<span class="operator">=</span>’zhaoLiu’;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h3 id="3-删除数据">3.删除数据</h3><p>语法 1：<br><code>DELETE FROM 表名 [WHERE 条件];</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sid<span class="operator">=</span>’s_1001’<span class="number">003</span>B;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname<span class="operator">=</span>’chenQi’ <span class="keyword">OR</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>语法 2：<br>TRUNCATE TABLE 表名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> stu;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>两者之间的区别：<br>虽然 TRUNCATE 和 DELETE 都可以删除表的所有记录，但有原理不同。DELETE的效率没有 TRUNCATE 高！<br>TRUNCATE 其实属性 DDL 语句，因为它是先 DROP TABLE，再 CREATE TABLE。<br>而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的（回滚是事务的知识！）。</p><hr><h2 id="五、DCL（Data-Control-Language）：数据控制语言">五、DCL（Data Control Language）：数据控制语言</h2><h3 id="1-创建用户">1.创建用户</h3><p>语法：<br><code>CREATE USER ‘用户名’@地址 IDENTIFIED BY '密码';</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘user1’<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> ‘<span class="number">123</span>’;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘user2’@’<span class="operator">%</span>’ IDENTIFIED <span class="keyword">BY</span> ‘<span class="number">123</span>’;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="2-给用户授权">2.给用户授权</h3><p>语法：<br><code>GRANT 权限 1, … , 权限 n ON 数据库.* TO ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">TO</span> user2<span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="3-撤销授权">3.撤销授权</h3><p>语法：<br><code>REVOKE 权限 1, … , 权限 n ON 数据库.* FROM ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4-查看用户权限">4.查看用户权限</h3><p>语法：<br><code>SHOW GRANTS FOR ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="5-删除用户">5.删除用户</h3><p>语法：<br><code>DROP USER ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> ‘user1’<span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="6-修改用户密码（以root身份）">6.修改用户密码（以root身份）</h3><p>语法 ：<br><code>use mysql;</code><br><code>alter user '用户名'@localhost identified by '新密码';</code></p><hr><h2 id="六、DQL（Data-Query-Language）：数据查询语言">六、DQL（Data Query Language）：数据查询语言</h2><p>数据库执行 DQL 语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p><p>语法：<br>select 列名 ----&gt; 要查询的列名称<br>from 表名 ----&gt; 要查询的表名称<br>where 条件 ----&gt; 行条件<br>group by 分组列 ----&gt; 对结果分组<br>having 分组条件 ----&gt; 分组后的行条件<br>order by 排序列 ----&gt; 对结果分组<br>limit 起始行, 行数 ----&gt; 结果限定</p><h3 id="创建数据库：Info，在-Info-下创建如下表：">创建数据库：Info，在 Info 下创建如下表：</h3><p>☆学生表：stu：<br><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/2021021301182633.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903498.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line">sid <span class="type">CHAR</span>(<span class="number">6</span>), </span><br><span class="line">sname <span class="type">VARCHAR</span>(<span class="number">50</span>), </span><br><span class="line">age <span class="type">INT</span>, </span><br><span class="line">gender <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1001&#x27;</span>, <span class="string">&#x27;liuYi&#x27;</span>, <span class="number">35</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1002&#x27;</span>, <span class="string">&#x27;chenEr&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1003&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>, <span class="number">95</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1004&#x27;</span>, <span class="string">&#x27;liSi&#x27;</span>, <span class="number">65</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1005&#x27;</span>, <span class="string">&#x27;wangWu&#x27;</span>, <span class="number">55</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1006&#x27;</span>, <span class="string">&#x27;zhaoLiu&#x27;</span>, <span class="number">75</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1007&#x27;</span>, <span class="string">&#x27;sunQi&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1008&#x27;</span>, <span class="string">&#x27;zhouBa&#x27;</span>, <span class="number">45</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1009&#x27;</span>, <span class="string">&#x27;wuJiu&#x27;</span>, <span class="number">85</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1010&#x27;</span>, <span class="string">&#x27;zhengShi&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1011&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p>☆雇员表：emp<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903446.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">empno <span class="type">INT</span>, </span><br><span class="line">ename <span class="type">VARCHAR</span>(<span class="number">50</span>), </span><br><span class="line">job <span class="type">VARCHAR</span>(<span class="number">50</span>), </span><br><span class="line">mgr <span class="type">INT</span>, </span><br><span class="line">hiredate <span class="type">DATE</span>,</span><br><span class="line">sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>), </span><br><span class="line">comm <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>), </span><br><span class="line">deptno <span class="type">INT</span></span><br><span class="line">) ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7369</span>,<span class="string">&#x27;SMITH&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7902</span>,<span class="string">&#x27;1980-12-17&#x27;</span>,<span class="number">800</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7499</span>,<span class="string">&#x27;ALLEN&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-02-20&#x27;</span>,<span class="number">1600</span>,<span class="number">300</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7521</span>,<span class="string">&#x27;WARD&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-02-22&#x27;</span>,<span class="number">1250</span>,<span class="number">500</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7566</span>,<span class="string">&#x27;JONES&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="number">7839</span>,<span class="string">&#x27;1981-04-02&#x27;</span>,<span class="number">2975</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7654</span>,<span class="string">&#x27;MARTIN&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-09-28&#x27;</span>,<span class="number">1250</span>,<span class="number">1400</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7698</span>,<span class="string">&#x27;BLAKE&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="number">7839</span>,<span class="string">&#x27;1981-05-01&#x27;</span>,<span class="number">2850</span>,<span class="keyword">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7782</span>,<span class="string">&#x27;CLARK&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="number">7839</span>,<span class="string">&#x27;1981-06-09&#x27;</span>,<span class="number">2450</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7788</span>,<span class="string">&#x27;SCOTT&#x27;</span>,<span class="string">&#x27;ANALYST&#x27;</span>,<span class="number">7566</span>,<span class="string">&#x27;1987-04-19&#x27;</span>,<span class="number">3000</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7839</span>,<span class="string">&#x27;KING&#x27;</span>,<span class="string">&#x27;PRESIDENT&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;1981-11-17&#x27;</span>,<span class="number">5000</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7844</span>,<span class="string">&#x27;TURNER&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-09-08&#x27;</span>,<span class="number">1500</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7876</span>,<span class="string">&#x27;ADAMS&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7788</span>,<span class="string">&#x27;1987-05-23&#x27;</span>,<span class="number">1100</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7900</span>,<span class="string">&#x27;JAMES&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-12-03&#x27;</span>,<span class="number">950</span>,<span class="keyword">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7902</span>,<span class="string">&#x27;FORD&#x27;</span>,<span class="string">&#x27;ANALYST&#x27;</span>,<span class="number">7566</span>,<span class="string">&#x27;1981-12-03&#x27;</span>,<span class="number">3000</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7934</span>,<span class="string">&#x27;MILLER&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7782</span>,<span class="string">&#x27;1982-01-23&#x27;</span>,<span class="number">1300</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure><p>☆部门表：dept<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903646.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">deptno <span class="type">INT</span>, </span><br><span class="line">dname <span class="type">varchar</span>(<span class="number">14</span>),</span><br><span class="line">loc <span class="type">varchar</span>(<span class="number">13</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;ACCOUNTING&#x27;</span>, <span class="string">&#x27;NEW YORK&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">20</span>, <span class="string">&#x27;RESEARCH&#x27;</span>, <span class="string">&#x27;DALLAS&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">30</span>, <span class="string">&#x27;SALES&#x27;</span>, <span class="string">&#x27;CHICAGO&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">40</span>, <span class="string">&#x27;OPERATIONS&#x27;</span>, </span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h3 id="1-基础查询">1.基础查询</h3><p>查询所有列<br><code>SELECT * FROM 表名;</code><br>(* ：通配符，表示所有列)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>查询指定列<br><code>SELECT 列名 1, 列名 2, …列名 n FROM 表名;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, sname, age <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-条件查询">2.条件查询</h3><p>条件查询介绍<br>条件查询就是在查询时给出 WHERE 子句，在 WHERE 子句中可以使用如下运算符及关键字：</p><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>BETWEEN…AND；</li><li>IN(set)；</li><li>IS NULL；</li><li>AND；</li><li>OR；</li><li>NOT；</li></ul><p>举例说明<br>查询性别为女，并且年龄小于 50 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE gender='female' AND age&lt;50;</code></p><p>查询学号为 S_1001，或者姓名为 liSi 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE sid ='S_1001' OR sname='liSi';</code></p><p>查询学号为 S_1001，S_1002，S_1003 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE sid IN ('S_1001','S_1002','S_1003')</code></p><p>查询学号不是 S_1001，S_1002，S_1003 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE sid NOT IN ('S_1001','S_1002','S_1003');</code></p><p>查询年龄为 null 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE age IS NULL;</code></p><p>查询年龄在 20 到 40 之间的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE age&gt;=20 AND age&lt;=40;</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE age BETWEEN 20 AND 40;</code></p><p>查询性别非男的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE gender!='male';</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE gender&lt;&gt;'male';</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE NOT gender='male';</code></p><p>查询姓名不为 null 的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE NOT sname IS NULL;</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE sname IS NOT NULL;</code></p><hr><h3 id="3-模糊查询">3.模糊查询</h3><p><code>SELECT 字段 FROM 表 WHERE 某字段 Like 条件</code><br>其中关于条件，SQL 提供了两种匹配模式：</p><ol><li><code>%</code> ：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情<br>况下若是中文，请使用两个百分号（%%）表示。</li><li><code>_ </code>： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字 符长度语句。</li></ol><p>举例说明<br>查询姓名由 5 个字母构成的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE '_ _ _ _ _';</code></p><p>查询姓名由 5 个字母构成，并且第 5 个字母为“i”的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE '_ _ _ _i';</code></p><p>查询姓名以“z”开头的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE 'z%';</code><br>其中“%”匹配 0~n 个任何字母。</p><p>查询姓名中第 2 个字母为“i”的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE '_i%';</code></p><p>\查询姓名中包含“a”字母的学生记录<br><code>SELECT * FROM stu WHERE sname LIKE '%a%';</code></p><h3 id="4-字段控制查询">4.字段控制查询</h3><p>去掉重复记录<br>去除重复记录（两行或两行以上记录中系列的上的数据都相同），例如 emp 表中 sal 字段就存在相同的记录。当只查询 emp 表的 sal 字段时，那么会出现重复记录，那么想去除重复记录，需要使用 DISTINCT：<br><code>SELECT DISTINCT sal FROM emp;</code></p><p>查看雇员的月薪与佣金之和<br>因为 sal 和 comm 两列的类型都是数值类型，所以可以做加运算。如果 sal 或 comm 中有一个字段不是数值类型，那么会出错。<br><code>SELECT *,</code><br><code>sal+comm FROM emp;</code><br>comm 列有很多记录的值为 NULL，因为任何东西与 NULL 相加结果还是 NULL，所以结算结果可能会出现 NULL。下面使用了把 NULL 转换成数值 0 的函数 IFNULL：<br><code>SELECT *, sal+IFNULL(comm,0) FROM emp;</code></p><p>给列名添加别名<br>在上面查询中出现列名为 sal+IFNULL(comm,0)，这很不美观，现在我们给这一列给出一个别名，为 total：<br><code>SELECT *, sal+IFNULL(comm,0) AS total FROM emp;</code><br>给列起别名时，是可以省略 AS 关键字的：<br><code>SELECT *, sal+IFNULL(comm,0) total FROM emp;</code></p><hr><h3 id="5-排序">5.排序</h3><p>查询所有学生记录，按年龄升序排序<br><code>SELECT * FROM stu</code><br><code>ORDER BY sage ASC;</code><br>或者<br><code>SELECT * FROM stu ORDER BY sage;</code></p><p>查询所有学生记录，按年龄降序排序<br><code>SELECT * FROM stu</code><br><code>ORDER BY age DESC;</code></p><p>查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序<br><code>SELECT * FROM emp</code><br><code>ORDER BY sal DESC ,empno ASC;</code></p><hr><h3 id="6-聚合函数">6.聚合函数</h3><p>聚合函数是用来做纵向运算的函数：</p><ul><li>COUNT()：统计指定列不为 NULL 的记录行数；</li><li>MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为 0；</li><li>AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为 0；</li></ul><p>COUNT：当需要纵向统计时可以使用 COUNT()。</p><p>查询 emp 表中记录数：<br><code>SELECT COUNT(*) AS cnt FROM emp;</code></p><p>查询 emp 表中有佣金的人数：<br><code>SELECT COUNT(comm) cnt FROM emp;</code><br>注意，因为 count()函数中给出的是 comm 列，那么只统计 comm 列非 NULL 的行数。</p><p>查询 emp 表中月薪大于 2500 的人数：<br><code>SELECT COUNT(*) FROM emp WHERE sal &gt; 2500;</code></p><p>统计月薪与佣金之和大于 2500 元的人数：<br><code>SELECT COUNT(*) AS cnt FROM emp WHERE sal+IFNULL(comm,0) &gt; 2500;</code><br>查询有佣金的人数，以及有领导的人数：<br><code>SELECT COUNT(comm), COUNT(mgr) FROM emp;</code></p><p>SUM 和 AVG：当需要纵向求和时使用 sum()函数。</p><p>查询所有雇员月薪和：<br><code>SELECT SUM(sal) FROM emp;</code></p><p>查询所有雇员月薪和，以及所有雇员佣金和：<br><code>SELECT SUM(sal), SUM(comm) FROM emp;</code></p><p>查询所有雇员月薪+佣金和：<br><code>SELECT SUM(sal+IFNULL(comm,0)) FROM emp;</code></p><p>统计所有员工平均工资：<br><code>SELECT SUM(sal), COUNT(sal) FROM emp;</code><br>或者<br><code>SELECT AVG(sal) FROM emp;</code></p><p>MAX 和 MIN<br>查询最高工资和最低工资：<br><code>SELECT MAX(sal), MIN(sal) FROM emp;</code></p><h3 id="7-分组查询">7.分组查询</h3><p>分组查询</p><p>当需要分组查询时需要使用 <code>GROUP BY </code>子句，例如查询每个部门的工资和，这说明要使用部分来分组。</p><p>查询每个部门的部门编号和每个部门的工资和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="built_in">SUM</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>查询每个部门的部门编号以及每个部门的人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>查询每个部门的部门编号以及每个部门工资大于 1500 的人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno ,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal<span class="operator">&gt;</span><span class="number">1500</span>`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>HAVING 子句</p><p>查询工资总和大于 9000 的部门编号以及工资和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="built_in">SUM</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(sal) <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p><strong>注意，WHERE 是对分组前记录的条件，如果某行记录没有满足 WHERE 子句的条件，那<br>么这行记录不会参加分组；而 HAVING 是对分组后数据的约束。</strong></p><h3 id="8-LIMIT：用来限定查询结果的起始行，以及总行数。">8.LIMIT：用来限定查询结果的起始行，以及总行数。</h3><p>查询 5 行记录，起始行从 0 开始<br><code>SELECT * FROM emp LIMIT 0, 5;</code><br>注意，起始行从 0 开始，即第一行开始！</p><p>查询 10 行记录，起始行从 3 开始<br><code>SELECT * FROM emp LIMIT 3, 10;</code></p><p>分页查询<br>如果一页记录为 10 条，希望查看第 3 页记录应该怎么查呢？<br> 第一页记录起始行为 0，一共查询 10 行；<br> 第二页记录起始行为 10，一共查询 10 行；<br> 第三页记录起始行为 20，一共查询 10 行；</p><h3 id="9-多表连接查询：-表连接分为内连接和外连接。">9.多表连接查询： 表连接分为内连接和外连接。</h3><p>他们之间最主要的区别：内连接仅选出两张表中互相匹配的记录，外连接会选出其他不匹配的记录。</p><p>例如： 以下是员工表 staff 和职位表 deptno:<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903280.png" alt="在这里插入图片描述"></p><h4 id="内连接">内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> staff.name,deptname <span class="keyword">from</span> staff,deptno <span class="keyword">where</span></span><br><span class="line">staff.name<span class="operator">=</span>deptno.name;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151901731.png" alt="在这里插入图片描述"></p><h4 id="外连接分为左连接和右连接">外连接分为左连接和右连接</h4><p>左连接：包含左边表中所有的记录，右边表中没有匹配的记录显示为 NULL。<br>右连接：包含右边表中所有的记录，左边表中没有匹配的记录显示为 NULL。</p><p>外连接(左连接)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> staff.name,deptname <span class="keyword">from</span> staff <span class="keyword">left</span> <span class="keyword">join</span> deptno onstaff.name<span class="operator">=</span>deptno.name;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151901354.png" alt="在这里插入图片描述"><br>外连接（右连接）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptname,deptno.name <span class="keyword">from</span> staff <span class="keyword">right</span> <span class="keyword">join</span> deptno ondeptno.name<span class="operator">=</span>staff.name;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151901810.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <summary type="html">SQL基础知识总结</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="SQL" scheme="https://www.sadalsuud.cn/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis-缓存穿透、缓存击穿、缓存雪崩</title>
    <link href="https://www.sadalsuud.cn/posts/5aff4b42.html"/>
    <id>https://www.sadalsuud.cn/posts/5aff4b42.html</id>
    <published>2024-06-15T10:44:50.000Z</published>
    <updated>2024-06-15T10:47:28.490Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis 缓存穿透，缓存击穿，缓存雪崩</h1><p>在日常开发工作中，缓存技术被广泛利用以增强系统性能和减轻数据库的访问压力。但是，在使用缓存的过程中，我们可能会碰到几个典型问题，比如<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F&amp;spm=1001.2101.3001.7020">缓存穿透</a>、缓存击穿和缓存雪崩。这些问题不仅在实际的应用中需要解决，而且它们也经常在面试中被问到。</p><p>​    然后，大部分的小可爱在准备阶段可能已经熟悉了这些概念，但在面试的紧张氛围下，往往会出现混淆，无法清晰区分缓存穿透、<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF&amp;spm=1001.2101.3001.7020">缓存击穿</a>和缓存雪崩。为了帮助大家深入理解并记住这三种缓存问题，以便在面试或实际工作中能够清晰地识别和解决问题，本文将详细解析这三个缓存问题，并提供一些记忆技巧，确保你不再对它们感到困惑，达到拨云见日、茅塞顿开之功效。</p><h5 id="一、缓存穿透">一、缓存穿透</h5><h6 id="1、什么是缓存穿透？">1、什么是缓存穿透？</h6><p>​    缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><p>​    <strong>那么，我们该怎么记忆缓存穿透呢？</strong></p><p>我们可以这么想，缓存穿透其实就是恶意攻击，就是有人想“穿”过你的防护网(缓存)来“偷”你的家(数据库)，这也就是穿透。或者你这样想，有人想恶意攻击你的数据库，这是不是不好的行为，是不是小偷的行为！这样透和偷，不就联系起来了。那么下次面试官问你缓存穿透是什么的时候。你只要想到透就是偷，就是不好的行为，也就能想到缓存穿透的意思就是别人恶意攻击，故意频繁访问一个不存在的key，来压垮你的数据库。</p><h6 id="2、问题分析">2、问题分析</h6><p>​    缓存穿透现象的核心问题在于请求中使用的key在Redis缓存中无法找到相应的值。这与缓存击穿的情形有本质的不同，后者通常涉及一个有效key的过期失效。在缓存穿透的情况下，传入的key在Redis中根本就不存在。如果黑客故意发送大量不存在的key的请求，这会导致数据库遭受巨大的查询压力，可能会严重威胁到系统的正常运行。因此，在日常开发实践中，对请求参数进行严格的校验是至关重要的。对于那些非法或明显不可能存在的key，系统应该立即返回一个错误提示，而不是让这些请求到达数据库层面。这样不仅可以提升系统的安全性，还能够维护数据库的稳定性和性能。</p><h6 id="3、解决方案">3、解决方案</h6><ul><li><p><strong>缓存空数据</strong></p><p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=“null”，并设置其一个较短的过期时间，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。</p></li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151846206.png" alt="img"></p><p><strong>优点</strong>：<strong>实现简单</strong>。</p><p><strong>缺点</strong>：1）<strong>耗费内存并且会有失效的情况</strong>。在Redis中缓存大量空值不仅会消耗宝贵的内存资源，而且如果攻击者持续使用随机键进行攻击，这种防御策略就会失效。在这种情况下，不仅数据库可能因过载而崩溃，Redis服务也可能由于内存耗尽而出现拒绝写操作的现象。这样，你的正常需要写入redis的业务也就会跟着受到影响。</p><p>​        2）<strong>数据不一致</strong>。虽然在缓存空值时我们设定了较短的过期时间，但仍存在一种情况：在缓存的空值尚未过期的这段短时间内，数据库中的实际数据可能已经更新，而该键值在数据库中存在了数据。这导致在缓存中的空值仍然被返回，而没有反回真实的数据，从而造成缓存与数据库之间的数据不一致现象。</p><ul><li><strong>布隆过滤器</strong></li></ul><p>​    布隆过滤器提供一种高效的概率型检测机制，用于判断一个元素是否可能在一个集合内。它的工作原理是，当布隆过滤器断言某个键（key）不存在时，这个结论是绝对可靠的；但当它认为某个键存在时，只表示有很高的可能性确实存在，尽管有一定的误判几率。为了缓解缓存穿透的问题，我们可以在Redis缓存层之前部署一道布隆过滤器的防线。将数据库中所有的键导入布隆过滤器中，这样在任何查询到达Redis之前，系统会首先检查该查询的键是否在布隆过滤器中。如果键在布隆过滤器中不存在，那么查询将不会继续前往数据库，而是直接返回结果，以此避免对数据库的不必要访问和潜在的查询压力。通过这样的布隆过滤器前置筛查，我们不仅保护了数据库免受不存在的键的查询压力，还确保了整体系统的性能稳定，即使在高并发查询的环境下也能有效地运作。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151846994.png" alt="img"></p><p><strong>优点</strong>：<strong>占用内存小</strong>。布隆过滤器不需要存储具体的数据项，只需要存储数据的哈希值，因此相比存储实际数据，它占用的内存更少</p><p><strong>缺点</strong>： 1）**存在一定的误判情况。**布隆过滤器存在一定的误判率，即它可能会错误地认为某个不存在的元素存在（假阳性），尽管可以通过调整参数来降低误判率，但无法完全消除。</p><p>​        2）**不可逆性。**布隆过滤器不需要存储具体的数据项，只需要存储数据的哈希值，因此相比存储实际数据，它占用的内存更少。</p><p>​        3）**数据不一致。**为了维护数据的准确性和一致性，理想情况下，当数据库中的数据发生更新时，布隆过滤器也应当进行相应的更新以反映这些变更。然而，布隆过滤器与数据库是两个独立的数据管理实体。所以可能出现的一种情形是，在数据库成功执行了数据更新之后，当尝试更新布隆过滤器时，网络异常发生，导致新增的数据未能及时写入布隆过滤器中。在这种状况下，后续针对这个新加入数据的查询请求将会被布隆过滤器拒绝，因为该数据的键尚未存在于过滤器中。尽管这是一个合理的查询请求，它却被“错误地”拦截了。</p><p>​    在这里，其实我们可以意识到并不存在一个完美无缺的解决方案。最终选择哪种方案必须依据我们的业务场景来定。例如，虽然引入布隆过滤器可以解决缓存穿透导致的内存占用问题，但它同时可能带来其它问题。这也正是我们需要培养的思维方式：每当考虑引入新的技术方栈时，我们必须思考它能够解决哪些问题，以及可能会带来哪些新问题，并要提前规划好如何应对这些潜在的问题**。**</p><p><strong>那么，到底该如何解决这个问题？</strong></p><p>​    在这里，关键的考量因素是我们平台能够承载的并发水平。我们可以根据我们平台的特点去考量平台最大的并发量。然后，再依据最大并发量进行限流，确保即使在极端的高并发情况下，也不会对数据库造成过大压力导致其崩溃。其次，再经过限流后，我们再去考虑并发度高低，并发度低的我们可以简单的使用缓存空值的方案来解决缓存穿透的问题，并发度高的情况下我们还是最好使用布隆过滤器的方案解决缓存穿透问题。</p><p>​     当然，除了上面提到的布隆过滤器和缓存空数据的方案之外，我们还可以通过实施<strong>参数校验</strong>和<strong>拉黑恶意攻击者的IP</strong>来增强对缓存穿透问题的防护。</p><h5 id="二、缓存击穿">二、缓存击穿</h5><h6 id="1、什么是缓存击穿？">1、什么是缓存击穿？</h6><p>​    缓存击穿通常发生在高并发系统中，当某个被频繁访问的数据（热点key）在缓存中的有效期过了，恰好在这个时候有大量的并发请求需要访问这个数据。由于缓存中的数据已经失效，这些并发请求就会直接转发到数据库上，如果数据库的处理能力不足以应对这种突然增加的压力，就可能导致系统响应缓慢甚至崩溃。</p><p>​    <strong>那么，我们该怎么记忆缓存击穿呢？</strong></p><p>​    首先，让我们参考百度百科对“击穿”现象的解释：在强电场的作用下，绝缘材料内部会发生破坏性的放电，导致其绝缘电阻降低，电流增大，最终引发材料的损坏甚至穿孔。现在，我们用这个原理来类比Redis缓存系统中的情况。设想Redis中的缓存数据被组织成一系列的“网格”，这些网格共同构成了一层防御屏障。当某个网格由于某种原因突然变得不可用或丢失时，原本应该被该网格处理的大量请求就会如同电流般穿透这个缺口，直接冲击后端的数据库。这种现象，就类似于电学中的“击穿”，在Redis缓存的语境下，我们称之为缓存击穿。</p><p>​    或者，你也可以这样想。&quot;击穿&quot;中的&quot;击&quot;字与&quot;寄&quot;发音相同。在网络上，当我们说“我寄了”，它通常隐含着“我完了”或者“我死了”的意味。沿着这个思路，缓缓存击穿就好比是某个关键的key“寄”了，导致的大量并发请求打到数据库。所以，只要你能从“击”这个字联想到“寄寄”，便能够自然而然地想到缓存击穿这一概念的具体含义。</p><h6 id="2、问题分析-2">2、问题分析</h6><p>​    核心问题在于，一旦某个热门的key失效，便会导致密集的并发请求直接涌向数据库。因此，解决方案需从两个方向着手：首先，考虑对热点key不设置过期时间以保持其持久有效；其次，探索降低数据库所承受的请求量的方法，以减轻其压力。</p><h6 id="3、解决方案-2">3、解决方案</h6><ul><li>互斥锁</li></ul><p>​    在缓存失效后，通过互斥锁控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151846765.png" alt="img"></p><p><strong>优点</strong>：<strong>1）强一致</strong>。互斥锁能够确保在缓存重建过程中，只有一个线程可以访问数据库并更新缓存，这样可以避免多个线程同时读取到过期的缓存数据，从而保证了数据的强一致性。</p><p>​     <strong>2）实现相对简单</strong>。互斥锁的实现相对简单，不需要复杂的逻辑处理，只需在缓存失效时加锁，更新完毕后释放锁即可。</p><p><strong>缺点</strong>： <strong>吞吐量低</strong>。在高并发的场景下，互斥锁可能会导致系统的可用性降低，因为大量的请求可能会因为等待锁而无法及时得到处理。</p><ul><li>逻辑过期</li></ul><p>​    逻辑过期方案与互斥锁方案在应对缓存击穿问题上确实有着相似之处，它们都通过使用互斥锁来防止同时对同一热点key的缓存进行更新。然而，它们的工作细节和重点略有不同。在逻辑过期方案中，每个缓存项旁边附加了一个额外的字段来表示其逻辑上的过期状态，而不是物理地从缓存系统中移除该数据。这样，即使一个缓存项已标记为逻辑上过期，它仍然存在于缓存中并可以被访问到。这种方法避免了因等待重新加载数据而导致的缓存缺失情况。当一个线程查询某个key的缓存数据时，如果该数据已经处于逻辑过期状态，无论该线程是否成功获取互斥锁，系统都会先返回这个逻辑上过期的数据。这样做的好处是即使在数据更新过程中，也能保证用户能立即得到响应，虽然数据可能是旧的。与此同时，如果某个线程成功获取了互斥锁，这意味着它获得了更新缓存数据的权限。这个线程会创建一个单独的工作线程来负责从数据库检索最新数据、更新缓存，并重置该key的逻辑过期时间。一旦这个过程完成，互斥锁便会被释放。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151847905.png" alt="img"></p><p><strong>优点</strong>：<strong>吞吐量高</strong>。在逻辑过期方案中，即使数据已过期，系统仍会返回过期数据给客户端，而不是等待锁释放后再去数据库拉取最新数据。</p><p><strong>缺点</strong>： **1）牺牲数据一致性。**由于在数据更新过程中，系统可能会返回过期数据，这在一定程度上牺牲了数据的一致性。</p><p>​      **2）实现复杂。**逻辑过期方案需要维护额外的字段来记录每个缓存项的逻辑过期状态，这增加了系统的复杂性。</p><p>​     **3）耗费更多的内存。**因为增加了一个字段来维护逻辑过期的时间，这必定会造成额外的空间占用。</p><p>这里，可能有些小可爱会有一个疑问：<strong>为什么不直接使用热点数据永不过期来代替逻辑过期呢？逻辑过期的数据不也是永不过期吗？折腾这么多又是加字段又是加锁的是为了什么？直接都不过期了不就不会缓存击穿了吗？</strong></p><p>​    实际上，尽管可以选择配置热点数据为永不过期以取代逻辑过期的方案，但逻辑过期的存在有其独特的必要性。逻辑过期允许我们在数据达到过期时间点时主动去刷新缓存中的数据，从而确保数据的更新和准确性。如果没有设置逻辑过期，我们将失去在查询时更新缓存数据的能力，这将导致数据的实时性和一致性难以得到保障。所以，对于不常变更的数据，可以安心设置为永不过期；而对于频繁更新的数据，采用逻辑过期是更为合适的策略。</p><p>​    <strong>那么，什么使用逻辑过期，什么时候使用互斥锁呢？</strong></p><p>根据上面我们总结的这两个方案的优缺点，不难得出当我们追求数据的强一致的时候，就使用互斥锁方案。当我们要求数据更高的吞吐量，并且对数据的一致性要求不高的时候，就使用逻辑过期的方案。</p><h5 id="三、缓存雪崩">三、<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9&amp;spm=1001.2101.3001.7020">缓存雪崩</a></h5><h6 id="1、什么是缓存雪崩？">1、什么是缓存雪崩？</h6><p>​    缓存雪崩是指<strong>由于缓存系统的整体失效，导致大量请求直接到达后端数据库，进而可能造成数据库崩溃和整个系统的崩溃</strong>。这种现象通常发生在缓存服务器重启或宕机时，或者是大规模的key同时失效导致的结果。</p><p>​    <strong>那么，我们该怎么记忆缓存雪崩呢？</strong></p><p>​    其实，记住缓存雪崩相比另外两个是比较容易的。雪崩这个词本身就可以生动地描绘了缓存雪崩发生的情境：发挥你的想象，redis就是个雪山，而redis上面的key好比山上一个一个的雪花。突然间，一个自称“天下第一帅”的拙野挥洒着他的帅气，高声发出震天的呐喊：我是天下第一帅！。这一声犹如惊雷贯耳，瞬间引发了山上的积雪大面积崩塌(大量key失效)或者这声吼叫的力量如此巨大，竟像是触发了一场地震，使得整个雪山轰然倒塌（redis服务器宕机）。</p><h6 id="2、问题分析-3">2、问题分析</h6><p>​    造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。</p><h6 id="3、解决方案-3">3、解决方案</h6><ul><li><strong>过期时间随机</strong></li></ul><p>​    在设置失效时间的时候加上一个随机值，比如1-5分钟随机。这样就可以避免了由于使用相同的过期时间导致在某一时刻大量key过期引发的缓存雪崩问题。</p><ul><li><strong>使用熔断机制</strong></li></ul><p>​    当系统流量达到预定的极限时，为避免对数据库造成过大压力，我们将自动显示“系统繁忙”提示。这样做可以确保至少有一部分用户能够顺畅地使用我们的服务。对于未能即时访问的用户，只要多刷新几次，也是可以获得正常访问的。</p><ul><li><strong>缓存预热</strong></li></ul><p>​    缓存预热是一种关键技术，它在系统启动前预先加载关键数据到缓存中，以减少系统上线时对后端数据库的冲击。由于新上线的系统缓存是空的，如果没有预热过程，大量并发请求将直接访问数据库，极有可能在系统上线初期导致服务崩溃。因此，通过在系统上线之前将高频率访问的数据从数据库加载到Redis等缓存系统中，可以确保用户请求首先由缓存服务处理，从而减轻数据库的压力。实施缓存预热通常涉及编写批处理任务，这些任务可以在系统启动期间执行，或者通过定时任务定期去执行。定期执行更能保证数据的实时性，但是，同样会耗费系统的部分性能，尤其是在数据量大的时候。所以，具体选择如何进行预热数据，还是需要综合考虑预热数据量的大小以及预热数据更新的是否频繁等因素。</p><ul><li><strong>redis集群</strong></li></ul><p>​    保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用主从+ 哨兵，Redis集群来避免单个Redis服务器宕机导致整个缓存直接失效。</p><ul><li><strong>多级缓存</strong></li></ul><p>​    通过实施多级缓存策略，我们可以优化系统的性能并降低因缓存失效导致的风险。在这种策略中，本地进程内的缓存充当第一级缓存，而Redis则作为第二级远程缓存。每一级缓存都设定有独立且差异化的超时时间，这样的设计确保了即使一级缓存的数据过期或被清除，仍能有二级或其他级别的缓存来提供数据支持。这种层级化的缓存机制为系统提供了额外的弹性层，当一层缓存遇到问题时，其他层级能够起到“安全网”的作用，从而可以有效避免雪崩现象。</p><ul><li><strong>互斥锁</strong></li></ul><p>​    这个和缓存击穿比较类似 ，都是通过互斥锁来控制读数据写缓存的线程数量，这样就避免大量请求同时击中数据库。同样，这样虽然可以避免大量key同时失效导致的缓存雪崩问题。但是，同样性能也会因为加锁的原因受到影响。如果，系统对吞吐量要求不高的情况下，这种方式其实还是不错的。因为它即解决了缓存击穿的问题，也解决了缓存雪崩的问题。可谓一举两得。</p>]]></content>
    
    
    <summary type="html">缓存穿透，缓存击穿，缓存雪崩</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis 6.0.12 配置文件详解</title>
    <link href="https://www.sadalsuud.cn/posts/68e33178.html"/>
    <id>https://www.sadalsuud.cn/posts/68e33178.html</id>
    <published>2024-06-15T10:43:20.000Z</published>
    <updated>2024-06-15T10:43:53.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、NETWORK-网络配置详解">1、NETWORK 网络配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ NETWORK ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定redis只能接受来自此IP绑定的网卡的请求，注意此默认值默认外网是不可访问的，想要外网访问redis服务，需注释掉</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否开启保护模式。如果没有指定bind和密码，redis只会本地进行访问，拒绝外部访问。* protected-mode yes</span></span><br><span class="line">protected-mode <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认端口，建议生产环境不要使用默认端口避免被恶意扫描到</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP连接中已完成队列(完成三次握手之后)的长度,默认是511,此值必须不大于Linux系统定义的tcp内核参数somaxconn值,默认参数</span></span><br><span class="line"><span class="comment">#值是128，该内核参数默认值一般是128（定义了系统中每一个端口最大的监听队列的长度），对于负载很大的服务程序来说大大的不够。#一般会将它修改为2048或者更大。somaxconn修改方法：</span></span><br><span class="line"><span class="comment">#在/etc/sysctl.conf中添加：net.core.somaxconn = 2048</span></span><br><span class="line"><span class="comment">#然后在终端中执行：sysctl -p</span></span><br><span class="line"></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，服务端会断开连接。为0则服务端不会主动断开连接。</span></span><br><span class="line"><span class="built_in">timeout</span> 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果#设置为0，则不会周期性的检测。</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829</span><br></pre></td></tr></table></figure><h3 id="2、GENERAL-普通配置详解">2、GENERAL 普通配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ GENERAL ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认值为 no</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#不进行监督树的交互</span></span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义日志级别。默认使用notice，有4种级别·：</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#1、debug（记录大量日志信息，适用于开发、测试阶段）</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#2、verbose（较多日志信息）</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#3、notice（适量日志信息，使用于生产环境），默认</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#4、warning（仅有部分重要、关键信息才会被记录）</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置日志文件地址</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库的数量，序号从0开始</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否总是显示logo</span></span><br><span class="line">always-show-logo <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure><h3 id="3、SNAPSHOTTING-快照配置详解">3、SNAPSHOTTING <a href="https://so.csdn.net/so/search?q=%E5%BF%AB%E7%85%A7&amp;spm=1001.2101.3001.7020">快照</a>配置详解</h3><p>Redis作为一款<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>数据库，被广泛使用于缓存，分布式锁等场景，假如断电或者因其他因素导致Reids服务宕机，在重启之后数据将会丢失，因此需要数据的持久化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ SNAPSHOTTING ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#save 设置redis进行数据库镜像的频率</span></span><br><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在开启了 RDB 快照后，如果最近的一次 RDB 快照在后台生成失败的话，Redis 默认会拒绝所有的写请求。这样以一种强硬的方式让用#户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生。如果后台保存进程重新启动工作了，redis 也将自动的允许写操#作。如果你已经为你的 Redis 实例和持久化配置了合适的监控手段，你可能不希望 redis 这样做，就改成 no 好了。</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在生成 rdb（关系数据库）文件的时候使用 LZF 压缩算法 ，yes：压缩，但是需要一些cpu的消耗。</span></span><br><span class="line"><span class="comment">#no：不压缩，需要更多的磁盘空间</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#从 5.0 版本开始 RDB 文件的末尾会默认放置一个 CRC64 的校验码。</span></span><br><span class="line"><span class="comment">#是否校验rdb文件，这会让文件的格式更加容易检验验证，代价是生成和加载 RDB 文件的性能会损失 10% 左右。你可以把该配置关闭以#求更佳的性能。</span></span><br><span class="line"><span class="comment">#没有开启校验码配置的 RDB 文件会将校验码设置为 0，加载该文件的程序就会跳过校验过程。</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 rdb 文件的名称。默认值为 dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#rdb文件是否删除同步锁</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738</span><br></pre></td></tr></table></figure><h3 id="4、REPLICATION-主从复制配置详解">4、REPLICATION 主从复制配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt; <span class="comment">#</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>主从复制。使用 replicaof 来让一个 Redis 实例复制另一个 Redis 实例，关于 Redis 复制需要了解的一些事情：</p><p>1）Redis 复制时异步进行的，但是可以通过配置让 Redis 主节点拒绝写请求：配置会给定一个值，主节点至少需要和大于该值的从节点个数成功连接。</p><p>2）如果 Redis 从节点和主节点意外断连了很少的一段时间，从节点可以向主节点进行<strong>增量复制</strong>。你可以根据你的需要配置复制的备份日志文件大小（在下一部分可以看到相关的配置）</p><p>3）复制会自动进行且不需要人为介入（intervention）。在网络划分后复制会自动与主节点重连且同步数据。</p><p><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/112a5aea128ebbf66058994882ab4239.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ REPLICATION ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果主节点配置了密码（使用了 &quot;requirepass&quot; 配置项），从节点需要进行密码认证才能进行复制同步的过程，否则主节点会直接拒</span></span><br><span class="line"><span class="comment">#绝从节点的复制请求。</span></span><br><span class="line">masterauth &lt;master-password&gt; <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当复制过程与主节点失去连接，或者当复制正在进行时，复制可以有两种行为模式：</span></span><br><span class="line"><span class="comment">#1）如果 replica-serve-stale-data 设置为 &#x27;yes&#x27;（默认设置），从节点仍可以处理客户端请求，但该从节点的数据很可能和主</span></span><br><span class="line"><span class="comment">#节点不同步，从节点的数据也可能是空数据集，如果这是与主节点进行的第一次同步。</span></span><br><span class="line"><span class="comment">#2）如果 replica-serve-stale-data 设置成 &#x27;no&#x27;，从节点会对除了 INFO，replicaOF，AUTH，PING，SHUTDOWN，#REPLCONF，ROLE，CONFIG，SUBSCRIBE，UNSUBSCRIBE，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，COMMAND， #POST，HOST： and LATENCY 这些命令之外的请求均返回 &quot;SYNC with master in process&quot;。</span></span><br><span class="line">replica-serve-stale-data <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。</span></span><br><span class="line">replica-read-only <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line"><span class="comment">#新建立连接和重连的副本不会根据数据情况进行恢复传输，只会进行全量复制。主节点会传输在从节点之间传输 RDB 文件。传输行为有两种方式：</span></span><br><span class="line"><span class="comment">#1）硬盘备份：Redis 主节点创建一个子进程来向硬盘写 RDB 文件。之后由父进程持续的文件传给副本。在生成 RDB 文件时，多个副本会进行入队并在当前子进程完成 RDB 文件时立即为副本进行 RDB 传输。</span></span><br><span class="line"><span class="comment">#2）不使用硬盘：Redis 主节点建立一个进程直接向副本的网络套接字写 RDB 文件，不涉及到硬盘。一旦传输开始，新来的副本传输请求会入队且只在当前的传输断开后才建立新的传输连接。</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果 diskless sync 是开启的话，就需要配置一个延迟的秒数，这样可以服务更多通过 socket 传输 RDB 文件的副本。延迟配置的单位是秒，默认是 5 秒。不想要该延迟的话可以配置为 0 秒，传输就会立即开始。</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否使用无磁盘加载，有三项选择：</span></span><br><span class="line"><span class="comment">#disabled：不使用无磁盘加载，先将rdb文件存储到磁盘</span></span><br><span class="line"><span class="comment">#on-empty-db：只有在完全安全的情况下才使用无磁盘加载</span></span><br><span class="line"><span class="comment">#swapdb：解析时在RAM中保留当前db内容的副本，直接从套接字获取数据。</span></span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#副本会根据配置好的时间间隔（interval）向主节点发送 PING 命令。可以通过 repl_ping_replica_period 配置修改时间间隔。默认为 10 秒。</span></span><br><span class="line">repl-ping-replica-period 10 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的配置会将副本进行超时处理，为了：</span></span><br><span class="line"><span class="comment">#1）在副本的角度，在同步过程中批量进行 I/O 传输。</span></span><br><span class="line"><span class="comment">#2）从副本s的角度，主节点超时了。</span></span><br><span class="line"><span class="comment">#3）从主节点的角度，副本超时了。</span></span><br><span class="line"><span class="comment">#需要重视的一点是确保该选项的配置比 repl-ping-replica-period 配置的值更高，否则每次主从之间的网络比较拥挤时就容易被判定为超时。</span></span><br><span class="line">repl-timeout 60 <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#同步过后是否在副本套接字上关闭 TCP_NODELAY</span></span><br><span class="line"><span class="comment">#如果你选择了 &#x27;yes&#x27; ，Redis 会使用很小的 TCP 包，占用很低的带宽来想副本发送数据。但是这么做到达副本的数据会有一些延迟，#使用默认的配置值且是 Linux 内核该延迟最多可能 40 毫秒。</span></span><br><span class="line"><span class="comment">#如果你选择 &#x27;no&#x27;，副本的数据延迟会更低但是占用的带宽会更多一些。</span></span><br><span class="line"><span class="comment">#我们默认会为了低延迟进行优化，但是在比较拥挤网络情况下或者是主节点和副本之间的网络情况比较复杂，比如中间有很多路由跳转的情况下，把选项设置为 &#x27;yes&#x27; 应该会比较适合。</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置副本的缓冲区（backlog）大小。该缓冲区用来在副本断开连接后暂存副本数据。</span></span><br><span class="line"><span class="comment">#这样做的因为但副本重新连接后，不一定要重新进行全量复制，很多时候增量复制同步（仅同步断连期间副本可能丢失的数据）完全足够了。配置的缓冲区越大，副本可以承受的断连时间可以更长。</span></span><br><span class="line">repl-backlog-size 1mb <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主节点如果一段时间没有副本连接，上面提到的缓冲区会被释放。可以通过配置一个指定的时间来释放缓冲区</span></span><br><span class="line"><span class="comment">#配置为 0 意味着不释放缓冲区。</span></span><br><span class="line">repl-backlog-ttl 3600 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当主节点无法提供服务后，Redis Sentinel（哨兵）会使用到优先级进行选举副本，晋升为主节点。</span></span><br><span class="line"><span class="comment">#值越低，代表该副本晋升成为主节点的优先级越高，比如说有三个副本，优先级的值分别为 10，100，25，Redis 哨兵会选择最低的那个，即优先级配置为10的那个。</span></span><br><span class="line"><span class="comment">#有一个特殊的配置值：&#x27;0&#x27;，意味着该副本不可能充当主节点的角色，故优先级配置为 0 的副本永远不会被 Redis 哨兵选择晋升。</span></span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主节点可以根据目前连接的延迟小于 M 秒的副本数量，主redis就停止接受外来的写请求。</span></span><br><span class="line"><span class="comment">#数量 N 的副本需要是 &quot;online&quot; 的状态。默认的 min-replicas-to-write 被设置为 0（功能关闭）</span></span><br><span class="line"><span class="comment">#延迟的秒数（The lag（落后） in seconds） M ，计算方式是根据上一次副本发送 ping 命令到主节点的时间计算。通常每秒都会发送 ping 命令。</span></span><br><span class="line"><span class="comment">#比如要求至少有三个延迟小等于 10 秒的副本，主redis就停止接受外来的写请求，你可以这么配置：</span></span><br><span class="line">min-replicas-to-write 3 <span class="comment">#</span></span><br><span class="line">min-replicas-max-lag 10 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的两个配置选项用来让副本上报特定的 IP 和 端口 集合给它连接的主节点，之后主节点使用 &quot;INFO&quot; 或者 &quot;ROLE&quot; 命令都可以输出这些上报的值。</span></span><br><span class="line"><span class="comment">#如果你只想上报 ip 或 端口其中一个，就没有必要两个都使用。</span></span><br><span class="line">replica-announce-ip 5.5.5.5 <span class="comment"># </span></span><br><span class="line">replica-announce-port 1234 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485</span><br></pre></td></tr></table></figure><h3 id="5、KEYS-TRACKING-键的追踪配置详解">5、KEYS TRACKING 键的追踪配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ KEYS TRACKING ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在使用了客户端缓存的时候,这里配置要追踪的key的数量，如果配置为0，则表示要追踪的key的数量不受限制</span></span><br><span class="line">tracking-table-max-keys 1000000 <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h3 id="6、SECURITY-安全配置详解">6、SECURITY 安全配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ SECURITY ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ACL日志的最大长度，默认是128M。</span></span><br><span class="line">acllog-max-len 128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ACL外部配置文件所在位置</span></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前redis服务的访问密码，默认是不需要密码</span></span><br><span class="line"><span class="comment">#警告：因为 Redis 的响应速率很快，所以恶意攻击者可能在每秒中发送 150k 数据量的密码尝试解密。这意味着你设置的密码强度要足够大，否则很容易被破解。</span></span><br><span class="line">requirepass foobared <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令的重命名。</span></span><br><span class="line"><span class="comment">#可以在共享的环境中重命名那些比较危险的命令。比如把 CONFIG 命令重命名成一个不好猜的名字，这样内部的功能还可以使用，且可以避免大部分的客户端使用。</span></span><br><span class="line"><span class="comment">#例如：rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment">#甚至可以将命名重命名成一个空串，使其失效。</span></span><br><span class="line">rename-command CONFIG <span class="string">&quot;&quot;</span> <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><h3 id="7、CLIENTS-客户端配置详解">7、CLIENTS 客户端配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ CLIENTS ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置可以同时连接客户端的最大数量。默认该项设置为 10000 个客户端</span></span><br><span class="line"><span class="comment">#一旦达到该限制数 Redis 会拒绝所有的新连接并返回错误信息 &#x27;max number of clients reached&#x27;。</span></span><br><span class="line">maxclients 10000 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="8、MEMEORY-MANAGEMENT-内存管理配置详解">8、MEMEORY MANAGEMENT 内存管理配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ MEMEORY MANAGEMENT ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定Redis最大内存限制。达到内存限制时，Redis将尝试删除已到期或即将到期的Key。</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内存使用达到限制后， Redis移除key的策略，默认是noeviction，</span></span><br><span class="line"><span class="comment">#maxmemory-policy 六种策略：</span></span><br><span class="line"><span class="comment">#1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span></span><br><span class="line"><span class="comment">#2、allkeys-lru ： 删除lru算法的key   </span></span><br><span class="line"><span class="comment">#3、volatile-random：随机删除即将过期key   </span></span><br><span class="line"><span class="comment">#4、allkeys-random：随机删除   </span></span><br><span class="line"><span class="comment">#5、volatile-ttl ： 删除即将过期的   </span></span><br><span class="line"><span class="comment">#6、noeviction ： 永不过期，返回错误</span></span><br><span class="line"><span class="comment">#如果根据淘汰策略，Redis 不能移除键值对，Redis 会拒绝那些申请更大内存的命令，比如 SET，LPUSH 等等，但是仍可以处理读请求，比如 GET 等。</span></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><h3 id="9、APPEND-ONLY-aof模式配置详解">9、APPEND ONLY aof模式配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ APPEND ONLY MODE ============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否启用aof持久化方式 。即是否在每次更新操作后进行日志记录，默认配置是no</span></span><br><span class="line"><span class="comment">#如果不开启，可能会在断电时导致部分数据丢失。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#aof持久化文件名，默认为appendonly.aof</span></span><br><span class="line">appendfilename “appendonly.aof”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#aof持久化文件刷新的频率。有三种：</span></span><br><span class="line"><span class="comment">#1.no 依靠OS进行刷新，redis不主动刷新AOF，这样最快，但安全性就差。</span></span><br><span class="line"><span class="comment">#2.always 每提交一个修改命令都调用fsync刷新到AOF文件，非常非常慢，但也非常安全。</span></span><br><span class="line"><span class="comment">#3.everysec 每秒钟都调用fsync刷新到AOF文件，很快，但可能会丢失一秒以内的数据。</span></span><br><span class="line">appendfsync always <span class="comment"># </span></span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://cloud.tencent.com/developer/news/709703">https://cloud.tencent.com/developer/news/709703</a></p>]]></content>
    
    
    <summary type="html">Redis 6.0.12 配置文件详解</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
    <category term="config" scheme="https://www.sadalsuud.cn/tags/config/"/>
    
  </entry>
  
  <entry>
    <title>Redis HyperLogLog 基数统计和 Bitmap位图场景详解</title>
    <link href="https://www.sadalsuud.cn/posts/13680a08.html"/>
    <id>https://www.sadalsuud.cn/posts/13680a08.html</id>
    <published>2024-06-15T10:41:45.000Z</published>
    <updated>2024-06-15T10:42:41.052Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis HyperLogLog 基数统计和 Bitmap位图场景详解</h1><h3 id="1、HyperLogLog-基数统计">1、HyperLogLog 基数统计</h3><blockquote><p>什么是基数?</p></blockquote><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><blockquote><p>Redis HyperLogLog</p></blockquote><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><blockquote><p>常用命令：</p></blockquote><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td>[PFADD key element [element …]添加指定元素到 HyperLogLog 中。</td></tr><tr><td>2</td><td>[PFCOUNT key [key …] 返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td>3</td><td>[PFMERGE destkey sourcekey [sourcekey …] 将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><p><strong>使用实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加指定元素到 HyperLogLog 中</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd key1 a b c d e f g h</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#返回给定 HyperLogLog 的基数估算值</span></span><br><span class="line">127.0.0.1:6379&gt; pfcount key1</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; pfadd key2 e f g h x w y x z</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key2</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"><span class="comment">#将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">127.0.0.1:6379&gt; pfmerge key3 key1 key2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount key3</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h3 id="2、Bitmap位图场景详解">2、Bitmap位图场景详解</h3><p>bitmap就是通过最小的单位bit来进行0或者1的设置，表示某个元素对应的值或者状态。一个bit的值，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。</p><p>Redis从2.2.0版本开始新增了<code>setbit</code>,<code>getbit</code>,<code>bitcount</code>等几个bitmap相关命令。虽然是新命令，但是并没有新增新的数据类型，因为<code>setbit</code>等命令只不过是在<code>set</code>上的扩展。</p><p><strong>语法详解：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>对key所存储的字符串值，设置或清除指定偏移量上的位（bit），如果不存在，就设置；如果已存在，就清除原有的，设置新的。</p><p>返回值为该位在setbit之前的值，value只能取0或1，offset(偏移量)从0开始，即使原位图只能10位，offset可以取1000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>对key所存储的字符串值，获取指定偏移量上的位（bit）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>获取位图指定范围中位值为1的个数，如果不指定start与end，则取所有</p><blockquote><p>使用场景1：统计一周打卡次数</p></blockquote><p>0-6为周一到周末，1表示已打卡，0表示未打卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#========================记录一周内的打卡情况========================</span></span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#========================查看具体某一天的打卡情况========================</span></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#========================统计一周内打卡次数========================</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><blockquote><p>使用场景2：统计活跃用户</p></blockquote><p>使用时间作为Key，然后用户ID为offset，如果当日活跃过就设置为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#记录2021年08月12日用户的状态</span></span><br><span class="line">127.0.0.1:6379&gt; setbit 20210812 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit 20210812 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit 20210812 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#查看指定用户在2021年08月12日是否活跃</span></span><br><span class="line">127.0.0.1:6379&gt; getbit 20210812 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#查看在2021年08月12日活跃的用户数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount 20210812</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><p><strong>使用bitmap是一个节约空间效率又高的一种方法</strong></p>]]></content>
    
    
    <summary type="html">HyperLogLog 基数统计和 Bitmap位图场景详解</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
    <category term="HyperLogLog" scheme="https://www.sadalsuud.cn/tags/HyperLogLog/"/>
    
    <category term="Bitmap" scheme="https://www.sadalsuud.cn/tags/Bitmap/"/>
    
  </entry>
  
  <entry>
    <title>Redis Geospatial地理位置的使用</title>
    <link href="https://www.sadalsuud.cn/posts/f844b42a.html"/>
    <id>https://www.sadalsuud.cn/posts/f844b42a.html</id>
    <published>2024-06-15T10:40:26.000Z</published>
    <updated>2024-06-15T10:41:16.050Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis Geospatial地理位置</h1><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p><p>Redis GEO 操作方法有：</p><ul><li><strong>geoadd：添加地理位置的坐标。</strong></li><li><strong>geopos：获取地理位置的坐标。</strong></li><li><strong>geodist：计算两个位置之间的距离。</strong></li><li><strong>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</strong></li><li><strong>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</strong></li><li><strong>geohash：返回一个或多个位置对象的 geohash 值。</strong></li></ul><blockquote><p><strong>geoadd：添加地理位置的坐标。</strong></p></blockquote><p>geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。南北两级无法添加。</p><p>平时，我们一般会直接下载城市数据，然后通过java程序导入。</p><p>经度范围是0-180°，纬度范围是0-90°。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">116.40 39.90</span> beijing</span><br><span class="line"> (integer) <span class="number">1</span></span><br><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">106.50 29.53</span> chongqing <span class="number">121.47 31.23</span> shanghai</span><br><span class="line"> (integer) <span class="number">2</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>geopos：获取地理位置的坐标</strong></p></blockquote><p>geopos 用于从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geopos china:city beijing shanghai</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;31.22999903975783553&quot;</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geopos china:city nanchang</span><br><span class="line"> <span class="attribute">1</span>) (nil)</span><br><span class="line"><span class="attribute">1234567</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>geodist：计算两个位置之间的距离</strong></p></blockquote><p>geodist 用于返回两个给定位置之间的距离，直线距离</p><p>最后一个距离单位参数说明：</p><ul><li>m ：米，默认单位。</li><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing   <span class="comment">#北京和重庆之间的距离  默认单位m</span></span><br><span class="line"> <span class="string">&quot;1464070.8051&quot;</span>  <span class="comment">#默认单位m</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing km</span><br><span class="line"> <span class="string">&quot;1464.0708&quot;</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing ft</span><br><span class="line"> <span class="string">&quot;4803381.9063&quot;</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing mi</span><br><span class="line"> <span class="string">&quot;909.7337&quot;</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>nanchang  <span class="comment">#，不存在的返回 nil</span></span><br><span class="line"> (nil)</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</strong></p><p><strong>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合</strong></p></blockquote><ul><li><p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p></li><li><p>georadiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。</p></li><li><p>参数说明：</p></li><li><ul><li>m ：米，默认单位。</li><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</li><li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li><li>COUNT 限定返回的记录数。</li><li>ASC: 查找结果根据距离从近到远排序。</li><li>DESC: 查找结果根据从远到近排序，默认。</li></ul></li></ul><p><strong>georadius 实例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#================返回以 119 35 中心，半径1000km内所有城市================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km</span><br><span class="line"> <span class="attribute">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> <span class="comment">#================返回以 119 35 中心，半径1000km内所有城市，并将位置元素与中心之间的距离也一并返回================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km withdist</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;591.3126&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;478.2625&quot;</span></span><br><span class="line"> <span class="comment">#================返回以 119 35 中心，半径1000km内所有城市，将位置元素的经度和维度也一并返回================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km withcoord</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;31.22999903975783553&quot;</span></span><br><span class="line"> <span class="comment">#返回以 119 35 中心，半径1000km内所有城市，将位置元素与中心之间的距离一并返回，将位置元素的经度和维度也一并返回    </span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km withcoord withdist</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;591.3126&quot;</span></span><br><span class="line">    <span class="attribute">3</span>) <span class="number">1</span>) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;478.2625&quot;</span></span><br><span class="line">    <span class="attribute">3</span>) <span class="number">1</span>) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;31.22999903975783553&quot;</span></span><br><span class="line"> <span class="comment">#================================限定返回的记录数为1================================      </span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km  count <span class="number">1</span></span><br><span class="line"> <span class="attribute">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> <span class="comment">#================================查找结果根据距离从近到远排序================================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km  withdist asc</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;478.2625&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;591.3126&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure><p><strong>georadiusbymember实例：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.583333</span> <span class="number">37.316667</span> <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line"> (<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">&quot;Palermo&quot;</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">&quot;Catania&quot;</span></span><br><span class="line"> (<span class="built_in">integer</span>) <span class="number">2</span></span><br><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEORADIUSBYMEMBER Sicily Agrigento <span class="number">100</span> km</span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEORADIUSBYMEMBER Sicily Agrigento <span class="number">100</span> km withdist</span><br><span class="line"> <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line">    <span class="number">2</span>) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">    <span class="number">2</span>) <span class="string">&quot;90.9778&quot;</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><blockquote><p>geohash：返回一个或多个位置对象的 geohash 值。</p></blockquote><ul><li>Redis GEO 使用 geohash 来保存地理位置的坐标，</li><li>将二维经纬度转化为一维字符串，如果两个字符串越接近，则两个位置越接近。</li><li>geohash 用于获取一个或多个位置元素的 geohash 值。</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> &quot;Palermo&quot; <span class="number">15.087269</span> <span class="number">37.502669</span> &quot;Catania&quot;</span><br><span class="line"> (integer) <span class="number">2</span></span><br><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line"> <span class="number">1</span>) &quot;sqc8b49rny0&quot;</span><br><span class="line"> <span class="number">2</span>) &quot;sqdtr74hyu0&quot;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><blockquote><p>geo底层实现原理其实就是zset，我们可以通过zset命令来操作geo</p></blockquote><p><strong>尝试用zset的查询指令，查询添加的GEO信息：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; geoadd chin<span class="variable">a:city</span> <span class="number">116.40</span> <span class="number">39.90</span> beijing</span><br><span class="line"> (integer) <span class="number">1</span></span><br><span class="line"> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;  geoadd chin<span class="variable">a:city</span> <span class="number">106.50</span> <span class="number">29.53</span> chongqing <span class="number">121.47</span> <span class="number">31.23</span> shanghai</span><br><span class="line"> (integer) <span class="number">2</span></span><br><span class="line"> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange chin<span class="variable">a:city</span> <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;4026042091628984&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;4054803462927619&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4069885360207904&quot;</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>可以查到 “chongqing&quot;的位置信息为&quot;4026042091628984”， “shanghai&quot;的位置信息为&quot;4054803462927619”， “beijing&quot;的位置信息为&quot;4069885360207904”。</p><p>4026042091628984为对经纬度进行编码后的值。使用4026042091628984做为score 能够快速实现对经纬度的索引。</p><p><strong>至此能够推断出Redis GEO 添加经、纬度位置信息的指令的过程是：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">ZADD</span> china:city <span class="number">4026042091628984</span> chongqing</span><br><span class="line"> <span class="attribute">ZADD</span> china:city <span class="number">4054803462927619</span> shanghai</span><br><span class="line"> <span class="attribute">ZADD</span> china:city <span class="number">4069885360207904</span> beijing</span><br><span class="line"><span class="attribute">123</span></span><br></pre></td></tr></table></figure><p><strong>对数据进行删除：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; zrem china:city chongqing</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; zrange china:city <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Redis Geospatial地理位置的使用</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
    <category term="Geospatial" scheme="https://www.sadalsuud.cn/tags/Geospatial/"/>
    
  </entry>
  
  <entry>
    <title>Redis Key 基本命令及 String 类型详解</title>
    <link href="https://www.sadalsuud.cn/posts/ae6bd4af.html"/>
    <id>https://www.sadalsuud.cn/posts/ae6bd4af.html</id>
    <published>2024-06-15T10:24:27.000Z</published>
    <updated>2024-06-15T10:39:39.267Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-四-——Redis-Key-基本命令及-String-类型详解">Redis(四)——Redis Key 基本命令及 String 类型详解</h2><h3 id="1、Redis-Key基本命令">1、Redis Key基本命令</h3><p>Redis Key（键）命令用于管理 redis 的键。</p><p><strong>语法</strong></p><p>Redis 键命令的基本语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">redis</span> <span class="number">127.0.0.1:6379</span>&gt; COMMAND KEY_NAME</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>Redis Key 使用案例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name wanli  </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> <span class="built_in">pwd</span> 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;pwd&quot;</span></span><br><span class="line"><span class="comment">#-----------------------判断是否存在某个key-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; exists name   <span class="comment">#判断是否存在某个key，</span></span><br><span class="line">(<span class="built_in">integer</span>) 1   <span class="comment">#存在为1，</span></span><br><span class="line">127.0.0.1:6379&gt; exists name1</span><br><span class="line">(<span class="built_in">integer</span>) 0   <span class="comment">#不存在为0</span></span><br><span class="line"><span class="comment">#-----------------------把指定key移动到指定数据库-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; move name 1  <span class="comment">#把名为name的key移动到1号数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;pwd&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; select 1    <span class="comment">#切换到1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *   <span class="comment">#key移动成功</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; flushdb  <span class="comment">#清除1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *  </span><br><span class="line">(empty array)</span><br><span class="line"><span class="comment">#-----------------------指定key的过期时间-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; expire <span class="built_in">pwd</span> 15  <span class="comment">#指定名为pwd的key 15s后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">pwd</span>  <span class="comment">#查看还有多少时间过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">pwd</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">pwd</span></span><br><span class="line">(<span class="built_in">integer</span>) -2        <span class="comment">#key已经过期了</span></span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">pwd</span>   </span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)   </span><br><span class="line"><span class="comment">#-----------------------查看key的类型-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> <span class="built_in">pwd</span></span><br><span class="line">string</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure><p>更多常用的Redis Key命令请参照下表：更多命令请参考：<a href="https://redis.io/commands">https://redis.io/commands</a></p><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td>DEL key 该命令用于在 key 存在时删除 key。</td></tr><tr><td>2</td><td>DUMP key 序列化给定 key ，并返回被序列化的值。</td></tr><tr><td>3</td><td>EXISTS key 检查给定 key 是否存在。</td></tr><tr><td>4</td><td>EXPIRE key seconds 为给定 key 设置过期时间，以秒计。</td></tr><tr><td>5</td><td>EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td>6</td><td>PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。</td></tr><tr><td>7</td><td>PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td>8</td><td>KEYS pattern 查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td>9</td><td>MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td>10</td><td>PERSIST key 移除 key 的过期时间，key 将持久保持。</td></tr><tr><td>11</td><td>PTTL key 以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td>12</td><td>TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td></tr><tr><td>13</td><td>RANDOMKEY 从当前数据库中随机返回一个 key 。</td></tr><tr><td>14</td><td>RENAME key newkey 修改 key 的名称</td></tr><tr><td>15</td><td>RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td>16</td><td>SCAN cursor MATCH pattern] [COUNT count 迭代数据库中的数据库键。</td></tr><tr><td>17</td><td>TYPE key 返回 key 所储存的值的类型。</td></tr></tbody></table><p>参考自菜鸟教程：<a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></p><h3 id="2、Redis-字符串-String-类型">2、Redis <a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020">字符串</a>(String)类型</h3><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><p><strong>语法：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">redis</span> <span class="number">127.0.0.1:6379</span>&gt; COMMAND KEY_NAME</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>使用实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----------------------key-value的存取-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 wanli</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;wanli&quot;</span></span><br><span class="line"><span class="comment">#---------------------- 将指定的 value 追加到该 key 原来值（value）的末尾-------------</span></span><br><span class="line">127.0.0.1:6379&gt; append key1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;wanlihello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;hi&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;wanlihellohi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append key3 taoxian  <span class="comment">#如果指定的key不存在，就会创建该指定key，并赋于value</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Redis Key 基本命令及 String 类型详解</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL数据库四大分类</title>
    <link href="https://www.sadalsuud.cn/posts/d43317f5.html"/>
    <id>https://www.sadalsuud.cn/posts/d43317f5.html</id>
    <published>2024-06-15T10:03:37.000Z</published>
    <updated>2024-06-15T10:20:50.568Z</updated>
    
    <content type="html"><![CDATA[<h1>NoSQL数据库四大分类</h1><p>NoSQL数据库是一类不使用传统的关系型数据库管理系统（RDBMS）模式的数据库。它们通常用于处理大量数据，并具有高度的可扩展性和灵活性。NoSQL数据库可以根据其数据模型分为四大类：键值存储数据库、列存储数据库、文档存储数据库和图数据库。以下是每一类的简要概述和代表性数据库。</p><h3 id="1-键值存储数据库-Key-Value-Stores">1. 键值存储数据库 (Key-Value Stores)</h3><h4 id="概述">概述</h4><p>键值存储数据库使用键值对来存储数据，每个键都是唯一的，并且与一个值相关联。它们适用于简单的数据模型，提供了快速的读写性能和高度的可扩展性。</p><h4 id="代表性数据库">代表性数据库</h4><ul><li><strong>Redis:</strong> Redis 是一个内存中数据结构存储，可以用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。</li><li><strong>Riak:</strong> Riak 是一个分布式键值存储数据库，具有高可用性、故障容忍和数据持久性特性。</li></ul><h3 id="2-列存储数据库-Column-Family-Stores">2. 列存储数据库 (Column-Family Stores)</h3><h4 id="概述-2">概述</h4><p>列存储数据库将数据按列族（Column Family）存储，而不是按行存储。每个列族可以看作是一个键值对集合。它们适用于分析和处理大量数据，因为它们在处理某些类型的查询时非常高效。</p><h4 id="代表性数据库-2">代表性数据库</h4><ul><li><strong>Apache HBase:</strong> HBase 是一个基于Hadoop的开源分布式数据库，可以处理非常大的表，适用于需要实时读取和写入访问大数据的应用程序。</li><li><strong>Cassandra:</strong> Cassandra 是一个分布式数据库管理系统，设计用于处理大量数据的跨多个商品服务器的分布式数据存储。</li></ul><h3 id="3-文档存储数据库-Document-Stores">3. 文档存储数据库 (Document Stores)</h3><h4 id="概述-3">概述</h4><p>文档存储数据库使用文档（通常是JSON、BSON或XML格式）来存储数据。每个文档都包含数据项和其元数据，可以嵌套复杂的数据结构。它们适用于需要灵活数据模型的应用程序。</p><h4 id="代表性数据库-3">代表性数据库</h4><ul><li><strong>MongoDB:</strong> MongoDB 是一个基于文档的数据库，提供高性能、高可用性和自动扩展。它使用灵活的JSON-like文档模式。</li><li><strong>CouchDB:</strong> CouchDB 是一个面向文档的数据库，采用JSON来存储数据，JavaScript来查询，利用MapReduce来进行索引和查询。</li></ul><h3 id="4-图数据库-Graph-Databases">4. 图数据库 (Graph Databases)</h3><h4 id="概述-4">概述</h4><p>图数据库使用图结构来存储数据，包括节点、边和属性。它们擅长处理复杂的关系和关联数据，适用于社交网络、推荐系统等应用。</p><h4 id="代表性数据库-4">代表性数据库</h4><ul><li><strong>Neo4j:</strong> Neo4j 是一个高性能的图数据库，使用图结构来存储数据。它适用于需要高效查询图状数据的应用。</li><li><strong>OrientDB:</strong> OrientDB 是一个多模型数据库，支持图、文档、键值、对象等多种模型。它可以存储大量数据，同时提供高性能的图查询能力。</li></ul><h3 id="总结">总结</h3><p>NoSQL数据库通过不同的数据模型提供了对特定应用场景的高效支持。键值存储数据库适用于简单的查找操作；列存储数据库适用于大规模数据分析；文档存储数据库适用于需要灵活数据结构的应用；图数据库则适用于处理复杂关系的数据。选择合适的NoSQL数据库取决于具体的应用需求和数据特点。</p>]]></content>
    
    
    <summary type="html">本文将介绍NoSQL的四大分类以及代表性数据库。</summary>
    
    
    
    <category term="架构" scheme="https://www.sadalsuud.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
    <category term="NoSQL" scheme="https://www.sadalsuud.cn/tags/NoSQL/"/>
    
    <category term="MongoDB" scheme="https://www.sadalsuud.cn/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>音视频&amp;流媒体的原理以及基础入门知识</title>
    <link href="https://www.sadalsuud.cn/posts/bf51a49e.html"/>
    <id>https://www.sadalsuud.cn/posts/bf51a49e.html</id>
    <published>2024-06-15T03:38:45.000Z</published>
    <updated>2024-06-15T03:46:27.049Z</updated>
    
    <content type="html"><![CDATA[<h1>音视频&amp;流媒体的原理以及基础入门知识</h1><h2 id="流媒体背景">流媒体背景</h2><p>当下，音视频、流媒体已经无处不在，直播已经火了几年，在后续的时间里面，人们聊天已经不仅仅满足与文字、而是更多的在于“类面对面”交流，能够实时感知对方的表情、动作。为此，有必要跟紧时代潮流，好好梳理梳理流媒体这门功课。</p><p>流媒体是什么？流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术。那么音视频就是流媒体的核心。</p><h2 id="音视频常见术语定义规范">音视频常见术语定义规范</h2><h2 id="音视频组成">音视频组成</h2><p>一个完整的视频文件，包括音频、视频和基础元信息，我们常见的视频文件如mp4、mov、flv、avi、rmvb等视频文件，就是一个容器的封装，里面包含了音频和视频两部分，并且都是通过一些特定的编码算法，进行编码压缩过后的。</p><p>H264、Xvid等就是视频编码格式，MP3、AAC等就是音频编码格式。例如：将一个Xvid视频编码文件和一个MP3音频编码文件按AVI封装标准封装以后，就得到一个AVI后缀的视频文件。</p><p>因此，视频转换需要设置的本质就是</p><ul><li>设置需要的视频编码</li><li>设置需要的音频编码</li><li>选择需要的容器封装</li></ul><p>一个完整的视频转换设置都至少包括了上面3个步骤。</p><h2 id="编码格式">编码格式</h2><p><strong>音频编码格式</strong></p><p>音频编码格式有如下</p><ul><li>AAC</li><li>AMR</li><li>PCM</li><li>ogg(ogg vorbis音频)</li><li>AC3(DVD 专用音频编码)</li><li>DTS(DVD 专用音频编码)</li><li>APE(monkey’s 音频)</li><li>AU(sun 格式)</li><li>WMA</li></ul><p>音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3</p><p>目前最常见的音频格式有 Mp3、AC-3、ACC，MP3最广泛的支持最多，AC-3是杜比公司的技术，ACC是MPEG-4中的音频标准，ACC是目前比较先进和具有优势的技术。对应入门，知道有这几种最常见的音频格式足以。</p><p><strong>视频编码格式</strong></p><p>视频编码标准有两大系统： MPEG 和ITU-T，国际上制定视频编解码技术的组织有两个，一个是“国际电联（ITU-T）”，它制定的标准有H.261、H.263、H.263+、H.264等，另一个是“国际标准化组织（ISO）”它制定的标准有MPEG-1、MPEG-2、MPEG-4等。</p><p>常见编码格式有：</p><ul><li>Xvid(MPEG4)</li><li>H264 （目前最常用编码格式）</li><li>H263</li><li>MPEG1，MPEG2</li><li>AC-1</li><li>RM，RMVB</li><li>H.265（目前用的不够多）</li></ul><p>目前最常见的视频编码方式的大致性能排序基本是： MPEG-1/-2 &lt; WMV/7/8 &lt; RM/RMVB &lt; Xvid/Divx &lt; AVC/H.264（由低到高，可能不完全准确）。</p><p>在H.265出来之前，H264是压缩率最高的视频压缩格式，其优势有:</p><ul><li>低码率（Low Bit Rate）：和MPEG2和MPEG4 ASP等压缩技术相比，在同等图像质量下，采用H.264技术压缩后的数据量只有MPEG2的1/8，MPEG4的1/3。</li><li>高质量的图象 ：H.264能提供连续、流畅的高质量图象（DVD质量）。</li><li>容错能力强 ：H.264提供了解决在不稳定网络环境下容易发生的丢包等错误的必要工具。</li><li>网络适应性强 ：H.264提供了网络抽象层（Network Abstraction Layer），使得H.264的文件能容易地在不同网络上传输（例如互联网，CDMA，GPRS，WCDMA，CDMA2000等）。</li></ul><p>H.264最大的优势是具有很高的数据压缩比率，在同等图像质量的条件下，H.264的压缩比是MPEG-2的2倍以上，是MPEG-4的1.5～2倍。举个例子，原始文件的大小如果为88GB，采用MPEG-2压缩标准压缩后变成3.5GB，压缩比为25∶1，而采用H.264压缩标准压缩后变为879MB，从88GB到879MB，H.264的压缩比达到惊人的102∶1。低码率（Low Bit Rate）对H.264的高的压缩比起到了重要的作用，和MPEG-2和MPEG-4 ASP等压缩技术相比，H.264压缩技术将大大节省用户的下载时间和数据流量收费。尤其值得一提的是，H.264在具有高压缩比的同时还拥有高质量流畅的图像，正因为如此，经过H.264压缩的视频数据，在网络传输过程中所需要的带宽更少，也更加经济。</p><p>目前这些常见的视频编码格式实际上都属于有损压缩，包括H264和H265，也是有损编码，有损编码才能在质量得以保证的前提下得到更高的压缩率和更小体积</p><h2 id="存储封装格式">存储封装格式</h2><p>目前市面常见的存储封装格式有如下：</p><ul><li>AVI (.avi)</li><li>ASF（.asf)</li><li>WMV (.wmv)</li><li>QuickTime ( .mov)</li><li>MPEG (.mpg / .mpeg)</li><li>MP4 (.mp4)</li><li>m2ts （.m2ts / .mts )</li><li>Matroska （.mkv / .mks / .mka )</li><li>RM ( .rm / .rmvb)</li><li>TS/PS</li></ul><p>AVI : 可用MPEG-2, DIVX, XVID, WMV3, WMV4, AC-1, H.264</p><p>WMV : 可用WMV3, WMV4, AC-1</p><p>RM/RMVB : 可用RV40, RV50, RV60, RM8, RM9, RM10</p><p>MOV : 可用MPEG-2, MPEG4-ASP(XVID), H.264</p><p>MKV : 所有</p><h2 id="视频码率、帧率、分辨率">视频码率、帧率、分辨率</h2><p><strong>码率</strong></p><p>码流(Data Rate)是指视频文件在单位时间内使用的数据流量，也叫码率或码流率，通俗一点的理解就是取样率,是视频编码中画面质量控制中最重要的部分，一般我们用的单位是kb/s或者Mb/s。一般来说同样分辨率下，视频文件的码流越大，压缩比就越小，画面质量就越高。码流越大，说明单位时间内采样率越大，数据流，精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p><p>当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部90分钟1Mbps码率的720P RMVB文件，其体积就=5400秒×1Mbps/8=675MB。</p><p>通常来说，一个视频文件包括了画面（视频）及声音（音频），例如一个RMVB的视频文件，里面包含了视频信息和音频信息，音频及视频都有各自不同的采样方式和比特率，也就是说，同一个视频文件音频和视频的比特率并不是一样的。而我们所说的一个视频文件码流率大小，一般是指视频文件中音频及视频信息码流率的总和。</p><p><strong>帧率</strong></p><p>帧率也称为FPS(Frames Per Second)- - - 帧/秒。是指每秒钟刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。越高的帧速率可以得到更流畅、更逼真的动画。每秒钟帧数(FPS)越多，所显示的动作就会越流畅。</p><p>关于帧率有如下几个基础数据：</p><ul><li>帧率越高，cpu消耗就高</li><li>秀场视频直播，一般帧率20fps</li><li>普通视频直播，一般帧率15fps</li></ul><p><strong>分辨率</strong></p><p>视频分辨率是指视频成像产品所成图像的大小或尺寸。常见的视像分辨率有352×288，176×144，640×480，1024×768。在成像的两组数字中，前者为图片长度，后者为图片的宽度，两者相乘得出的是图片的像素，长宽比一般为4：3.</p><p>480P : 640 x 480 个像素点</p><p>720P : 1280 x 720 个像素点</p><p>1080P : 1920 x 1080 个像素点</p><p>然后还需要关注每个像素点的存储格式，每个像素点占用的字节大小。</p><h2 id="图像存储格式yuv">图像存储格式yuv</h2><p><strong>一幅彩色图像的基本要素是什么？</strong></p><p>1、宽：一行有多少个像素点。</p><p>2、高：一列有多少个像素点，一帧有多少行</p><p>3、YUV格式还是RGB格式？</p><p>4、一行多少个字节？？</p><p>5、图像大小是多少？</p><p>6、图像的分辨率多少？</p><p>说白了，一幅图像包括的基本东西就是二进制数据，其容量大小实质即为二进制数据的多少。一幅1920x1080像素的YUV422的图像，大小是1920X1080X2=4147200（十进制），也就是3.95M大小。这个大小跟多少个像素点和数据的存储格式有关。</p><h2 id="YUV与像素的关系：">YUV与像素的关系：</h2><p>YUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p><p>YUV格式有两大类：planar和packed。对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。对于packed的YUV格式，每个像素点的Y,U,V是连续交替存储的。</p><p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p><p>YUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。</p><p>如果使用YUV表示这个像素，假设YUV的采样率为：4：2：0，即每一个像素对于亮度Y的采样频率为1，对于色差U和V，则是每相邻的两个像素各取一个U和V。对于单个的像素来说，色差U和V的采样频率为亮度的一半。如有三个相邻的像素，如果用RGB三原色表示，则共需要占用：8 * 3 * 3 = 72bits；如果采用YUV（4：2：0）表示，则只需要占用：8 * 3（Y）+ 8* 3 * 0.5（U）+ 8 * 3 * 0.5（V）= 36bits。只需原来一半的空间，就可以表示原来的图像，数据率压缩了一倍，而图像的效果基本没发生变化。</p><p>那么，具体yuv格式所占用的字节数要怎么算呢 ？</p><h2 id="YUV图像格式的内存大小">YUV图像格式的内存大小</h2><ul><li>4:4:4 表示色度值(UV)没有减少采样。即Y,U,V各占一个字节，加上Alpha通道一个字节，总共占4字节.这个格式其实就是24bpp的RGB格式了。</li><li>4:2:2 表示UV分量采样减半,比如第一个像素采样Y,U,第二个像素采样Y,V,依次类推,这样每个点占用2个字节.二个像素组成一个宏像素.</li><li>需要占用的内存：w * h * 2</li><li>4:2:0 这种采样并不意味着只有Y，Cb而没有Cr分量，这里的0说的U，V分量隔行才采样一次。比如第一行采样 4:2:0 ,第二行采样 4:0:2 ,依次类推…在这种采样方式下，每一个像素占用16bits或10bits空间.</li><li>内存则是：yyyyyyyyuuvv</li><li>需要占用的内存：w * h * 3 / 2</li><li>4:1:1 可以参考4:2:2分量，是进一步压缩，每隔四个点才采一次U和V分量。一般是第1点采Y,U,第2点采Y,第3点采YV,第4点采Y,依次类推。</li></ul><h2 id="帧率、码率与分辨率之间关系">帧率、码率与分辨率之间关系</h2><p>码率和帧率没有半毛钱关系</p><p>码率关系着带宽、文件体积</p><p>帧率关系着画面流畅度和cpu消耗</p><p>分辨率关系着图像尺寸和清晰度</p><p><strong>一个视频文件的大小为5.86M,播放时长为3分7秒</strong></p><ul><li>1，该文件对应的码率就是</li><li>5.86 * 1024 * 1024 * 8 / (3 * 60 + 7) = 262872.95657754bps</li><li>2，10M独享带宽能支撑的同时在线人数</li><li>10 * 1024 * 1024 / 262872.95657754 = 39.889078498294</li><li>3， 支撑1000人同时在线的系统最少需要的带宽数为</li><li>262872 * 1000 / (1024 * 1024) = 250.69427490234M</li></ul><p><strong>10min，流量消耗41587KB</strong></p><p>41587/10*60 = 69KB/s = 69 * 8 Kb/s = 532Kb/s</p><p>那么得到码率就是 532Kb/s</p><p><strong>输出文件大小公式</strong></p><p>一个音频编码率为128Kbps，视频编码率为800Kbps的文件，其总编码率为928Kbps，意思是经过编码后的数据每秒钟需要用928K比特来表示。</p><p>文件大小公式：</p><p>（音频编码率（KBit为单位）/8 + 视频编码率（KBit为单位）/8）× 影片总长度（秒为单位）= 文件大小（MB为单位）</p><p><strong>一帧图像大小</strong></p><p>一帧图像原始大小 = 宽像素 * 长像素 ，当然要考虑数据格式，因为数据格式不一样，大小写也不相同，一般数据采用rgb、yuv格式，如rgb32、yuv420、yuv422等。最常用的应当属于yuv420。 因此，计算公式为：</p><p>文件的字节数 = 图像分辨率 * 图像量化位数/8</p><p>图像分辨率 = X方向的像素数 * Y方向的像素数</p><p>图像量化数 = 二进制颜色位数</p><ul><li>RGB24每帧的大小是</li></ul><p>size＝width×heigth×3 Bit</p><ul><li>RGB32每帧的大小是</li></ul><p>size＝width×heigth×4</p><ul><li>YUV420每帧的大小是</li></ul><p>size＝width×heigth×1.5 Bit</p><p>举例说明，对于一个1024*768的图像实际的YUV422数据流大小就为：1024 *768 * 2 = 1572864bit</p><h2 id="音频采样率、位数">音频采样率、位数</h2><p>1、声道数：声道数是音频传输的重要指标，现在主要有单声道和双声道之分。双声道又称为立体声，在硬件中要占两条线路，音质、音色好， 但立体声数字化后所占空间比单声道多一倍。</p><p>2、量化位数： 量化位是对模拟音频信号的幅度轴进行数字化，它决定了模拟信号数字化以后的动态范围。由于计算机按字节运算，一般的量化位数为 8位和16位。量化位越高，信号的动态范围越大，数字化后的音频信号就越可能接近原始信号，但所需要的存储空间也越大。</p><p>3、采样率：也称为采样速度或者采样频率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样率是指将模拟信号转换成数字信号时的采样频率，也就是单位时间内采样多少点。一个采样点数据有多少个比特。比特率是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，传送的数据越大，音质越好.</p><p>采样率的选择应该遵循奈奎斯特(Harry Nyquist)采样理论( 如果对某一模拟信号进行采样，则采样后可还原的最高信号频率只有采样频率的一半，或者说只要采样频率高于输入信号最高频率的两倍，就能从采样信号系列重构原始信号 )。根据该采样理论， CD激光唱盘采样频率为 44kHz，可记录的最高音频为 22kHz，这样的音质与原始声音相差无几，也就是我们常说的超级高保真音质。通信系统中数字电话的采用频率通常为 8kHz，与原 4k带宽声音一致的。</p><p>比特率(音频) = 采样率 x 采用位数 x 声道数.</p><p>以电话为例，每秒3000次取样，每个取样是7比特，那么电话的比特率是21000。 而CD是每秒 44100次取样，两个声道，每个取样是13位PCM编码，所以CD的比特率是44100213=1146600，也就是说CD每秒的数据量大约是 144KB，而一张CD的容量是74分等于4440秒，就是639360KB＝640MB。</p><h2 id="I帧、P帧、B帧、IDR帧">I帧、P帧、B帧、IDR帧</h2><p><strong>I帧:帧内编码帧</strong></p><p>I帧特点:</p><ol><li>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;</li><li>解码时仅用I帧的数据就可重构完整图像;</li><li>I帧描述了图像背景和运动主体的详情;</li><li>I帧不需要参考其他画面而生成;</li><li>I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);</li><li>I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;</li><li>I帧不需要考虑运动矢量;</li><li>I帧所占数据的信息量比较大。</li></ol><p><strong>P帧:前向预测编码帧</strong></p><p>P帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。又称predictive-frame，通过充分将低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧</p><p>P帧特点:</p><ol><li>P帧是I帧后面相隔1~2帧的编码帧;</li><li>P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</li><li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</li><li>P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;</li><li>P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</li><li>由于P帧是参考帧,它可能造成解码错误的扩散;</li><li>由于是差值传送,P帧的压缩比较高。</li></ol><p><strong>B帧:双向预测内插编码帧。</strong></p><p>B帧的预测与重构:B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。 又称bi-directional interpolated prediction frame，既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧</p><p>B帧特点:</p><ol><li>B帧是由前面的I或P帧和后面的P帧来进行预测的;</li><li>B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;</li><li>B帧是双向预测编码帧;</li><li>B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;</li><li>B帧不是参考帧,不会造成解码错误的扩散。</li></ol><p><strong>IDR 帧</strong></p><p>IDR（Instantaneous Decoding Refresh）–即时解码刷新。</p><p>I和IDR帧都是使用帧内预测的。它们都是同一个东西而已,在编码和解码中为了方便，要首个I帧和其他I帧区别开，所以才把第一个首个I帧叫IDR，这样就方便控制编码和解码流程。IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始,重新算一个新的序列开始编码。而I帧不具有随机访问的能力，这个功能是由IDR承担。IDR会导致DPB（DecodedPictureBuffer参考帧列表——这是关键所在）清空，而I不会。IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有很多的I图像，I图像之后的图像可以引用I图像之间的图像做运动参考。一个序列中可以有很多的I图像，I图像之后的图象可以引用I图像之间的图像做运动参考。</p><p>对于IDR帧来说，在IDR帧之后的所有帧都不能引用任何IDR帧之前的帧的内容，与此相反，对于普通的I-帧来说，位于其之后的B-和P-帧可以引用位于普通I-帧之前的I-帧。从随机存取的视频流中，播放器永远可以从一个IDR帧播放，因为在它之后没有任何帧引用之前的帧。但是，不能在一个没有IDR帧的视频中从任意点开始播放，因为后面的帧总是会引用前面的帧。</p><p><strong>小结</strong></p><p>I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）.</p><p>P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）.</p><p>B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。</p><p>PTS：Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来</p><p>DTS：Decode Time Stamp。DTS主要是标识读入内存中的bit流在什么时候开始送入解码器中进行解码。</p><p>DTS主要用于视频的解码,在解码阶段使用.PTS主要用于视频的同步和输出.在display的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的.</p><h2 id="GOP">GOP</h2><p>两个I frame之间形成一个GOP，在x264中同时可以通过参数来设定bf的大小，即：I 和p或者两个P之间B的数量。如果有B frame 存在的情况下一个GOP的最后一个frame一定是P.</p><p>一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p><p>如果一个GOP里面丢了I帧，那么后面的P帧、B帧也将会无用武之地，因此必须丢掉，但是一般策略会保证I帧不丢（如通过tcp协议保证） ，如果采用UDP，那么也会有更多的策略来保证I帧正确传输。</p><p><strong>编解码</strong></p><p><strong>硬编解码</strong></p><p>通过硬件实现编解码，减轻CPU计算的负担，如GPU等</p><p><strong>软编解码</strong></p><p>如 H264、H265、MPEG-4等编解码算法，更消耗CPU</p><p><strong>数据优化</strong></p><p>数据优化和编解码算法息息相关，一般而言</p><p>视频帧大小</p><ul><li>一般I 帧的压缩率是7，P 帧是20，B 帧可以达到50 (数据不精确)</li><li>P帧大概是3~4KB (480P, 1200k码率, baseline profile)</li></ul><p>音频帧大小</p><ul><li>(采样频率（Hz）* 采样位数（bit）* 声道数)/ 8</li><li>48000hz大概经过AAC压缩后，应该是12KB/s左右</li></ul><h2 id="流媒体传输协议">流媒体传输协议</h2><p>常用的流媒体协议主要有 HTTP 渐进下载和基于 RTSP/RTP 的实时流媒体协议，这二种基本是完全不同的东西</p><p>CDN直播中常用的流媒体协议包括RTMP，HLS，HTTP FLV</p><h2 id="RTP，RTCP">RTP，RTCP</h2><p>实时传输协议（Real-time Transport Protocol），RTP协议常用于流媒体系统（配合RTCP协议），视频会议和一键通系统（配合H.323或SIP），使它成为IP电话产业的技术基础。RTP协议和RTP控制协议RTCP一起使用，而且它是建立在UDP协议上的。</p><p>实时传输控制协议（Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）是实时传输协议的一个姐妹协议。RTCP为RTP媒体流提供信道外控制。RTCP本身并不传输数据，但和RTP一起协作将多媒体数据打包和发送。RTCP定期在流多媒体会话参加者之间传输控制数据。RTCP的主要功能是为RTP所提供的服务质量提供反馈。</p><p>RTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。</p><p><strong>小结</strong></p><p><strong>RTMP</strong></p><p>RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p><p>它有三种变种：</p><ul><li>工作在TCP之上的明文协议，使用端口1935；</li><li>RTMPT封装在HTTP请求之中，可穿越防火墙；</li><li>RTMPS类似RTMPT，但使用的是HTTPS连接；</li></ul><p>总结： RTMP协议基于TCP来实现，每个时刻的数据，收到后立刻转发，一般延迟在1-3s左右</p><p><strong>HLS</strong></p><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。基本原理就是将视频或流切分成小片（TS）， 并建立索引（M3U8）.</p><p>相对于常见的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p><p>总结： HLS协议基于HTTP短连接来实现，集合一段时间数据，生成ts切片文件，然后更新m3u8(HTTP Live Streaming直播的索引文件)，一般延迟会大于10s</p><p><strong>HTTP-FLV</strong></p><p>HTTP-FLV基于HTTP长连接，通RTMP一样，每个时刻的数据，收到后立刻转发，只不过使用的是HTTP协议，一般延迟在1-3s</p><p><strong>CDN</strong></p><p>CDN架构设计比较复杂。不同的CDN厂商，也在对其架构进行不断的优化，所以架构不能统一而论。这里只是对一些基本的架构进行简单的剖析。</p><p>CDN主要包含：源站、缓存服务器、智能DNS、客户端等几个主要组成部分。</p><p>源站：是指发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。对于直播来说，源站为主播客户端。</p><p>缓存服务器：是直接提供给用户访问的站点资源，由一台或数台服务器组成；当用户发起访问时，他的访问请求被智能DNS定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。</p><p>智能DNS：是整个CDN技术的核心，它主要根据用户的来源，以及当前缓存服务器的负载情况等，将其访问请求指向离用户比较近且负载较小的缓存服务器。通过智能DNS解析，让用户访问同服务商下、负载较小的服务器，可以消除网络访问慢的问题，达到加速作用。</p><p>客户端：即发起访问的普通用户。对于直播来说，就是观众客户端。</p><p><strong>弱网优化</strong></p><p>弱网优化的策略包括如下：</p><ul><li>播放器Buffer</li><li>丢帧策略 (优先丢P帧，其次I帧，最后音频)</li><li>自适应码率算法</li><li>双向链路优化</li><li>音频FEC冗余算法(20%丢包率）</li></ul><p><strong>丢帧</strong></p><p>在弱网情况下，为了达到更好的体验，可能会采取丢帧的策略，但是丢帧，怎么丢呢？丢音频帧还是视频帧呢 ？ 因为视频帧比较大，并且视频帧前后是有关联的；音频帧很小，关键是音频帧是连续采样的，丢了音频帧，那声音就会明显出现瑕疵。为此，一般的丢帧策略是丢视频帧</p><p><strong>自适应码率</strong></p><p>在弱网情况下，另外一种靠谱的策略是自适应码率算法，通过设置码率降级为多个档次，这样，当网络不好的情况下，通过降低码率进行预测，如果码率降低后，还不够buffer缓冲，那么继续降低一个档次，是一个循环探测的过程，如果再次降级一个档次后，发现buffer缓冲足够了，那么说明当前网络能够适应这个码率，因此就会采取当前码率。同理，升档也是一样的。但是这个属于厂商的核心算法，</p><p><strong>实时聊天的挑战</strong></p><p>简单估算一下大概的网络延时。众所周知，光在真空中的速度约为300,000km/s，而在其他介质中光 速会大大降低，所以在普通光纤中，工程上一般认为传输速度是200,000km/s。从现实上来说，可以参考如下：</p><p>实时聊天的挑战主要在于以下几点:</p><ul><li>实时性: 600ms以内</li><li>网络的不对称性</li><li>距离</li></ul><h2 id="视频文件格式">视频文件格式</h2><p>首先让我们了解一下什么是视频文件格式？</p><p>1.容器和编解码器是任何视频文件的两个组成部分。 视频格式是存储音频，视频，字幕和任何其他源数据的容器。 编解码器对诸如音频和视频之类的多媒体数据进行编码和解码。</p><p>2.创建视频时，视频编解码器对视频进行编码和压缩，而音频编解码器对声音也是如此。 之后，编码的视频和音频将同步并存储在媒体容器（文件格式）中。</p><p>下面我分别介绍一下8种常见的视频文件格式，编解码器和容器</p><p><strong>1. MP4</strong></p><p>MPEG-4 Part 14或MP4是2001年推出的最早的数字视频文件格式之一。大多数数字平台和设备都支持MP4。 MP4格式可以存储音频文件，视频文件，静止图像和文本。 此外，MP4提供高质量的视频，同时保持相对较小的文件大小。</p><p><strong>2. MOV</strong></p><p>MOV是苹果设计的一种流行的视频文件格式。 它旨在支持QuickTime播放器。 MOV文件包含视频，音频，字幕，时间码和其他媒体类型。 它适用于Mac和Windows的不同版本的QuickTimePlayer。 由于它是一种非常高质量的视频格式，因此MOV文件在计算机上会占用更多的存储空间。</p><p><strong>3. WMV</strong></p><p>WMV视频格式由Microsoft设计，并广泛用于Windows媒体播放器中。 WMV格式可提供比MP4更好的压缩小文件。 这这个优势使它在在线视频流中很受欢迎。 尽管它与苹果设备不兼容，但用户可以为iPhone或Mac下载Windows Media Player。</p><p><strong>4. FLV</strong></p><p>FLV是Adobe Flash Player使用的文件格式。 它支持所有视频平台和浏览器，并且使用相当广泛，是用途最广泛的视频格式之一。 FLV格式是YouTube等在线视频流媒体平台的理想选择。 它们的文件大小相对较小，因此易于下载。 唯一的缺点是它与许多移动设备（如iPhone）不兼容。</p><p><strong>5. AVI</strong></p><p>AVI文件格式是Microsoft于1992年引入的，如今仍被广泛使用。 AVI视频格式使用的压缩比其他视频格式（例如MPEG或MOV）少。 这将导致非常大的文件大小，每分钟视频大约2-3 GB。 对于存储空间有限的用户来说可能是个问题。 您也可以创建AVI视频文件而无需任何压缩，这使文件无损。 无论您打开或保存文件多少次，无损文件都不会随着时间的流逝失去其质量。 此外，这省去了在视频播放器中使用编解码器。</p><p><strong>6. AVCHD（高级视频编码）</strong></p><p>AVCHD是用于高清视频播放和数字录制的格式。 这种视频格式是由Panasonic和Sony设计的，用于专业高清视频录制。 通过利用H.264 / MPEG-4视频压缩技术，AVCHD还使您仅使用少量数据就可以存储数小时的高质量视频。 此外，AVCHD 2.0格式的最新版本支持三维视频存储。</p><p><strong>7. WebM</strong></p><p>WebM由Google于2010年首次引入，是一种开放源代码视频格式，是在考虑互联网当前和未来状态的基础上开发的。 WebM适用于HTML5。 WebM的视频编解码器只需很少的计算机功能即可压缩和解压缩文件。 此设计的目的是使几乎所有设备（例如平板电脑，台式机，智能手机或智能电视等设备）上的在线视频流式传输成为可能。</p><p><strong>8. MKV</strong></p><p>MKV文件格式在单个文件中合并了音频，视频和字幕。 MKV格式是为了将来的使用而开发的，这意味着视频文件将始终保持更新。 MKV容器几乎支持任何视频和音频格式，从而使该格式具有高度自适应性，与易用性。</p><h2 id="常见问题和解决方案">常见问题和解决方案</h2><ul><li>出现花屏、绿屏问题</li></ul><p>采集问题、编解码问题、声网传输丢帧问题</p><ul><li>声画不同步</li></ul><p>采集问题，或者公有云SDK问题</p><ul><li>画面有时候有点糊</li></ul><p>弱网，码率的自适应</p><ul><li>有声音没有画面</li></ul><p>弱网，触发了丢帧策略</p><ul><li>画面播放有时候卡顿</li></ul><p>CPU消耗过高导致卡顿，比如AR模块</p><p>弱网</p><ul><li>网络连接不上</li></ul><p>弱网</p><p>或者代码有Bug，或者公有云SDK有Bug</p><ul><li>出现马赛克现象？</li></ul><p>是否类似花屏 ？</p><ul><li>TODO</li></ul><p>其他常见指标 和 问题解决方案</p><h2 id="相关链接">相关链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/232291020">音视频&amp;流媒体的原理以及基础入门知识 - 知乎 (zhihu.com)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;音视频&amp;amp;流媒体的原理以及基础入门知识&lt;/h1&gt;
&lt;h2 id=&quot;流媒体背景&quot;&gt;流媒体背景&lt;/h2&gt;
&lt;p&gt;当下，音视频、流媒体已经无处不在，直播已经火了几年，在后续的时间里面，人们聊天已经不仅仅满足与文字、而是更多的在于“类面对面”交流，能够实时感知对方的表情、动</summary>
      
    
    
    
    <category term="演示" scheme="https://www.sadalsuud.cn/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="streaming media" scheme="https://www.sadalsuud.cn/tags/streaming-media/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的将MultipartFile和File互转</title>
    <link href="https://www.sadalsuud.cn/posts/f8448a72.html"/>
    <id>https://www.sadalsuud.cn/posts/f8448a72.html</id>
    <published>2024-06-15T03:02:11.000Z</published>
    <updated>2024-06-15T03:46:27.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>首先来区别一下MultipartFile和File:</p><ul><li>MultipartFile是 Spring 框架的一部分，File是 Java 标准库的一部分。</li><li>MultipartFile主要用于接收上传的文件，File主要用于操作系统文件。</li></ul><h2 id="MultipartFile转换为File">MultipartFile转换为File</h2><h3 id="使用-transferTo">使用 transferTo</h3><p>这是一种最简单的方法，使用MultipartFile自带的transferTo 方法将MultipartFile转换为File，这里通过上传表单文件，将MultipartFile转换为File格式，然后输出到特定的路径，具体写法如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151132476.png" alt="image-20240615113226175"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;C:\\desktop\\file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="comment">// Check if the file is empty</span></span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;文件为空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Ensure the upload directory exists</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR);</span><br><span class="line">            <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">                uploadDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the file to the specified directory</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR + File.separator + file.getOriginalFilename());</span><br><span class="line">            file.transferTo(targetFile);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-FileOutputStream">使用 FileOutputStream</h3><p>这是最常用的一种方法，使用 FileOutputStream 可以将字节写入文件。具体写法如下。</p><p><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/image-20240615113255746.png" alt="image-20240615113255746"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;C:\\desktop\\file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="comment">// Check if the file is empty</span></span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;文件为空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Ensure the upload directory exists</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR);</span><br><span class="line">            <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">                uploadDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the file to the specified directory</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR + File.separator + file.getOriginalFilename());</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">FileOutPutStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile)) &#123;</span><br><span class="line">                fos.write(file.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Java-NIO">使用Java NIO</h3><p>Java NIO 提供了文件复制的方法。具体写法如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151134781.png" alt="image-20240615113416663"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">string</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;C:\\desktop\lfile&quot;</span>;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot; )</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file)</span>&#123;</span><br><span class="line">        <span class="comment">// Check if the file is empty</span></span><br><span class="line">        <span class="keyword">if</span>(file.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>“文件为空<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                Path uploadPath = Paths.get(UPLOAD DIR);</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                // Ensure the upload directory exists</span></span><br><span class="line"><span class="string">                File uploadDir = new File(UPLOAD DIR);</span></span><br><span class="line"><span class="string">                if(!uploadDir.exists())&#123;</span></span><br><span class="line"><span class="string">                    uploadDir.mkdirs();</span></span><br><span class="line"><span class="string">                    // Save the file to the specified directory using Java NIO</span></span><br><span class="line"><span class="string">                    Path targetPath = uploadPath.resolve(file.getOriginalFilename());</span></span><br><span class="line"><span class="string">                    Files.copy(file.getInputstream(), targetPath, standardCopyOptiOn.REPLACE EXISTING);</span></span><br><span class="line"><span class="string">                    return“上传成功&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(I0Exception e)&#123;</span><br><span class="line">                    e.printstackTrace();</span><br><span class="line">                    <span class="keyword">return</span>“上传失败<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br></pre></td></tr></table></figure><h3 id="File装换为MultipartFile">File装换为MultipartFile</h3><p>从File转换为MultipartFile 通常在测试或模拟场景中使用，生产环境一般不这么用，这里只介绍一种最常用的方法。</p><h3 id="使用-MockMultipartFile">使用 MockMultipartFile</h3><p>在转换之前先确保引入了spring-test 依赖（以Maven举例）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过获得File文件的名称、mime类型以及内容将其转换为MultipartFile格式。具体写法如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151135870.png" alt="image-20240615113555637"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiToFileUtil</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Multipartfile <span class="title function_">convertMockMultipartfile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IoException&#123;</span><br><span class="line">      <span class="comment">//根据提供的文件路径创建Path对象</span></span><br><span class="line">      Path path= Paths.get(filePath);</span><br><span class="line">      <span class="comment">//获取文件的名字</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> path.getFileName().tostring();</span><br><span class="line">      <span class="comment">//使用 Java NI0的Files 类探测文件的 MIME 类型</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span>Files.probeContentType(path);</span><br><span class="line">      <span class="comment">//读取文件内容为字节数组</span></span><br><span class="line">      bytel] content = Files.readAllBytes(path);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockMultipartFile</span>(name, name, contentType, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">我们在开发过程中经常需要接收前端传来的文件，通常需要处理MultipartFile格式的文件。今天来介绍一下MultipartFile和File怎么进行优雅的互转。</summary>
    
    
    
    <category term="Java" scheme="https://www.sadalsuud.cn/categories/Java/"/>
    
    
    <category term="MultipartFile" scheme="https://www.sadalsuud.cn/tags/MultipartFile/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化-宕机了如何避免数据丢失</title>
    <link href="https://www.sadalsuud.cn/posts/e6419cec.html"/>
    <id>https://www.sadalsuud.cn/posts/e6419cec.html</id>
    <published>2024-06-15T02:38:14.000Z</published>
    <updated>2024-06-15T03:46:27.046Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis持久化-宕机了如何避免数据丢失</h1><p>Reids实现高可用主要依靠以下几个方面的保障：</p><ul><li><code>数据持久化</code></li><li>主从复制</li><li>自动故障恢复</li><li>集群化</li></ul><p>Redis是一个内存数据库，它的数据都保存在内存中，如果实例宕机，那么数据则全部丢失。如何保证数据的完整性和安全性也是提高服务高可用的重要机制之一。</p><p>持久化机制是保证高可用的基础。因为Redis的主从复制和自动故障恢复，都需要依赖Redis持久化相关的东西。同时，Redis的数据持久化也可以用来做数据备份，用来保障数据的安全性。</p><p>Redis提供了完善的持久化机制，可以把内存中的数据持久化到磁盘上，方便我们进行备份数据和快速恢复数据。</p><p>目前，Redis 的持久化主要有两大机制，即 <strong>AOF（<code>Append Only File</code>）日志和 RDB（<code>Redis DataBase</code>） 快照</strong>。</p><h2 id="AOF">AOF</h2><h3 id="日志是如何实现的">日志是如何实现的</h3><p>说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF 日志正好相反，它是写后日志，” 写后” 的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。</p><p>AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p><p>我们以 Redis 收到 “set testkey testvalue” 命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3” 表示当前命令有三个部分，每部分都是由 “$+ 数字” 开头，后面紧跟着具体的命令、键或值。这里，“数字” 表示这部分中的命令、键或值一共有多少字节。例如，$3 set 表示这部分有 3 个字节，也就是 set 命令。</p><h3 id="写后日志的优势与风险">写后日志的优势与风险</h3><p><strong>为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。</strong></p><p>如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。</p><p>所以，Redis 使用写后日志这一方式的一大好处是，<strong>可以避免出现记录错误命令的情况</strong>。</p><p>除此之外，写后日志一个好处：它是在命令执行后才记录日志，<strong>不会阻塞当前的写操作</strong>。</p><h4 id="AOF-也有两个潜在的风险：">AOF 也有两个潜在的风险：</h4><ul><li><p>风险一：如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</p><ul><li><p>如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复。</p></li><li><p>如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p></li></ul></li><li><p>风险二：AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。</p><ul><li>AOF 日志也是在主线程中执行 (写回策略为 always 时)，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li></ul></li></ul><p>这两个风险都是和 <strong>AOF 写回磁盘</strong>的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p><h3 id="日志的写回策略">日志的写回策略</h3><p>AOF 机制一共有三种写回策略，也就是 AOF 配置项<code>appendfsync</code>的三个可选值。</p><ul><li><code>Always 同步写回</code>：每个写命令执行完，立马同步地将日志写回磁盘；</li><li><code>Everysec 每秒写回</code>：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li><code>No 操作系统控制的写回</code>：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。<br>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。</li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151055633.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><p>我们就可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。</p><p>想要获得高性能，就选择 No 策略；<br>想要得到高可靠性保证，就选择 Always 策略；<br>允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。</p><h3 id="日志的重写">日志的重写</h3><h4 id="重写的作用">重写的作用</h4><p>AOF 是以文件的形式在记录接收到的所有写命令。<strong>随着接收的写命令越来越多，AOF 文件会越来越大</strong>。这也就意味着，我们一定要小心 AOF 文件过大带来的性能问题，主要在于以下三个方面：</p><ul><li>一是，文件系统本身对文件大小有限制，无法保存过大的文件；</li><li>二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li><li>三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</li></ul><p>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，<strong>读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入</strong>。重写机制具有 “多变一” 功能。所谓的 “多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151056923.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><h4 id="重写的过程">重写的过程</h4><p>AOF 日志由主线程写回不同，重写过程是由<strong>后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程</strong>，导致数据库性能下降。</p><p>我把重写的过程总结为 “<strong>一个拷贝，两处日志</strong>”。</p><p>“一个拷贝” 就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>第一处日志，指的是因为主线程未阻塞，仍然可以处理新来的操作，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p><p>第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。</p><p>此时，我们就可以用新的 AOF 文件替代旧文件了。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151057241.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><p>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，<strong>因为 Redis 采用子进程进行日志重写，所以，这个过程并不会阻塞主线程</strong>。</p><p>正因为记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。这当然不是理想的结果。那么，还有没有既可以保证可靠性，还能在宕机时实现快速恢复的其他方法呢？</p><h2 id="RDB">RDB</h2><p>对 Redis 来说，它实现类似照片记录效果的方式，把某一时刻的状态以文件的形式写到磁盘上，也就是快照（RDB 文件）。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。</p><p>和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。</p><h3 id="快照的原理">快照的原理</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li><code>save</code>：在主线程中执行，会导致阻塞；</li><li><code>bgsave</code>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><p>我们可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。<br>在执行快照的同时，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），正常处理写操作。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p><p>如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151059013.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><p>这样既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p><h2 id="混合-AOF-RDB">混合 AOF/RDB</h2><p>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。</p><p>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）。</p><p>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越大，阻塞时间越长。</p><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，<strong>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作</strong>。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151100983.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><h2 id="总结">总结</h2><p>最后，关于 AOF 和 RDB 的选择问题，这里有三点建议：</p><ul><li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li><li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li><li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li></ul><h2 id="相关链接">相关链接</h2><ul><li><a href="https://learnku.com/articles/86491">宕机了，Redis 如何避免数据丢失？ | 程序员论坛 (learnku.com)</a></li><li><a href="https://blog.csdn.net/shangyuanlang/article/details/81297970">Redis数据&quot;丢失&quot;讨论及规避和解决的几点总结_redis是不是完全可靠,有没有数据丢失的时候,举例-CSDN博客</a></li><li><a href="https://cloud.tencent.com/developer/article/1730906">Redis 怎么防止数据丢失？面试必问！-腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul>]]></content>
    
    
    <summary type="html">一旦服务器宕机，内存中的数据将全部丢失。如何避免在宕机后数据无法恢复是选择使用Redis需要考虑的问题。</summary>
    
    
    
    <category term="Java" scheme="https://www.sadalsuud.cn/categories/Java/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
    <category term="Data Loss" scheme="https://www.sadalsuud.cn/tags/Data-Loss/"/>
    
  </entry>
  
  <entry>
    <title>Redis怎么预防数据丢失问题</title>
    <link href="https://www.sadalsuud.cn/posts/2b4fa0b2.html"/>
    <id>https://www.sadalsuud.cn/posts/2b4fa0b2.html</id>
    <published>2024-06-15T02:25:30.000Z</published>
    <updated>2024-06-15T03:46:27.045Z</updated>
    
    <content type="html"><![CDATA[<h1>Redis怎么预防数据丢失问题</h1><p>在使用Redis时，数据丢失可能会因为多种原因发生。以下是常见的导致数据丢失的问题及其对应的解决方案：</p><h2 id="1-内存溢出导致的数据丢失">1. 内存溢出导致的数据丢失</h2><p><strong>问题</strong>：</p><ul><li>Redis是基于内存的数据库，数据全部存储在内存中。当数据量超过内存容量时，可能会导致内存溢出，系统崩溃，数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>内存限制</p><p>：设置Redis的内存使用限制，防止内存溢出。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shell</span></span><br><span class="line">复制代码</span><br><span class="line">maxmemory &lt;<span class="keyword">bytes</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>内存淘汰策略</p><p>：配置适当的内存淘汰策略，在内存使用达到限制时删除旧数据。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br><span class="line">复制代码</span><br><span class="line">maxmemory-<span class="keyword">policy</span> noeviction  <span class="comment"># 或者 allkeys-lru, volatile-lru 等策略</span></span><br></pre></td></tr></table></figure></li><li><p><strong>水平扩展</strong>：使用Redis Cluster，通过分片技术将数据分布在多个节点上，减少单节点的内存压力。</p></li></ul><h2 id="2-持久化故障">2. 持久化故障</h2><p><strong>问题</strong>：</p><ul><li>RDB或AOF文件损坏、保存不及时或者配置不当可能导致数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>定期持久化</p><p>配置RDB和AOF的持久化策略，确保数据定期保存到磁盘中。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">shell</span>复制代码# RDB配置</span><br><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF配置</span></span><br><span class="line"><span class="attribute">appendonly</span> yes</span><br><span class="line"><span class="attribute">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="attribute">appendfsync</span> everysec  # 每秒同步一次</span><br></pre></td></tr></table></figure></li><li><p>混合持久化</p><p>启用RDB和AOF混合持久化，结合两者的优点，提高数据安全性。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shell</span></span><br><span class="line">复制代码</span><br><span class="line">aof-<span class="keyword">use</span>-rdb-preamble yes</span><br></pre></td></tr></table></figure></li><li><p><strong>定期备份</strong>：定期备份RDB和AOF文件，防止文件损坏时的数据丢失。</p></li></ul><h2 id="3-主从复制延迟或故障">3. 主从复制延迟或故障</h2><p><strong>问题</strong>：</p><ul><li>主从复制过程中，如果从节点未能及时同步主节点数据，或者主从节点切换不及时，可能导致数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>优化复制延迟</p><p>：确保网络和硬件环境的稳定性，优化复制延迟。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span></span><br><span class="line"><span class="keyword"></span>复制代码</span><br><span class="line">repl-<span class="keyword">backlog-size </span>&lt;<span class="keyword">bytes&gt; </span> <span class="comment"># 增加复制积压缓冲区大小</span></span><br></pre></td></tr></table></figure></li><li><p>配置哨兵机制</p><p>：使用哨兵机制监控主从节点状态，自动进行主从切换，确保高可用性。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码sentinel<span class="built_in"> monitor </span>mymaster &lt;master-ip&gt; &lt;master-port&gt; 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-磁盘故障">4. 磁盘故障</h2><p><strong>问题</strong>：</p><ul><li>磁盘损坏或磁盘I/O异常会导致持久化文件（RDB、AOF）丢失或损坏。</li></ul><p><strong>解决方案</strong>：</p><ul><li><strong>使用可靠的硬件</strong>：选择高可靠性的磁盘设备。</li><li><strong>RAID阵列</strong>：使用RAID阵列提升磁盘的可靠性和性能。</li><li><strong>定期备份</strong>：将持久化文件定期备份到其他存储设备或云存储上。</li></ul><h2 id="5-人为错误">5. 人为错误</h2><p><strong>问题</strong>：</p><ul><li>错误的命令操作（如FLUSHALL、FLUSHDB）或误操作可能导致数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>权限控制</p><p>：通过设置密码和用户权限，限制高风险命令的执行。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span></span><br><span class="line">复制代码</span><br><span class="line">requirepass <span class="symbol">&lt;password&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>多级确认</strong>：对于高风险操作，设置多级确认机制，防止误操作。</p></li></ul><h2 id="6-意外重启或崩溃">6. 意外重启或崩溃</h2><p><strong>问题</strong>：</p><ul><li>Redis实例意外重启或崩溃，未及时持久化的数据可能会丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>设置持久化策略</p><p>：确保持久化配置合理，尽量减少数据丢失的时间窗口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">复制代码</span></span><br><span class="line">appendfsync always  <span class="comment"># 每次写操作都进行同步</span></span><br></pre></td></tr></table></figure></li><li><p><strong>快速重启</strong>：优化Redis的启动和恢复流程，尽量减少重启后的数据恢复时间。</p></li></ul><h2 id="总结">总结</h2><p>为防止Redis数据丢失，需采取综合措施，包括合理配置持久化策略、优化主从复制、定期备份数据、使用可靠的硬件和存储设备、加强权限控制及误操作防护等。这些措施可以显著提升Redis系统的可靠性和数据安全性。</p>]]></content>
    
    
    <summary type="html">本文Redis会发生的数据丢失问题怎么以预防的解决思路</summary>
    
    
    
    <category term="Java" scheme="https://www.sadalsuud.cn/categories/Java/"/>
    
    
    <category term="Redis" scheme="https://www.sadalsuud.cn/tags/Redis/"/>
    
    <category term="Data Loss" scheme="https://www.sadalsuud.cn/tags/Data-Loss/"/>
    
  </entry>
  
  <entry>
    <title>HashedWheelTimer算法（定时任务）</title>
    <link href="https://www.sadalsuud.cn/posts/33980cf3.html"/>
    <id>https://www.sadalsuud.cn/posts/33980cf3.html</id>
    <published>2024-06-15T01:59:05.000Z</published>
    <updated>2024-06-15T03:46:27.043Z</updated>
    
    <content type="html"><![CDATA[<h1>HashedWheelTimer算法理解</h1><h2 id="序">序</h2><p>George Varghese 和 Tony Lauck 1996 年的论文：<a href="https://link.segmentfault.com/?enc=8Wp%2F27rHZt4fLrTAPAiB8w%3D%3D.2h2jPX7bqrabxLNbRoJq31JEIatYam7wPTcg866E1DwI7YOdmiuelp7MaTfZ8A8w9yk8w9RrXneF%2FVcvGjH9iA%3D%3D">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a>提出了一种定时轮的方式来管理和维护大量的Timer调度算法.Linux 内核中的定时器采用的就是这个方案。而Redisson的实现中会调用<code>scheduleExpirationRenewal</code>方法创建一个定时任务来刷新锁的过期时间，防止任务执行完毕前锁就过期释放了，其中使用的定时任务就是<code>Netty</code>提供的<code>HashedWheelTimer</code>。</p><h2 id="定时任务的本质">定时任务的本质</h2><p>一个Timer本质上是这样的一个数据结构：deadline越近的任务拥有越高优先级，提供以下3中基本操作：</p><ol><li><code>schedule</code>新增</li><li><code>cancel</code>删除</li><li><code>expire</code>执行到期的任务</li><li><code>updateDeadline</code>更行到期时间（可选）</li></ol><p><code>expire</code>通常有两种工作方式：</p><ol><li><p>轮询</p><p>每隔一个时间片就去查找哪些任务已经到期</p></li><li><p>睡眠/唤醒</p><ol><li>不停地查找deadline最近的任务，如到期则执行；否则sleep直到其到期</li><li>在sleep期间，如果有任务被<code>cancel</code>或<code>schedule</code>，则deadline最近的任务有可能改变，线程会被唤醒并重新进行1的逻辑</li></ol></li></ol><p>具体实现的数据结构可以有很多选择：（假设任务持有自己在总体任务集合中对应的节点，<code>cancel</code>时不需要查找的过程）</p><ol><li>有序链表<ul><li><code>schedule</code>：O(n)</li><li><code>cancel</code>：O(1) //双向链表的节点删除</li><li><code>expire</code>：O(1) //不停地查看第一个就可以了</li></ul></li><li>堆heap<ul><li><code>schedule</code>：O(log2N) //调整heap</li><li><code>cancel</code>：O(log2N) //调整heap</li><li><code>expire</code>：O(1)</li></ul></li></ol><h2 id="原理">原理</h2><p>一个Hash Wheel Timer是一个环形结构，可以想象成时钟，分为很多格子，一个格子代表一段时间（越短Timer精度越高），并用一个List保存在该格子上到期的所有任务，同时一个指针随着时间流逝一格一格转动，并执行对应List中所有到期的任务。任务通过取模决定应该放入哪个格子。</p><p>环形结构可以根据超时时间的 hash 值(这个 hash 值实际上就是ticks &amp; mask)将 task 分布到不同的槽位中, 当 tick 到那个槽位时, 只需要遍历那个槽位的 task 即可知道哪些任务会超时(而使用线性结构, 你每次 tick 都需要遍历所有 task), 所以, 我们任务量大的时候, 相应的增加 wheel 的 ticksPerWheel 值, 可以减少 tick 时遍历任务的个数.</p><h3 id="结构图">结构图</h3><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151008709.webp" alt="img"></p><p>以上图为例，假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。</p><h3 id="效率">效率</h3><ul><li>添加任务：O(1)</li><li>删除/取消任务：O(1)</li><li>过期/执行任务：最差情况为O(n)-&gt;也就是当HashMap里面的元素全部hash冲突，退化为一条链表的情况。平均O(1)</li></ul><p>槽位越多，每个槽位上的链表就越短，这里需要权衡时间与空间。</p><h2 id="netty3-10的实现">netty3.10的实现</h2><h3 id="相关参数">相关参数</h3><ul><li>tickDuration: 每 tick 一次的时间间隔, 每 tick 一次就会到达下一个槽位</li><li>ticksPerWheel: 轮中的 slot 数，hash算法计算目标槽位</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new timer with the default thread factory</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@link</span> Executors#defaultThreadFactory()&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tickDuration   the duration between tick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit           the time unit of the &#123;<span class="doctag">@code</span> tickDuration&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticksPerWheel  the size of the wheel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashedWheelBucket定义">HashedWheelBucket定义</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy</span></span><br><span class="line"><span class="comment">     * removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no</span></span><br><span class="line"><span class="comment">     * extra object creation is needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">class</span> <span class="title">HashedWheelBucket</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Used for the linked-list datastructure</span></span><br><span class="line">        <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">        <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;@link HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span>(<span class="params">HashedWheelTimeout timeout</span>)</span> &#123;</span><br><span class="line">            assert timeout.bucket == <span class="literal">null</span>;</span><br><span class="line">            timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                head = tail = timeout;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = timeout;</span><br><span class="line">                timeout.prev = tail;</span><br><span class="line">                tail = timeout;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Expire all &#123;@link HashedWheelTimeout&#125;s for the given &#123;@code deadline&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span>(<span class="params"><span class="built_in">long</span> deadline</span>)</span> &#123;</span><br><span class="line">            HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// process all timeouts</span></span><br><span class="line">            <span class="keyword">while</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">                boolean <span class="keyword">remove</span> = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                        timeout.expire();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                                <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">remove</span> = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">remove</span> = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    timeout.remainingRounds --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// store reference to next as we may null out timeout.next in the remove block.</span></span><br><span class="line">                HashedWheelTimeout next = timeout.next;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">remove</span>) &#123;</span><br><span class="line">                    <span class="keyword">remove</span>(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">                timeout = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params">HashedWheelTimeout timeout</span>)</span> &#123;</span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line">            <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                timeout.prev.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timeout.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                timeout.next.prev = timeout.prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">                <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">                <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                    tail = <span class="literal">null</span>;</span><br><span class="line">                    head = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    head = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">                tail = timeout.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">            timeout.prev = <span class="literal">null</span>;</span><br><span class="line">            timeout.next = <span class="literal">null</span>;</span><br><span class="line">            timeout.bucket = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Clear this bucket and return all not expired / cancelled &#123;@link Timeout&#125;s.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearTimeouts</span>(<span class="params">Set&lt;Timeout&gt; <span class="keyword">set</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = pollTimeout();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (timeout.isExpired() || timeout.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> HashedWheelTimeout <span class="title">pollTimeout</span>()</span> &#123;</span><br><span class="line">            HashedWheelTimeout head = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HashedWheelTimeout next = head.next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = <span class="keyword">this</span>.head =  <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.head = next;</span><br><span class="line">                next.prev = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// null out prev and next to allow for GC.</span></span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            head.prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>HashedWheelTimeout</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashedWheelTimeout <span class="keyword">implements</span> Timeout &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_IN_BUCKET = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.<span class="keyword">class</span>, <span class="string">&quot;state&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TimerTask <span class="keyword">task</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;<span class="string">&quot;unused&quot;</span>, <span class="string">&quot;FieldMayBeFinal&quot;</span>, <span class="string">&quot;RedundantFieldInitialization&quot;</span> &#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remainingRounds will be calculated and set by Worker.transferTimeoutsToBuckets() before the</span></span><br><span class="line">        <span class="comment">// HashedWheelTimeout will be added to the correct HashedWheelBucket.</span></span><br><span class="line">        <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This will be used to chain timeouts in HashedWheelTimerBucket via a double-linked-list.</span></span><br><span class="line">        <span class="comment">// As only the workerThread will act on it there is no need for synchronization / volatile.</span></span><br><span class="line">        HashedWheelTimeout <span class="keyword">next</span>;</span><br><span class="line">        HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The bucket to which the timeout was added</span></span><br><span class="line">        HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask <span class="keyword">task</span>, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timer = timer;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">task</span> = <span class="keyword">task</span>;</span><br><span class="line">            <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Timer getTimer() &#123;</span><br><span class="line">            <span class="keyword">return</span> timer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TimerTask getTask() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">task</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> cancel() &#123;</span><br><span class="line">            <span class="keyword">int</span> state = state();</span><br><span class="line">            <span class="keyword">if</span> (state &gt;= ST_CANCELLED) &#123;</span><br><span class="line">                <span class="comment">// fail fast if the task was cancelled or expired before.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state != ST_IN_BUCKET &amp;&amp; compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">                <span class="comment">// Was cancelled before the HashedWheelTimeout was added to its HashedWheelBucket.</span></span><br><span class="line">                <span class="comment">// In this case we can just return here as it will be discarded by the WorkerThread when handling</span></span><br><span class="line">                <span class="comment">// the adding of HashedWheelTimeout to the HashedWheelBuckets.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_IN_BUCKET, ST_CANCELLED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Add the HashedWheelTimeout back to the timeouts queue so it will be picked up on the next tick</span></span><br><span class="line">            <span class="comment">// and remove this HashedTimeTask from the HashedWheelBucket. After this is done it is ready to get</span></span><br><span class="line">            <span class="comment">// GC&#x27;ed once the user has no reference to it anymore.</span></span><br><span class="line">            timer.timeouts.add(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> remove() &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> compareAndSetState(<span class="keyword">int</span> expected, <span class="keyword">int</span> state) &#123;</span><br><span class="line">            <span class="keyword">return</span> STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, expected, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> state() &#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isCancelled() &#123;</span><br><span class="line">            <span class="keyword">return</span> state == ST_CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isExpired() &#123;</span><br><span class="line">            <span class="keyword">return</span> state &gt; ST_IN_BUCKET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HashedWheelTimeout value() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> expire() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_IN_BUCKET, ST_EXPIRED)) &#123;</span><br><span class="line">                assert state() != ST_INIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">task</span>.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;An exception was thrown by &quot;</span> + TimerTask.<span class="keyword">class</span>.getSimpleName() + <span class="string">&#x27;.&#x27;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> remaining = deadline - currentTime + timer.startTime;</span><br><span class="line"></span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">192</span>);</span><br><span class="line">            buf.<span class="keyword">append</span>(getClass().getSimpleName());</span><br><span class="line">            buf.<span class="keyword">append</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            buf.<span class="keyword">append</span>(<span class="string">&quot;deadline: &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(remaining);</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot; ns later&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(-remaining);</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot; ns ago&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot;now&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot;, cancelled&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf.<span class="keyword">append</span>(<span class="string">&quot;, task: &quot;</span>);</span><br><span class="line">            buf.<span class="keyword">append</span>(getTask());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> buf.<span class="keyword">append</span>(<span class="string">&#x27;)&#x27;</span>).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashedWheelBucket创建">HashedWheelBucket创建</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] <span class="title">createWheel</span>(<span class="params"><span class="built_in">int</span> ticksPerWheel</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;ticksPerWheel must be greater than 0: &quot;</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;ticksPerWheel may not be greater than 2^30: &quot;</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line">        HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">normalizeTicksPerWheel</span>(<span class="params"><span class="built_in">int</span> ticksPerWheel</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">            normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="timeouts队列">timeouts队列</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Queue&lt;HashedWheelTimeout&gt; timeouts = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;HashedWheelTimeout&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">public Timeout <span class="keyword">new</span><span class="constructor">Timeout(TimerTask <span class="params">task</span>, <span class="params">long</span> <span class="params">delay</span>, TimeUnit <span class="params">unit</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task<span class="operator"> == </span>null) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">NullPointerException(<span class="string">&quot;task&quot;</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unit</span><span class="operator"> == </span>null) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">NullPointerException(<span class="string">&quot;unit&quot;</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></span><br><span class="line">        <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></span><br><span class="line">        long deadline = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>nano<span class="constructor">Time()</span> + <span class="built_in">unit</span>.<span class="keyword">to</span><span class="constructor">Nanos(<span class="params">delay</span>)</span> - startTime;</span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> <span class="constructor">HashedWheelTimeout(<span class="params">this</span>, <span class="params">task</span>, <span class="params">deadline</span>)</span>;</span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line">        return timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Worker">Worker</h3><p>HashedWheelTimer的核心，主要处理tick的转动、过期任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> tick;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// Initialize the startTime.</span></span><br><span class="line">            startTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span></span><br><span class="line">                startTime = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify the other threads waiting for the initialization at start().</span></span><br><span class="line">            startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> waitForNextTick();</span><br><span class="line">                <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    transferTimeoutsToBuckets();</span><br><span class="line">                    <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span></span><br><span class="line">                            wheel[(<span class="type">int</span>) (tick &amp; mask)];</span><br><span class="line">                    bucket.expireTimeouts(deadline);</span><br><span class="line">                    tick++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span></span><br><span class="line">            <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">                bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                unprocessedTimeouts.add(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferTimeoutsToBuckets</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span></span><br><span class="line">            <span class="comment">// adds new timeouts in a loop.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED</span><br><span class="line">                        || !timeout.compareAndSetState(HashedWheelTimeout.ST_INIT, HashedWheelTimeout.ST_IN_BUCKET)) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled in the meantime. So just remove it and continue with next HashedWheelTimeout</span></span><br><span class="line">                    <span class="comment">// in the queue</span></span><br><span class="line">                    timeout.remove();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">calculated</span> <span class="operator">=</span> timeout.deadline / tickDuration;</span><br><span class="line">                <span class="type">long</span> <span class="variable">remainingRounds</span> <span class="operator">=</span> (calculated - tick) / wheel.length;</span><br><span class="line">                timeout.remainingRounds = remainingRounds;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">stopIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">                <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[stopIndex];</span><br><span class="line">                bucket.addTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * calculate goal nanoTime from startTime and current tick number,</span></span><br><span class="line"><span class="comment">         * then wait until that goal has been reached.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> Long.MIN_VALUE if received a shutdown request,</span></span><br><span class="line"><span class="comment">         * current time otherwise (with Long.MIN_VALUE changed by +1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">waitForNextTick</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.nanoTime() - startTime;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sleepTimeMs</span> <span class="operator">=</span> (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> currentTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">                <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">                <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">                <span class="keyword">if</span> (DetectionUtil.isWindows()) &#123;</span><br><span class="line">                    sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleepTimeMs);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title function_">unprocessedTimeouts</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.unmodifiableSet(unprocessedTimeouts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>定位槽位</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashedWheelBucket[] wheel = createWheel(ticksPerWheel);</span><br><span class="line">mask = wheel.<span class="built_in">length</span> - <span class="number">1</span>;</span><br><span class="line">HashedWheelBucket bucket = wheel[(<span class="type">int</span>) (tick &amp; mask)];</span><br></pre></td></tr></table></figure><p>比如有16个槽，则mask为15，假设当前tick=30，则槽位=14</p><ul><li>更新该槽位任务的remainingRounds<br>每走一个tick都要更新该tick对应的槽位下面的任务的remainingRounds或者执行到期的任务</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bucket.<span class="built_in">expireTimeouts</span>(deadline);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="type">long</span> deadline)</span> </span>&#123;</span><br><span class="line">            HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// process all timeouts</span></span><br><span class="line">            <span class="keyword">while</span> (timeout != null) &#123;</span><br><span class="line">                <span class="type">boolean</span> remove = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                        timeout.<span class="built_in">expire</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalStateException</span>(<span class="type">String</span>.format(</span><br><span class="line">                                <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">                    &#125;</span><br><span class="line">                    remove = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.<span class="built_in">isCancelled</span>()) &#123;</span><br><span class="line">                    remove = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    timeout.remainingRounds --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// store reference to next as we may null out timeout.next in the remove block.</span></span><br><span class="line">                HashedWheelTimeout next = timeout.next;</span><br><span class="line">                <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">                    <span class="built_in">remove</span>(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">                timeout = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行到期任务</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_IN_BUCKET, ST_EXPIRED)) &#123;</span><br><span class="line">                <span class="function">assert <span class="title">state</span>() !</span>= ST_INIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;An exception was thrown by &quot;</span> + TimerTask.<span class="keyword">class</span>.getSimpleName() + <span class="string">&#x27;.&#x27;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里是同步执行，会阻塞整个timer的，需要异步。</p></blockquote><ul><li>transfer<br>每走一个tick的时候，要把task从queue中取出来，放到槽位。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">calculated</span> <span class="operator">=</span> timeout.deadline / tickDuration;</span><br><span class="line"><span class="type">long</span> <span class="variable">remainingRounds</span> <span class="operator">=</span> (calculated - tick) / wheel.length;</span><br><span class="line">timeout.remainingRounds = remainingRounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">stopIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line"><span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[stopIndex];</span><br><span class="line">bucket.addTimeout(timeout);</span><br></pre></td></tr></table></figure><h2 id="使用实例">使用实例</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ﻿tickDuration: 每 tick 一次的时间间隔, 每 tick 一次就会到达下一个槽位</span></span><br><span class="line"><span class="comment">     * ticksPerWheel: 轮中的 slot 数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Test</span><br><span class="line">    public <span class="literal">void</span> testHashedWheelTimer() throws InterruptedException &#123;</span><br><span class="line">        HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">1000</span>/**tickDuration**<span class="regexp">/, TimeUnit.MILLISECONDS, 16 /</span>**ticksPerWheel**/);</span><br><span class="line">        System.out.println(LocalTime.now()+<span class="string">&quot; submitted&quot;</span>);</span><br><span class="line">        Timeout timeout = hashedWheelTimer.newTimeout<span class="function"><span class="params">((t) -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> Thread()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                @Override</span></span></span><br><span class="line"><span class="params"><span class="function">                public <span class="literal">void</span> run() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; executed&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(hashedWheelTimer);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        e.printStackTrace();</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; FINISH&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;.start();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">5</span>, TimeUnit.SECONDS)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">hashedWheelTimer</span>.<span class="title">newTimeout</span><span class="params">((t) -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> Thread()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                @Override</span></span></span><br><span class="line"><span class="params"><span class="function">                public <span class="literal">void</span> run() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; TASK2 executed&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(hashedWheelTimer);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        e.printStackTrace();</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; TASK2 FINISH&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;.start();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">15</span>, TimeUnit.SECONDS)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">TimeUnit</span>.<span class="title">SECONDS</span>.<span class="title">sleep</span><span class="params">(<span class="number">500</span>)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总体来说，<code>HashedWheelTimer</code>使用的是一个比较朴素的算法，要点有两个：</p><ol><li>添加定时任务<ol><li>如果worker线程没有执行则启动worker线程。</li><li>将定时任务task包装成<code>HashedWheelTimeout</code>，然后添加到<code>Queue&lt;HashedWheelTimeout&gt; timeouts</code>队列中</li></ol></li><li>worker线程的执行<ol><li>调用<code>waitForNextTick</code>方法等待直到下一个tick</li><li>调用<code>processCancelledTasks</code>方法处理被取消的任务。从<code>Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts</code>队列（调用<code>cancel</code>方法取消任务时会将任务添加到该队列中）中取出被取消的任务，然后将其从格子的任务列表中移除。</li><li>计算当前tick所在的格子(<code>bucket</code>)</li><li>调用<code>transferTimeoutsToBuckets</code>方法将<code>timeouts</code>队列中新建的任务转移到所在格子的链表中</li><li>调用<code>HashedWheelBucket.expireTimeouts</code>方法执行到期的任务</li></ol></li></ol><p>这里有几个值的注意的数据结构：</p><ol><li>任务并不是直接放在格子中的，而是维护了一个双向链表，这种数据结构非常便于插入和移除。</li><li>新添加的任务并不直接放入格子，而是先放入一个队列中，这是为了避免多线程插入任务的冲突。在每个tick运行任务之前由worker线程自动对任务进行归集和分类，插入到对应的槽位里面。</li></ol><h2 id="相关链接">相关链接</h2><ul><li><p><a href="https://segmentfault.com/a/1190000010987765">java - HashedWheelTimer算法详解 - code-craft - SegmentFault 思否</a></p></li><li><p><a href="https://www.jianshu.com/p/311121f63d2f">定时任务之HashedWheelTimer - 简书 (jianshu.com)</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=Pq6wjH2PESfGLwNHQQelfw%3D%3D.m8IC%2FP5vjKLcBahNq9RhvVyOJAPO3bphJnUquigqpnrPKJOO7AUNoajKxlafdiq8OkJRRa%2FMx2ZmhaqprqvdKg%3D%3D">netty源码解读之时间轮算法实现-HashedWheelTimer</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=fD0IP2%2FHJvizRlOA8TgiJg%3D%3D.so9cbh%2F7kM2Z1iHwihShg%2BpYWIHL4gphfBCooz7J3ZJv2fwsI1viBVTMul4JsSIqo6vhdBikwfnAy%2BES1oM%2FMw%3D%3D">Timing Wheel 定时轮算法</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=W8Y7X0ev5Zw33j1bsTaB%2Fg%3D%3D.rxWVnie7pUbekY7su9DAjuOqYWNdOLRMfXyt01la5xCIfoefR05CROMvsFwUMUu1">细说延时任务的处理</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=Ol10zvO6HwKiW2y52%2Fa2Hg%3D%3D.Mgne%2BR4AAEkxvM1%2F0ikzDGnZzFHspdSzTs0B3ovIMOr%2FZS5q9UJCGNA9pN7EPMZ3">ifesdjeen-hashed-wheel-timer</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=iKGLRLH4LaJ%2BibMO9Ubs%2Bw%3D%3D.vVuY4FUZFOrNe92Hg8DFm5ohhFX1ncASKc0L8sRqwc9RZtzvCb%2BJ2sVukNp3jD8Z8jw0vGlMyJyjkuXeKlWNX7puOfjhaLIVk4nSjcd1X1c%3D">TimingWheels.ppt</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=0%2F%2BPCfysbe4AB5Dof9DO7g%3D%3D.6pgxgj9%2B6uw34IrMmMUSMQklE07sZvt%2F3ZitJmMBNWiHKQUESeaMj5F8uY7Xjy6xgc0nhMkWU8yQIlWi6kdj%2FN4TU%2BY09n3QjiZtJZ2224H%2BTe3oogiKQG%2FFa%2BwB1MM49PFrZZmFQP8UE64azYsbsnbppQRDUSfFE7DxmOPUp3WchD%2BdgN4c8EevZI5%2BA3%2FD">定时器（Timer）的实现</a></p></li></ul><h2 id="QA">QA</h2><ul><li>Dubbo在2.7x中也实现了HashedWheelTimer，为什么不直接使用netty的实现</li></ul><p>​Dubbo在2.7.x版本中实现了自己的<code>HashedWheelTimer</code>，而没有直接使用Netty的实现，主要是为了满足特定的定制化需求，减少对外部依赖的管理，优化性能，确保控制权和可维护性，以及保证在不同环境中的一致性和兼容性。这使得Dubbo能够更好地适应其分布式服务框架的要求。</p>]]></content>
    
    
    <summary type="html">HashedWheelTimer算法详解</summary>
    
    
    
    <category term="Java" scheme="https://www.sadalsuud.cn/categories/Java/"/>
    
    
    <category term="Netty" scheme="https://www.sadalsuud.cn/tags/Netty/"/>
    
    <category term="Redisson" scheme="https://www.sadalsuud.cn/tags/Redisson/"/>
    
    <category term="WatchDog" scheme="https://www.sadalsuud.cn/tags/WatchDog/"/>
    
  </entry>
  
  <entry>
    <title>Redisson-看门狗（WatchDog）</title>
    <link href="https://www.sadalsuud.cn/posts/6f94974c.html"/>
    <id>https://www.sadalsuud.cn/posts/6f94974c.html</id>
    <published>2024-06-15T01:54:54.000Z</published>
    <updated>2024-06-15T03:46:27.044Z</updated>
    
    <content type="html"><![CDATA[<h1>Redisson-看门狗（WatchDog）</h1><h2 id="前言">前言</h2><p>说起 Redisson，比较耳熟能详的就是这个看门狗（Watchdog）机制。</p><p>本文就一起看看加锁成功之后的看门狗（Watchdog）是如何实现的？</p><h2 id="加锁成功">加锁成功</h2><p>在前一篇文章中介绍了可重入锁加锁的逻辑，其中 <code>RedissonLock#tryAcquireAsync</code> 方法是进行异步加锁的逻辑。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956499.png" alt="img"></p><p>回顾一下这个方法的入参：</p><ol><li>waitTime：-1；</li><li>leaseTime：-1，加锁时未指定锁时间，则为 -1，如果指定，则是指定的时间；</li><li>unit：null；</li><li>threadId：当前线程 id。</li></ol><p>其中的 <code>tryLockInnerAsync</code> 在之前已经介绍过了。</p><p>当加锁成功时，会返回 null，加锁失败，会返回当前锁的剩余时间。</p><p>所以这块会进入到红框标记的部分。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956354.png" alt="img"></p><p>leaseTime 为加锁时间，默认不指定，所以会进入到 <code>scheduleExpirationRenewal</code> 方法，也就是今天的主题：看门狗。</p><p>至此可以得出一个结论：</p><p><strong>Redisson 看门狗（Watchdog）在指定加锁时间时，是不会对锁时间自动续租的。</strong></p><h2 id="看门狗">看门狗</h2><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956795.png" alt="img"></p><p>看门狗的一部分重点逻辑就在 <code>renewExpiration</code> 方法这里：</p><ol><li>延迟调度，延迟时间为：<code>internalLockLeaseTime / 3</code>，就是 10s 左右后会调度这个 TimerTask；</li><li>异步续租：逻辑都在 renewExpirationAsync 里面；</li><li>递归调用：当续租成功之后，重新调用 <code>renewExpiration</code> 自己，从而达到持续续租的目的；</li><li>当然也不能一直无限续租，所以中间有一些判断逻辑，就是用来中断续租的。</li></ol><h3 id="续租逻辑">续租逻辑</h3><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956618.png" alt="img"></p><p>这块也是一个 lua 脚本，就是将之前的 redis key 直接重新设置时间。</p><p>这样一通续租下来，就是<strong>在过了 10s 左右将锁的时间重新设置为 30s</strong>。</p><h2 id="总结">总结</h2><p>至此，看门狗介绍完毕，简要总结一下内容。</p><ol><li>只有在未指定锁超时时间时才会使用看门狗；</li><li>看门狗默认续租时间是 10s 左右，<code>internalLockLeaseTime / 3</code>；</li><li>可以通过 Config 统一设置看门狗的时间，设置 <code>lockWatchdogTimeout</code> 参数即可。</li></ol><p>最后，同样使用一张图，进行下总结：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956440.png" alt="img"></p><h2 id="相关链接">相关链接</h2><ul><li><a href="https://segmentfault.com/a/1190000040283488">java - Redisson 分布式锁源码 02：看门狗 - 小航的技术笔记 - SegmentFault 思否</a></li><li><a href="https://blog.csdn.net/Lin_xiaofeng/article/details/126054407">java使用看门狗原理实现监听业务_java 看门狗-CSDN博客</a></li></ul>]]></content>
    
    
    <summary type="html">说起 Redisson，比较耳熟能详的就是这个看门狗（Watchdog）机制。本文就一起看看加锁成功之后的看门狗（Watchdog）是如何实现的？</summary>
    
    
    
    <category term="Java" scheme="https://www.sadalsuud.cn/categories/Java/"/>
    
    
    <category term="Redisson" scheme="https://www.sadalsuud.cn/tags/Redisson/"/>
    
    <category term="WatchDog" scheme="https://www.sadalsuud.cn/tags/WatchDog/"/>
    
  </entry>
  
  <entry>
    <title>Github API 调用 (v3）</title>
    <link href="https://www.sadalsuud.cn/posts/87a20176.html"/>
    <id>https://www.sadalsuud.cn/posts/87a20176.html</id>
    <published>2024-06-15T01:44:37.000Z</published>
    <updated>2024-06-15T03:46:27.038Z</updated>
    
    <content type="html"><![CDATA[<h1>Github API 调用 (v3）</h1><blockquote><p>对于常用Github的用户来说，经常有一些自动化的需求。比如我的需求是定时备份Github的issues和comments到本地。以下为Github的API的使用参考。<br><a href="https://docs.github.com/en/rest?apiVersion=2022-11-28">v3版API的文档链接</a><br><a href="https://docs.github.com/en/rest/quickstart?apiVersion=2022-11-28">V3版API的官方文档</a></p></blockquote><h2 id="基本访问路径-Root-Endpoints">基本访问路径 (Root Endpoints)</h2><p>一开始读文档的时候，照着它的事例直接在命令行里<code>curl</code>，或者在InSomnia或Postman软件里访问，都完美显示200状态。可是一旦把链接里改写成自己的用户名就各种显示404无页面。还以为是授权问题，然后在页头HEADER中按照各种方式试了username和token密钥，都没用还是404。结果发现，原来不是方法的问题，纯粹是链接地址没写对！<br><code>实际上只是读取的话，完全不用任何授权</code>，可以在命令行、Insomnia、网页等各种情况下直接输入链接访问任何人的所有公开信息。<br>然后对照<a href="https://link.segmentfault.com/?enc=0zhtwwh2hv9Fre9w5p3o1Q%3D%3D.mN2W8LfkWH7ijOCHxIQsOo%2Bdc6IEFRCfeseruhYZwg8%3D">官方路径列表Root Endpoints</a>得到的链接，好像怎么访问都不对。反而在Stackoverflow中看到的一个链接，顺藤摸瓜自己发现了各种正确的访问路径，总结如下：</p><ul><li>首先！访问的链接最后不能有<code>/</code>。如<code>https://api.github.com/users/solomonxie</code>是可以访问到我个人信息的，但是<code>https://api.github.com/users/solomonxie/</code>就不行了，唯一不同是多了一个<code>/</code>.</li><li>其次！不同于一般URL访问，GIthub的API访问链接是<code>区分大小写</code>的！</li><li>个人主要信息。 <code>https://api.github.com/users/用户名</code>,得到数据如下图：</li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951956.webp" alt="image"></p><ul><li>个人所有repo。<code>https://api.github.com/users/用户名/repos</code>。会得到一个repo的JSON格式列表。</li><li>repo详细信息。<code>https://api.github.com/repos/用户名/仓库名</code>。repo的路径就开始和个人信息不同了。</li><li>获取某个repo的内容列表。<code>https://api.github.com/repos/solomonxie/gists/contents</code>，注意这只会返回根目录的内容。</li><li>获取repo中子目录的内容列表。<code>https://api.github.com/repos/solomonxie/gists/contents/目录名</code>。一定要注意这里一定要完全遵循原文件名的大小写，否则无法获得信息。如果是更深层的内容，则在链接列按照顺序逐级写上目录名称。</li><li>获取repo中某文件信息（不包括内容）。<code>https://api.github.com/repos/solomonxie/gists/contents/文件路径</code>。文件路径是文件的完整路径，区分大小写。只会返回文件基本信息。</li><li>获取某文件的原始内容（Raw）。1. 通过上面的文件信息中提取<code>download_url</code>这条链接，就能获取它的原始内容了。2. 或者直接访问：<code>https://raw.githubusercontent.com/用户名/仓库名/分支名/文件路径</code></li><li>repo中所有的commits列表。<code>https://api.github.com/repos/用户名/仓库名/commits</code>。</li><li>某一条commit详情。<code>https://api.github.com/repos/用户名/仓库名/commits/某一条commit的SHA</code></li><li>issues列表。<code>https://api.github.com/repos/用户名/仓库名/issues</code>。</li><li>某条issue详情。<code>https://api.github.com/repos/用户名/仓库名/issues/序号</code>。issues都是以1,2,3这样的序列排号的。</li><li>某issue中的comments列表。<code>https://api.github.com/repos/用户名/仓库名/issues/序号/comments</code>。</li><li>某comment详情。<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论详情的ID</code>。其中评论ID是从issues列表中获得的。</li></ul><h2 id="查询参数-Parameters">查询参数 (Parameters)</h2><p>如果在上面基本链接中加入查询条件，那么返回的数据就是filtered，过滤了的。比如要求只返回正在开放的issues，或者让列表数据分页显示。常用如下：</p><ul><li>分页功能。格式是<code>?page=页数&amp;per_page=每页包含数量</code>。</li></ul><p>如<code>https://api.github.com/users/solomonxie/repos?page=2&amp;per_page=3</code></p><ul><li>issues状态。格式是<code>?state=状态</code>。</li></ul><p>如<code>https://api.github.com/repos/solomonxie/solomonxie.github.io/issues?state=closed</code></p><h2 id="权限认证-Authentication">权限认证 Authentication</h2><blockquote><p>首先需要知道都是，到此为止之前所有都查询都是不需要任何权限的，给个地址就返回数据，全公开。<br>但是创建文件、更新、删除等就是必须用自己的账号&quot;登录&quot;才能实现的。所以为了下面的增删改做准备，需要先看一下权限问题。<br>官网虽然写的很简答，不过如果不熟悉API的话还是不能马上就理解。</p></blockquote><p>常用的认证方法有三种，<code>Basic authentication</code>, <code>OAuth2 token</code>, <code>OAuth2 key/secret</code><br>三种方法效果一样，但是各有其特点和方便之处。选哪种就要看自己哪种方便了。</p><h3 id="认证方法一：Basic-authentication">认证方法一：Basic authentication</h3><p>这种最简单，如果是用curl的话，就：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u <span class="string">&quot;用户名:密码&quot;</span> https:<span class="regexp">//</span>api.github.com</span><br></pre></td></tr></table></figure><p>如果是用Insomnia等api调试工具的话，直接在Auth选项栏里选Basic Auth，然后填上用户名密码即可。</p><h3 id="认证方法二：OAuth2-token">认证方法二：OAuth2 token</h3><h4 id="关于token">关于token</h4><blockquote><p>这种token方式，说实话如果不是操作过API或深度了解REST的话，是很难理解的东西。<br>说白了就是<code>第二个密码</code>，你既不用到处泄露自己的用户名密码，又可以专门给这个&quot;第二密码&quot;设置不同需要的权限，如有的只可读有的还可以写等。而且这个“第二密码”是既包括用户名又包括密码功能的，全站只此一个绝对不会和别人重复。初次之外，你还可以设置很多个token，也就是第三、第四、第五…密码。很方便。</p></blockquote><h4 id="设置token方法">设置token方法</h4><p>就位于github个人账号设置-&gt;开发者设置-&gt;个人token里。创建一个新token时，可以选择具体的权限，创建成功时一定要复制到本地哪里保存，只会让你看见一次，如果忘记的话就需要重新生成（其实丢了也不算麻烦）。<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951868.webp" alt="image"></p><p>另外！注意：</p><blockquote><p>token字符串不能存储在github的repo中，经过测试，一旦提交的文件中包含这个token字符串，那么github就会自动删除这个token -_-! 我用了很久才明白过来，创建的Personal Access Token总是自动消失，还以为是有时限的。</p></blockquote><h4 id="用token通过权限认证">用token通过权限认证</h4><p>有两种传送方法，哪种都可以：</p><ol><li>作为url中的参数明文传输：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="regexp">//</span>api.github.com/?access_token=OAUTH-TOKEN</span><br></pre></td></tr></table></figure><ol><li>作为header中的参数传输：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: token OAUTH-TOKEN&quot;</span> https:<span class="regexp">//</span>api.github.com</span><br></pre></td></tr></table></figure><p>如果不是用curl而是Insomnia测试的话，和上面basic auth是大同小异的，很容易操作就不复述了。<br>到此为止，权限认证就算搞清了，而且也实际验证过有效了。强烈建议用insomnia工具操作，有GUI界面方便理解，成功后再转为curl或python等程序语言。</p><h3 id="认证方法三：OAuth2-key-secret">认证方法三：OAuth2 key/secret</h3><p>这个是除了Personal Access Token之外的另一种好用的方法，即创建自己的OAuth app，然后得到一对<code>client_id</code>和<code>client_secret</code>。如下：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951962.webp" alt="image"><br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951836.webp" alt="image"><br>得到这两个值之后，直接在访问任何api的url连接后面显性加上这两个参数即可完成认证，如：<br><code>https://api.github.com/users/yourusername?client_id=YOUR-CLIENT-ID&amp;client_secret=YOUR-CLIENT-SECRET</code><br>但是：</p><blockquote><p>目前这种认证方式<strong>不支持</strong>查询以外的操作，也就是只能GET获取某些api信息，不能执行request里的任何PUT/PATCH/DELETE操作。</p></blockquote><h2 id="创建新文件-Create-content">创建新文件 Create content</h2><blockquote><p><a href="https://link.segmentfault.com/?enc=6J0ZNCI1z5xe8NW0ErjLjw%3D%3D.28GtMY3g6Q%2FzMAdzblEqwFBpjbAqGy1%2B%2Fkbds9sgl2Wp%2BOHXBsUKovo2FVE1jJeFGqhybfNXXoOvzZDiEePWDg%3D%3D">Contents操作 官方文档</a></p></blockquote><ul><li>传输方法：<code>PUT</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/contents/文件路径</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;commit from INSOMNIA&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;bXkgbmV3IGZpbGUgY29udGVudHM=&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON填写如下图：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951985.webp" alt="image"></p><ul><li>注意：1.必须添加权限验证（上面有写） 2. 数据传送格式选择JSON 3. 文件内容必须是把文件整体转为Base64字符串再存到JSON变量中 4. 文件路径中如果有不存在的文件夹，则会自动创建</li></ul><p>起初不管怎么尝试都一直报同样都错误，400 Invalid JSON，如下图：<br>[图片上传失败…(image-884e71-1527903120996)]</p><p>最后发现原来是犯了很小很小都错误才导致如此：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951217.webp" alt="image"><br>原来，我的token看似是正常的，唯独错误的是，多了一个空行！也就是说，标明都是invalid JSON，结果没注意竟然是invalid Token!</p><p>增加文件成功后返回的消息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951613.webp" alt="image"></p><h2 id="更新文件-Update-content">更新文件 Update content</h2><blockquote><p>主要这几点： 1. 传送方式用<code>PUT</code> 和创建文件一样 2. 需要权限验证，3. 传输内容数据用JSON 4. 需要指定该文件的SHA码 4. 路径和访问content时一样 5. 文件内容必须是把文件整体转为Base64字符串再存到JSON变量中</p></blockquote><ul><li>传输方法：<code>PUT</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/contents/文件路径</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;update from INSOMNIA&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Y3JlYXRlIGZpbGUgZnJvbSBJTlNPTU5JQQoKSXQncyB1cGRhdGVkISEhCgpJdCdzIHVwZGF0ZWQgYWdhaW4hIQ==&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sha&quot;</span>: <span class="string">&quot;57642f5283c98f6ffa75d65e2bf49d05042b4a6d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：必须指定该文件的<code>SHA码</code>，相当于文件的ID。</li></ul><h2 id="SHA虽然是对文件的唯一识别码，相当于ID，但是它是会随着文件内容变化而变化的！所以必须每次都重新获取才行。"><code>SHA</code>虽然是对文件的唯一识别码，相当于ID，但是它是会随着文件内容变化而变化的！所以必须每次都重新获取才行。</h2><p>至于获取方式，验证后发现，目前最靠谱的是用前面的<code>get content</code>获取到该文件的信息，然后里面找到<code>sha</code>。</p><p>对上传时的JSON格式另有要求，如果没有按照要求把必填项输入，则会出现422错误信息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951316.webp" alt="image"></p><p>或者如果用错了SHA，会出现409错误消息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951758.webp" alt="image"></p><p>如果正确传送，就会显示200完成更新：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150950271.webp" alt="image"></p><h2 id="删除文件-Delete-content">删除文件 Delete content</h2><ul><li>传输方法：<code>DELETE</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/contents/文件路径</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;delete a file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sha&quot;</span>: <span class="string">&quot;46d2b1f2ef54669a974165d0b37979e9adba1ab2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除成功后，会返回200消息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150950692.webp" alt="image"></p><h2 id="增删改issues">增删改issues</h2><blockquote><p>如果做过了上面文件的增删改，这里大同小异，不同的访问路径和JSON的格式而已。唯一不同的是，issues是不用把内容转为Base64码的。</p></blockquote><p>参考链接：<a href="https://link.segmentfault.com/?enc=cubTHVRW%2B%2B3zhF0MSvjjEA%3D%3D.XT5VmuuWDDx%2FjO0NHyEGX0FVrxlM1wwXX1C7rRYN5RJYE7spyL2bsP1V5my3qBJw7fiukuRfawjZtv3YseOq3A%3D%3D">github官方文档</a></p><h3 id="增加一条issue">增加一条issue</h3><ul><li>传输方法：<code>POST</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Creating issue from API&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Posting a issue from Insomnia&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：issue的数据里面是可以加label，milestone和assignees的。但是必须注意milestone和assignees必须是已有的名次完全对应才行，否则无法完成创建。</li></ul><h3 id="更改某条issue">更改某条issue</h3><ul><li>传输方法：<code>PATCH</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Creating issue from API ---updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Posting a issue from Insomnia \n\n Updated from insomnia.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: <span class="string">&quot;open&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：如果JSON中加入空白的labels或assignees，如<code>&quot;labels&quot;: []</code>，作用就是清空所有的标签和相关人。</li></ul><h3 id="锁住某条issue">锁住某条issue</h3><p>不允许别人评论（自己可以）<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150950039.webp" alt="image"></p><ul><li>传输方法：<code>PUT</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号/lock</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;locked&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;active_lock_reason&quot;</span>: <span class="string">&quot;too heated&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：active_lock_reason只能有4种值可选：<code>off-topic</code>, <code>too heated</code>, <code>resolved</code>, <code>spam</code>，否则报错。</li></ul><p>另外，成功锁住，会返回<code>204 No Content</code>信息。</p><h3 id="解锁某条issue">解锁某条issue</h3><ul><li>传输方法：<code>DELETE</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号/lock</code></li><li>无JSON传输</li></ul><h2 id="增删改comments">增删改comments</h2><blockquote><p>参考<a href="https://link.segmentfault.com/?enc=qYItiCFOCjgxsyvnFS0IeQ%3D%3D.W4f9KfCM2N1UB%2F562ZAgnz1tp%2FWdNWxdwlpWEb9gYTKz%2BSDlL9McsQzG%2FLu%2BB7e1zSo60TF%2FPnjkVSNHLpbvHC1QeNRP0Edny1FwyFpf6%2Fc%3D">官方文档</a></p></blockquote><h3 id="增加comment">增加comment</h3><ul><li>传输方法：<code>POST</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号/comments</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Create a comment from API&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改comment">更改comment</h3><ul><li>传输方法：<code>PATCH</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Create a comment from API \n\n----Updated&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：地址中，issues后不用序号了，因为可以通过唯一的<code>评论ID</code>追查到。查看评论ID的方法，直接在上面查询链接中找。</li></ul><h3 id="删除comment">删除comment</h3><ul><li>传输方法：<code>DELETE</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID</code></li><li>无传输数据</li></ul>]]></content>
    
    
    <summary type="html">一篇文章搞定Github API 调用 (v3）</summary>
    
    
    
    <category term="演示" scheme="https://www.sadalsuud.cn/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="GitHub" scheme="https://www.sadalsuud.cn/tags/GitHub/"/>
    
    <category term="API" scheme="https://www.sadalsuud.cn/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>Windows旋转屏幕后鼠标方向没变的解决实例</title>
    <link href="https://www.sadalsuud.cn/posts/25658fff.html"/>
    <id>https://www.sadalsuud.cn/posts/25658fff.html</id>
    <published>2024-06-12T12:47:38.000Z</published>
    <updated>2024-06-15T03:47:16.626Z</updated>
    
    <content type="html"><![CDATA[<h1>Windows旋转屏幕后鼠标方向没变的解决实例</h1><p>如果你在将Windows外接显示器更改显示方向后，出现鼠标并未旋转仍然保持原显示方向的情况时，可以尝试以下方式进行解决：</p><ol><li>尝试切换分辨率，切换后再修改回来确认是否可以修正</li><li>重启设备再次确认情况</li><li>打开NVIDIA Panel查看显示器状态是否正确并刷新设置</li></ol>]]></content>
    
    
    <summary type="html">本文提供Windows外接显示器更改显示方向后，鼠标并未旋转仍然保持原显示方向的问题解决方法</summary>
    
    
    
    <category term="演示" scheme="https://www.sadalsuud.cn/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="Windows" scheme="https://www.sadalsuud.cn/tags/Windows/"/>
    
    <category term="屏幕方向改变" scheme="https://www.sadalsuud.cn/tags/%E5%B1%8F%E5%B9%95%E6%96%B9%E5%90%91%E6%94%B9%E5%8F%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript（JS）遍历对象</title>
    <link href="https://www.sadalsuud.cn/posts/807271b8.html"/>
    <id>https://www.sadalsuud.cn/posts/807271b8.html</id>
    <published>2024-06-11T01:06:04.000Z</published>
    <updated>2024-06-11T01:09:06.653Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中，对象是一种非常重要的数据结构，要访问和处理对象中的属性和方法，我们需要能够遍历对象。本文将介绍在 JavaScript 中遍历对象的几种常见方法。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406110908690.png" alt="javascript js 中遍历对象 Object 的方法"></p><h2 id="JavaScript-中遍历对象的基本概念">JavaScript 中遍历对象的基本概念</h2><p>遍历对象就是访问对象中的每一个属性，对属性进行读取或操作。常见的遍历对象的场景包括:</p><ul><li>打印出对象的所有属性名和值</li><li>查找对象中是否存在某个属性</li><li>对对象的属性进行修改或删除遍历对象可以让我们更好地访问和利用对象中的数据。</li></ul><h2 id="JavaScript-中的对象遍历方法">JavaScript 中的对象遍历方法</h2><p>在 JavaScript 中，有几种常用的方法来遍历对象。下面将介绍这些方法，并提供详细的解释和示例代码。</p><h3 id="1-for…in-循环"><strong>1.for…in 循环</strong></h3><p><code>for...in</code> 循环可以用来遍历对象的可枚举属性，包括原型链上的属性。它将遍历对象的所有键，并允许你访问对应的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Engineer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;person[key]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Object-keys-方法">2.<strong>Object.keys() 方法</strong></h3><p><code>Object.keys()</code> 方法返回一个包含对象自身可枚举属性名称的数组。你可以遍历这个数组来访问对象的属性和值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Designer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(person);</span><br><span class="line">keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;person[key]&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-Object-values-方法">3.<strong>Object.values() 方法</strong></h3><p><code>Object.values()</code> 方法返回一个包含对象自身可枚举属性值的数组。你可以遍历这个数组来访问对象的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">28</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Artist&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(person);</span><br><span class="line">values.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-Object-entries-方法">4.<strong>Object.entries() 方法</strong></h3><p><code>Object.entries()</code> 方法返回一个包含对象自身可枚举属性键值对的数组。每个键值对都以数组形式表示，第一个元素是属性名，第二个元素是属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;David&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Writer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(person);</span><br><span class="line">entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">JavaScript（JS）中怎么遍历对象？一文讲解 JS 遍历对象的方法</summary>
    
    
    
    <category term="js" scheme="https://www.sadalsuud.cn/categories/js/"/>
    
    
    <category term="js" scheme="https://www.sadalsuud.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Echarts X轴标签过长显示不全的解决</title>
    <link href="https://www.sadalsuud.cn/posts/227ef8c8.html"/>
    <id>https://www.sadalsuud.cn/posts/227ef8c8.html</id>
    <published>2024-06-11T00:39:50.000Z</published>
    <updated>2024-06-11T01:09:06.650Z</updated>
    
    <content type="html"><![CDATA[<h1>Echarts X轴标签过长显示不全的解决</h1><p>Echarts 是国内图表组件占有率最高的第三方库，在使用中我们经常遇到 X 轴标签文字过长导致显示不全或 X 轴标签刻度间隔不够的问题。本文详细讲解 4 种标签超长显示问题的解决方案，轻松解决所有场景下的超长问题。</p><h2 id="方法一：Echarts-X-轴-标签倾斜摆放">方法一：Echarts X 轴 标签倾斜摆放</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">nameLocation</span>: <span class="string">&#x27;end&#x27;</span>, <span class="comment">// 名称显示在 X 坐标轴的位置</span></span><br><span class="line">    <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">      <span class="comment">//  X 坐标轴标签相关设置</span></span><br><span class="line">      <span class="attr">interval</span>: <span class="number">0</span>, <span class="comment">//使x轴文字显示全</span></span><br><span class="line">      <span class="attr">rotate</span>: <span class="string">&#x27;45&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="方法二：Echarts-X-轴-限制每行字数，换行显示">方法二：Echarts X 轴 限制每行字数，换行显示</h2><p>「换行显示标签」适合按字数断句的场景，X 轴每个标签都是前 N 个字一断是一个完整的词时，特别适合这种场景实用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xAxis</span>: &#123;</span><br><span class="line">  <span class="attr">data</span>: [</span><br><span class="line">  ...</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">nameLocation</span>: <span class="string">&#x27;end&#x27;</span>, <span class="comment">// 名称显示在 X 坐标轴的位置</span></span><br><span class="line">  <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">    <span class="attr">formatter</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> newParamsName = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 拼接后的新字符串</span></span><br><span class="line">      <span class="keyword">var</span> paramsNameNumber = params.<span class="property">length</span>; <span class="comment">// 实际标签数</span></span><br><span class="line">      <span class="keyword">var</span> provideNumber = <span class="number">3</span>; <span class="comment">// 每行显示的字数</span></span><br><span class="line">      <span class="keyword">var</span> rowNumber = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(paramsNameNumber / provideNumber); <span class="comment">// 如需换回，算出要显示的行数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (paramsNameNumber &gt; provideNumber) &#123;</span><br><span class="line">        <span class="comment">/** 循环每一行,p表示行 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rowNumber; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> tempStr = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 每次截取的字符串</span></span><br><span class="line">          <span class="keyword">var</span> start = i * provideNumber; <span class="comment">// 截取位置开始</span></span><br><span class="line">          <span class="keyword">var</span> end = start + provideNumber; <span class="comment">// 截取位置结束</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 最后一行的需要单独处理</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (i == rowNumber - <span class="number">1</span>) &#123;</span><br><span class="line">            tempStr = params.<span class="title function_">substring</span>(start, paramsNameNumber);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempStr = params.<span class="title function_">substring</span>(start, end) + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          newParamsName += tempStr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newParamsName = params;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> newParamsName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="方法三：Echarts-X-轴-垂直竖显文字">方法三：Echarts X 轴 垂直竖显文字</h2><p>「垂直显示标签」的情况，显得更正式一些。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">nameLocation</span>: <span class="string">&#x27;end&#x27;</span>, <span class="comment">// 名称显示在 X 坐标轴的位置</span></span><br><span class="line">    <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">      <span class="attr">interval</span>: <span class="number">0</span>, <span class="comment">//使x轴文字显示全</span></span><br><span class="line">      <span class="attr">formatter</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>总的来说，本质就两种方法：</p><ol><li>文本倾斜显示</li><li>使用自定义的formatter</li></ol>]]></content>
    
    
    <summary type="html">ECharts X 轴标签过长导致文字重叠或者无法完全现实的问题的解决</summary>
    
    
    
    <category term="front" scheme="https://www.sadalsuud.cn/categories/front/"/>
    
    
    <category term="echarts" scheme="https://www.sadalsuud.cn/tags/echarts/"/>
    
  </entry>
  
</feed>
