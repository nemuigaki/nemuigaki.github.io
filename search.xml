<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker 被墙?Linux安装最新的Docker安装方法</title>
      <link href="/posts/3a396ac8.html"/>
      <url>/posts/3a396ac8.html</url>
      
        <content type="html"><![CDATA[<h1>Docker 被墙?Linux安装最新的Docker安装方法</h1><p>在目前的情况下 <a href="http://download.docker.com">download.docker.com</a> 访问不是特别稳定的情况下,可以使用阿里的地址来进行更新<br>一、安装<br>1、检查环境<br>1.1 卸载旧版docker</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">apt <span class="built_in">remove</span> docker docker-engine docker.<span class="built_in">io</span> containerd runc</span><br></pre></td></tr></table></figure><p>2、安装依赖</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt -y install ca-certificates curl gnupg lsb-release</span><br></pre></td></tr></table></figure><p>3、添加密钥<br>输入命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/docker-ce/</span>linux<span class="regexp">/ubuntu/g</span>pg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>打印返回（返回OK即为成功）</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ok</span></span><br></pre></td></tr></table></figure><p>4、添加Docker软件源</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span><span class="string">&quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot;</span></span><br></pre></td></tr></table></figure><p>5、安装docker</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt -<span class="keyword">y</span> install docker-<span class="keyword">ce</span> docker-<span class="keyword">ce</span>-cli containerd.io</span><br></pre></td></tr></table></figure><p>6、启动docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><p>7、查看docker状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">systemctl status docker</span></span><br></pre></td></tr></table></figure><p>8、将当前用户添加到docker组<br>避免每次使用Docker时都需要使用sudo（默认情况下，只有root用户和docker组的用户才能运行Docker命令）</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><p>10、重启docker服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">service docker restart</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dcoker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在 Debian 11 上设置静态 IP 地址</title>
      <link href="/posts/44614b5d.html"/>
      <url>/posts/44614b5d.html</url>
      
        <content type="html"><![CDATA[<h1>如何在 Debian 11 上设置静态 IP 地址</h1><p>当您在计算机上安装新操作系统时，DHCP 服务器会为您分配一个动态 IP 地址。但是，在各种情况下，您可能需要在计算机上设置<strong>静态 IP 地址</strong>，例如当您托管 Web 服务器或任何服务需要 IP 地址时而不是域名，或者在您要授予某人远程访问您的系统的情况下。无论原因是什么，您都应该知道如何在系统上设置静态 IP 地址。</p><p>在这篇文章中，您将学习<strong>如何使用</strong>两种不同的方法<strong>在 Debian 11 上设置静态 IP</strong>。那么，让我们开始吧！</p><h2 id="方法-1：使用终端在-Debian-11-上设置静态-IP-地址">方法 1：使用终端在 Debian 11 上设置静态 IP 地址</h2><p>作为<strong>Debian</strong>用户，您可以使用终端轻松设置<strong>静态IP</strong>。为此，首先，您必须在系统上选择一个活动的网络接口。</p><h2 id="如何检查-Debian-11-上可用的网络接口">如何检查 Debian 11 上可用的网络接口</h2><p>您可以使用“<strong>ip</strong>”命令来获取有关系统当前可用网络接口的详细信息。 “<strong>ip</strong>”是“<strong>Internet 协议</strong>”的缩写。 “<strong>ip</strong>”命令是基于 Linux 的系统中网络和系统管理员用来配置网络接口的实用程序。在“<strong>ip</strong>”命令中，“<strong>link</strong>”是添加的子命令，用于查看和修改网络接口。在 <strong>Debian 11</strong> 终端中写出以下命令，以查看当前可用的网络接口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip <span class="built_in">link</span></span><br></pre></td></tr></table></figure><p>从输出中，我们将记下活动网络接口的名称，即“<strong>enpos3</strong>”。由于“<strong>enpos3</strong>”是我们将为其设置静态 IP 的网络接口：</p><h2 id="如何在-Debian-11-上设置静态-IP-地址">如何在 Debian 11 上设置静态 IP 地址</h2><p>现在，在nano编辑器中打开网络接口的配置文件“<strong>/etc/network/interfaces</strong>”：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/network/interfaces</span><br></pre></td></tr></table></figure><p>使用默认设置，您的网络接口配置文件将如下所示：</p><p>在“<strong>/etc/network/interfaces</strong>”文件中，添加有关网络接口的以下详细信息，例如您要设置的静态<strong>IP 地址</strong>，&lt;网络掩码、网关、DNS 名称服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto enp0s3</span><br><span class="line">iface enp0s3 inet static</span><br><span class="line">address 192.168.2.2</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.2.2</span><br><span class="line">dns-nameservers 8.8.4.4 8.8.8.8</span><br></pre></td></tr></table></figure><p>这里，前两行声明我们正在为“<strong>enpos3</strong>”网络接口设置静态 IP 地址：</p><p>要保存在网络接口配置文件中所做的更改，请按“<strong>CTRL+O</strong>”：</p><h2 id="如何在-Debian-11-上重启网络服务">如何在 Debian 11 上重启网络服务</h2><p>为“<strong>enpos3</strong>”网络接口配置静态IP地址后，现在我们将使用<strong>systemctl</strong> 命令重新启动网络服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart NetworkManager.service</span><br></pre></td></tr></table></figure><p>您可以验证 Debian 系统是否已为所选网络接口配置静态 IP：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip a</span><br></pre></td></tr></table></figure><p>从输出中，您可以看到我们已成功将“<strong>enpos3</strong>”网络接口的静态 IP 地址配置为“<strong>192.168.2.2</strong>”：</p><h2 id="方法-2：使用-GUI-在-Debian-11-上设置静态-IP-地址">方法 2：使用 GUI 在 Debian 11 上设置静态 IP 地址</h2><p><strong>Debian 11</strong> 还为您提供了使用其 GUI 设置活动网络接口的静态 IP 地址的功能。如果您想使用 Debian GUI 方法来配置静态 IP 地址，请通过在应用程序栏中搜索“<strong>设置</strong>”来打开系统设置：</p><p>从左侧菜单中的不同类别中，选择“<strong>网络</strong>”。单击齿轮图标打开活动网络连接的设置：</p><p>在打开的网络设置窗口中，单击“<strong>IPv4</strong>”选项卡。为您的网络选择“<strong>手动</strong>”IPv4 方法：</p><p>之后，为您的网络添加<strong>静态 IP 地址、网络掩码、网关、DNS</strong>，然后单击“<strong>应用</strong>”按钮：</p><p>现在，打开“<strong>详细信息</strong>”选项卡。在这里，您将验证网络的添加详细信息，例如 IP 地址：</p><p>这就是在 Debian 11 上使用 GUI 设置网络接口静态 IP 地址的方法。</p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Debian </tag>
            
            <tag> Debian11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 被墙?Dcoker拉取镜像的解决方案</title>
      <link href="/posts/55cf70c8.html"/>
      <url>/posts/55cf70c8.html</url>
      
        <content type="html"><![CDATA[<h1>Docker 被墙?Dcoker拉取镜像的解决方案</h1><h2 id="设置国内源：">设置国内源：</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示：常规方案（作用不大）</span><br></pre></td></tr></table></figure><p>阿里云提供了镜像源：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a> 登录后你会获得一个专属的地址<br>使用命令设置国内镜像源：通过vim /etc/docker/daemon.json 进入修改添加 registry-mirrors 内容后重启 Docker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://***替换为你的地址***.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure><p>此命令会创建一个 /etc/docker/daemon.json 文件，并将国内源的配置写入其中。然后你只需要重启 Docker 服务即可使配置生效，可以通过运行 sudo systemctl restart docker 命令来重启 Docker 服务。</p><h2 id="解决目前Docker-Hub国内无法访问方法">解决目前Docker Hub国内无法访问方法</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">提示：亲测有效果</span><br></pre></td></tr></table></figure><p>2023年5月中旬， <a href="http://hub.docker.com">hub.docker.com</a> “不知” 何种原因国内均无法正常访问了。当时只是官网不能访问，但是不影响pull镜像。</p><p>2024年6月，国内几家Docker Hub 镜像服务平台均被要求下架，停止服务。</p><p><strong>解决方案1：配置加速地址</strong></p><p>配置加速地址：适用于Ubuntu 16.04+、Debian 8+、CentOS 7+</p><p>方式一：使用以下命令设置registry mirror：但是需要重启docker服务</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;https://do.nark.eu.org&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dc.j8.work&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.m.daocloud.io&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://dockerproxy.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,</span><br><span class="line">        <span class="string">&quot;https://docker.nju.edu.cn&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>检查加速是否生效：</strong><br>查看docker系统信息 docker info，如果从输出结果中看到了 registry mirror 刚配置的内容地址，说明配置成功。</p></blockquote><p>方式二：如果您当前有正在运行的容器不方便重启Docker服务，则不用设置环境也可以直接使用，用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="keyword">do</span>.nark.eu.org/library/mysql:<span class="number">5.7</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>第三方镜像：</p><p>AtomHub 可信镜像中心 - 大部分需要的镜像都是有的。<br>可信镜像中心官网：<a href="https://atomhub.openatom.cn/">https://atomhub.openatom.cn/</a><br>通过搜索需要的镜像名称，进行pull拉取，用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull atomhub.openatom.cn/amd64/redis:<span class="number">7.0</span><span class="number">.13</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：docker compose 中要执行部署时，可以把版本与 atomhub 提供的版本匹配上，之后通过【拉取命令】进行单独拉取后，在执行 docker compose 就可以了。</p></blockquote><p>加速代理站点：</p><p>专门为Github用户提供下载加速服务的代理站点。由于Github的下载速度在某些地区可能会受到限制，导致开发者在获取代码库、项目文件等资源时遇到困难。该代理站点通过优化的网络节点和高速服务器，为用户提供快速、稳定的Github资源下载服务。<br>站点地址：<a href="https://docker.888666222.xyz/">https://docker.888666222.xyz/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">第一步：为了加速镜像拉取，你可以使用以下命令设置 registry mirror:</span><br><span class="line"></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.888666222.xyz&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">第二步：为了避免 Worker 用量耗尽，你可以手动 pull 镜像然后 re-tag 之后 push 至本地镜像仓库:</span><br><span class="line"></span><br><span class="line">docker pull docker<span class="number">.888666222</span>.xyz/library/alpine:latest # 拉取 library 镜像</span><br><span class="line">docker pull docker<span class="number">.888666222</span>.xyz/coredns/coredns:latest # 拉取 coredns 镜像</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p><strong>解决方案2：使用代理拉取镜像</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">第一步：创建配置文件</span><br><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br><span class="line">sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf</span><br><span class="line"></span><br><span class="line">第二步：在文件中添加代理</span><br><span class="line">[Service]</span><br><span class="line">Environment=<span class="string">&quot;HTTP_PROXY=socks5://user:pass@127.0.0.1:1080&quot;</span></span><br><span class="line">Environment=<span class="string">&quot;HTTPS_PROXY=socks5://user:pass@127.0.0.1:1080&quot;</span></span><br><span class="line"></span><br><span class="line">第三步：重启Docker</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">第四步：查看环境变量</span><br><span class="line">sudo systemctl show --property=Environment docker</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><p><strong>解决方案3：备用办法：直接传送镜像</strong></p><p>国外服务器拉取镜像后打包压缩到本地，然后传输到国内服务器，myimage为镜像名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一步：A服务器保存Docker镜像</span><br><span class="line">docker save myimage &gt; myimage.tar</span><br><span class="line"></span><br><span class="line">第二步：传送到B服务器</span><br><span class="line">scp myimage.tar root@<span class="number">192.0</span><span class="number">.2</span><span class="number">.0</span>:/home</span><br><span class="line">然后输入B服务器root密码</span><br><span class="line"></span><br><span class="line">第三步：B服务器加载Docker镜像</span><br><span class="line">cd /home</span><br><span class="line">docker load &lt; myimage.tar</span><br><span class="line"></span><br><span class="line">第四步：查看镜像</span><br><span class="line">docker images</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure><h2 id="目前可用的镜像代理：">目前可用的镜像代理：</h2><p>拉取 pull 镜像时，遇到不可用、关停、访问比较慢的状态，建议同时配置多个镜像源。</p><table><thead><tr><th>提供商</th><th>地址</th></tr></thead><tbody><tr><td>DaoCloud</td><td><a href="https://docker.m.daocloud.io">https://docker.m.daocloud.io</a></td></tr><tr><td>阿里云</td><td>https://&lt;your_code&gt;.mirror.aliyuncs.com</td></tr><tr><td>Docker镜像代理</td><td><a href="https://dockerproxy.com">https://dockerproxy.com</a></td></tr><tr><td>百度云</td><td><a href="https://mirror.baidubce.com">https://mirror.baidubce.com</a></td></tr><tr><td>南京大学</td><td><a href="https://docker.nju.edu.cn">https://docker.nju.edu.cn</a></td></tr><tr><td>中科院</td><td><a href="https://mirror.iscas.ac.cn">https://mirror.iscas.ac.cn</a></td></tr></tbody></table><p><strong>小福利：</strong><br>近期 Rainbond 社区为了方便拉取 Docker 镜像,自主搭建了个镜像加速服务，采用 CloudFlare + 国外服务器 Nginx 反代的方案为 Rainbond 社区的用户们提供镜像加速服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">方式一：直接获取 Docker Hub 镜像</span><br><span class="line">docker pull docker.rainbond.cc/library/node:<span class="number">20</span></span><br><span class="line">docker pull docker.rainbond.cc/rainbond/rainbond:v5<span class="number">.17</span><span class="number">.2</span>-release-allinone</span><br><span class="line"></span><br><span class="line">方式二：配置镜像加速器</span><br><span class="line">tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.rainbond.cc&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">技术栈参考LINK</span><br><span class="line">https:<span class="comment">//www.rainbond.com/docs/quick-start/quick-install</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure><h2 id="解决办法千万条：">解决办法千万条：</h2><p>面对问题时，解决的途径和方法是多种多样的。每个人、每个团队在面对问题时，都可以根据自身的情况和资源，创造性地找到最适合自己的解决办法。</p><blockquote><ol><li>Docker Hub 镜像加速： <a href="https://gitee.com/wanfeng789/docker-hub">https://gitee.com/wanfeng789/docker-hub</a></li><li>国内无法访问下载Docker镜像的多种解决方案：<a href="https://www.bilibili.com/read/cv35387254/">https://www.bilibili.com/read/cv35387254/</a></li><li>总结目前国内加速拉取 docker 镜像的几种方法：<a href="https://zhuanlan.zhihu.com/p/703322576">https://zhuanlan.zhihu.com/p/703322576</a></li><li>从Docker Hub拉取镜像受阻？这些解决方案帮你轻松应对：<a href="https://mp.weixin.qq.com/s/pXrxedldKOoD97bMDYy3pQ">https://mp.weixin.qq.com/s/pXrxedldKOoD97bMDYy3pQ</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dcoker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鉴权模块-登录鉴权设计</title>
      <link href="/posts/fc8f31f8.html"/>
      <url>/posts/fc8f31f8.html</url>
      
        <content type="html"><![CDATA[<h1>鉴权模块-登录鉴权设计</h1><p>场景：用户的角色不同，有不同的接口访问权限。</p><p>支持多种登录方式（用户名登录、手机号登录、ldap登录）</p><p>支持密码散列存储</p><p>支持黑名单</p><p>防暴力破解</p><p>api限流</p><p>支持高并发</p><h2 id="需求分析：">需求分析：</h2><ul><li><p>接口权限</p><p>用户的角色属于用户属性 1对多 –&gt; 数据库存储</p><p>角色的权限属于角色的属性 1对多 –&gt; 数据库存储</p><p>权限对应的接口调用属于业务范围 1对多 –&gt; 项目中进行配置</p></li><li><p>多登录方式意味着多数据源</p><p>用户名登录 需要存储用户名密码 –&gt; 关系型数据库</p><p>手机号登录 需要短信服务 –&gt;付费开通短信服务</p><p>Ldap登录 需要接入Ldap数据库</p></li><li><p>黑名单：指定用户不予登录，</p><p>黑名单的存储（缓存）</p><p>黑名单有效期</p></li><li><p>防暴力破解</p><p>登录验证失败超过一定次数进入黑名单</p></li><li><p>api限流</p><p>在单位时间内同一个用户调用同一个接口的次数是有限的</p><p>要避免单位时间交界处的超频访问</p></li></ul><h2 id="技术选型：">技术选型：</h2><ol><li>关系型数据库及orm框架 -&gt; mysql + mybatis</li><li>黑名单缓存使用redis -&gt; 可配置自动过期</li><li>鉴权框架–&gt; apache shiro ，轻量，支持多数据源</li><li>网关 netflix.zuul</li></ol><h2 id="方案设计：">方案设计：</h2><h3 id="登录设计">登录设计</h3><p>1、 首次访问需要登陆，客户端需提供用户名密码，由shiro进行用户名/密码认证，shiro获取当前用户信息，并生成token令牌设置到response的cookie中返回给客户端（具体实现上走controller），客户端保存cookie</p><p>2、 token令牌中携带uid信息，并进行数字签名防止被篡改，在TCP连接keeplive期间再次请求，服务器能从携带的token中获取到uid，不再需要登录，token需要设置有效期。</p><p>3、TCP断开后，再次访问同域名下的API，客户端会带上之前发放的Token，shiro会进行token认证，此次认证不需要客户端提供用户名密码，自动登录。认证成功，shiro会获取到当前的用户信息（token中有用户名）–具体实现上走Filter</p><h3 id="鉴权设计">鉴权设计</h3><p>传统的三表结构</p><p>User表 用户有1到多种role</p><p>Role表 role有1到多个permission</p><p>Permission表</p><h2 id="具体方案">具体方案</h2><h3 id="关于用户系统">关于用户系统</h3><p>对于一个简单的用户系统（不考虑复杂的权限控制，只考虑最单一的“合法用户”的鉴定），其功能其实可以被拆的很简单：注册、登录、鉴权。</p><ul><li>注册：用户将用户名和密码交给服务器，并由服务器存储的过程。</li><li>登录：用户将用户名和密码交给服务器，服务器鉴定是否正确的过程（在 Token鉴权系统中，这一步如果通过，会生成并返回 Token）。</li><li>鉴权：用户将 Token 发送给服务器，服务器校验该 Token 是否合法的过程（不考虑复杂鉴权）。</li></ul><h3 id="安全问题">安全问题</h3><p>流程清楚了，我们就来分析一下问题。不考虑前端可能出现的网络抓包等问题，仅从服务器角度考虑，我们可能遇到的安全问题有以下几个：</p><ul><li>密码泄漏</li><li>生成 Token 的 Secret Key（Salt）泄漏</li><li>Token 泄漏 / 伪造</li></ul><p>归纳一下：我们要解决的最重要的安全问题，就是用户最机密的安全信息被泄漏或伪造。</p><h3 id="鉴权设计实践">鉴权设计实践</h3><p>在我最近完成的产品上，为了规避这些问题，我们在关键步骤上进行了一些处理。整个鉴权系统依赖 Apache Shiro 框架；同时，在密码处理，Token 认证上，我们结合了一些自己的解决方案。</p><p>整个流程大致是这样的：（流程图软件到期了 TAT）</p><h4 id="注册">注册</h4><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291227125.jpeg" alt="img"></p><h4 id="登录">登录</h4><p><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/202406291227124.png" alt="img"></p><h4 id="鉴权">鉴权</h4><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291227239.jpeg" alt="img"></p><h4 id="关于密码加密存储与验证">关于密码加密存储与验证</h4><p>密码是一定要进行加密存储的。用户系统最核心的数据表，就是包含用户名（ID）、加密后的密码、Salt 的表。Salt 的生成，我们使用了 Shiro 提供的随机字符串生成工具，与用户名连接后，再进行 MD5。然后使用 Salt 加密密码，然后同时保存 Salt 和加密后的密码。<br>当用户登录时，我们使用 Salt 对用户输入的密码进行加密，再尝试与存储的密码进行匹配。</p><h3 id="关于-Token-方案（JWT-Token）">关于 Token 方案（JWT Token）</h3><p>使用 JWT Token 作为我们的 Token 方案。</p><h4 id="1-JWT-Token">1. JWT Token</h4><p>JWT Token 的全称是 JSON Web Token。一个 JWT Token 由三部分构成：Header，Payload，Signature。Header 规定了 Token 使用的加密方式与 Token 的类型，Payload 是 Token 中包含的用户信息（用户名，过期时间等），Signature 是 Header 的 Base64 值 + Payload 的 Base64 值 + Secret Key 生成的字符串，再对该字符串使用 Header 中规定的散列方式（HS256 或 RS256）取散列值后得到的字符串。一个典型的 JWT Token 是这个样子的：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9<span class="selector-class">.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</span><span class="selector-class">.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br><span class="line"><span class="comment">// HEADER</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="string">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PAYLOAD</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;sub&quot;</span>: <span class="string">&quot;1234567890&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;John Doe&quot;</span>,</span><br><span class="line">  <span class="string">&quot;admin&quot;</span>: true</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SIGNATURE</span></span><br><span class="line"><span class="built_in">HMACSHA256</span>(</span><br><span class="line">  <span class="built_in">base64UrlEncode</span>(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">  <span class="built_in">base64UrlEncode</span>(payload),  </span><br><span class="line">  secret</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Header、Payload 和 Signature 用 <code>.</code> 分隔。</p><p>验证 Token 的时候，我们只需要将前两段（即 Header 和 Payload 的 Base64）加上 Secret Key，然后按照 Header 规定的加密方式进行加密，将生成的字符串与第三段（Signature）比对即可。当然，Token 验证的实践上，不同的项目存在一些分歧：有些人会将生成的 Token 直接存在数据库（比如 Redis）里，然后通过 Query 的方式验证是否合法。这一点我们随后讨论。</p><p>一个 JWT Token 唯一不可见的部分，就是 Secret Key。它是保证这个 Token 合法且安全的唯一字段。拿不到 Secret Key ，就无法生成 Token，也无法验证 Token。这种 Token 机制很常见（HTTPS 的握手过程就类似这样，SSH 连接也是 - 私钥只有一方持有），难点在于，如何生成并管理 Secret Key。</p><h4 id="2-Secret-Key">2. Secret Key</h4><p>首先，所有用户使用相同的 Secret Key <strong>一定是不合理的</strong>。所以我们要解决的第一个问题是，如何为每一个用户生成唯一的 Secret Key ？</p><p>还记得刚才的 Salt 么？每个用户的 Salt 都是唯一的，我们使用 Salt ，但不直接使用 Salt 作为 Secret Key。我们使用 Salt + 加密后的密码，再取 MD5 值作为该用户的 Secret Key。每次鉴权前，我们通过这个方式生成 Secret Key，再使用 Secret Key 进行鉴权。</p><h4 id="3-在项目中使用">3. 在项目中使用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="安全性分析">安全性分析</h3><p>整套系统的安全之处在于，我们没有将任何敏感信息本地化。假设一种最坏的情况：攻击者拿到了我们数据库的全部数据，他能做什么？</p><ul><li>获取密码：密码被加密了，而且每个用户使用不同的 Salt 进行加密，加密方法是自定义的，不知道加密方法的话难以破解。</li><li>获取 Token：我们没有保存任何的 Token。</li><li>获取 Secret Key：Secret Key 是算出来的，即便拿到了 Salt，不知道算法也无法直接得到 Secret Key。</li></ul><p>我们避免了直接保存任何安全信息。攻击者拿到的数据，都无法被直接利用。即便尝试破解，代价也是巨大的。</p><h3 id="关于-Redis">关于 Redis</h3><p>在我看到的一些实践中，有些项目喜欢使用 Redis 存储生成的 Token，从而简化鉴权流程，提升鉴权效率。这样做可以吗？</p><p>我咨询了一位业界专家，同时查阅了相关资料，我给出的答案是：可以，但是不合理，不推荐。</p><h4 id="避免用-Redis-直接存储-Token">避免用 Redis 直接存储 Token</h4><p>还记得我们安全性分析的前提么：如果攻击者拿到了我们数据库的全部数据，他能做什么？</p><p>将 Token 保存在 Redis 中，一定是有风险的。如果服务器被攻破，用户 Token 泄漏的话，在规定的过期时间内，这些被泄漏的 Token 将会使用户账户变得非常危险。</p><p>当然，如果系统运行在内网环境，或者系统本身对用户安全的要求不高，这种方案从某种程度上讲，确实可以提升鉴权效率，简化鉴权流程。但是鉴于其可能存在的安全问题，不推荐。</p><h4 id="可以用-Redis-缓存-Salt">可以用 Redis 缓存 Salt</h4><p>在我们的产品设计中，我们使用 Salt 计算 Secret Key，然后再进行 Token 认证。我们可以在用户登录时把 Salt 缓存到 Redis 中以提升查询效率。</p><h3 id="进一步优化">进一步优化</h3><h4 id="使用-Payload-生成-Secret-Key">使用 Payload 生成 Secret Key</h4><p>现在，整个系统的安全性基本可靠了。但是，仔细分析系统的设计，还是有一点问题：每次鉴权都需要去查询 Salt，I/O 开销比较大。这恰恰也是有些人使用 Redis 的原因之一 —— 提升查询速度。</p><p>仔细分析一下，我们用 Salt 当做了生成 Secret Key 的 Seed ，目的在于保证 Secret Key 唯一，同时不直接存储 Secret Key 。但其实，保持 Secret Key 唯一的方式有很多，不一定要通过 Salt 。实际上只有登录操作必须依赖 Salt，鉴权操作完全可以使用别的机制。</p><p>我们可以使用 JWT 的 Payload 中的某些字段，通过特定算法生成 Secret Key。比如：有效期时间戳 + 用户名，再取 SHA256 散列值（当然可以更复杂，不过要注意性能开销）。因为生成 Secret Key 的算法是不透明的，所以 Secret Key 也是相对安全的。</p><p>如果对把生成 Token 的信息放在 Payload 中心存顾虑的话，我们可以在服务器上通过静态配置文件的方式设置固定的 Secret Salt ，配合 Payload 生成 Secret Key。</p><p>通过这样的方式，我们可以避免在鉴权阶段对数据库进行访问，提升响应效率。我们也可以利用 Secret Salt 进行细粒度的权限角色划分，在此就不赘述了。</p><h4 id="更标准的密码加密模式">更标准的密码加密模式</h4><p>关于密码加密等方式，我的老师给了我一些建议：可以使用 Blowfish 算法进行对称加密。这样的加密更标准，更安全。</p><h3 id="JWT-Token-与前端">JWT Token 与前端</h3><h4 id="JWT-Token-应该放在哪">JWT Token 应该放在哪</h4><p>官方建议使用 Bearer 的模式，即：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer <span class="tag">&lt;<span class="name">token</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="合理使用-Payload，避免-Token-过长">合理使用 Payload，避免 Token 过长</h4><p>JWT Token 是有 Payload 的，这从一定程度上会造成 Payload 滥用。我在 Chrome 上遇到一个奇怪的 Bug：如果 Authorization 过长，Chrome 传递这个字段的时候会发生截断。我们的产品刚开始研发的时候，过度依赖 JWT 的 Payload 传递用户基本信息（用户名、所属用户组、邮箱等），造成 Token 长度非常长。后来对 Token 进行了几次瘦身，才避免了 Chrome 上的 Bug。</p><h4 id="前端真的需要依赖-Payload-吗？">前端真的需要依赖 Payload 吗？</h4><p>答案是否定的。前端并不关心，也不应该关心 Token 的 Payload 是什么，真正使用 Payload 的应该是后端。前端获取用户信息的方式，应当是在用户登录的时候，由服务器作为 HTTP Response 回传，并使用 Cookie / Local Storage / Session Storage 进行持久化存储，而不是通过解析 Token 的 Payload 获得。</p><h2 id="开发遇到的问题">开发遇到的问题</h2><p>问题描述：</p><p>在网关中实现鉴权，考虑到分布式环境可能不止部署一台网关服务器，因此服务器不记录会话信息（为了实现高可用）。因此首次登录之后发放accessToken，再次请求网关会携带这个token</p><p>问题是，再次请求网关时，网关并不知道该请求的客户端已经登录了，因此无法获取权限信息，通过url过滤实现鉴权时，会直接跳转到登录页面</p><p>这个问题的主要原因是一个url不能经过两个过滤器，然后我将token登录过滤器的逻辑集成到鉴权过滤器中，在鉴权之前先使用token登录</p><p>新问题：token登录之后principal关联到accessTokenRealm，鉴权时，shiro还是会去sqlRealm中拿权限信息，然后当然拿不到，报异常。</p><p>异常原因：sqlRealm中获取user的语句是这样写的：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User) principals.from<span class="constructor">Realm(<span class="params">this</span>.<span class="params">getClass</span>()</span>.get<span class="constructor">Name()</span>).iterator<span class="literal">()</span>.next<span class="literal">()</span>;</span><br></pre></td></tr></table></figure><p>fromRealm方法返回一个集合，当集合为空时，获取迭代器执行next操作就会报错，编码不严谨造成的低级错误，正确的做法是应该先对集合判空</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">User</span> <span class="keyword">user</span>;</span><br><span class="line">Collection users =  principalCollection.fromRealm(this.getClass().getName());</span><br><span class="line"><span class="keyword">if</span>(users.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span> ;</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">user</span> = (<span class="keyword">User</span>)users.iterator().next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在作出以上两点修改之后，分布式网关的鉴权功能基本实现了，接下来进行优化。</p><p>shrio默认使用的是<code>PermissionsAuthorizationFilter</code>来进行鉴权，我上面的做法是</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AccessTokenAuthorizedFilter</span> <span class="keyword">extends</span> <span class="title">PermissionsAuthorizationFilter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span>[] perms;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AccessTokenLoginFilter</span> accessTokenLoginFilter = <span class="keyword">new</span> <span class="type">AccessTokenLoginFilter</span>();</span><br><span class="line">    public <span class="type">AccessTokenAuthorizedFilter</span>(<span class="type">String</span>[] perms)&#123;</span><br><span class="line">        <span class="keyword">this</span>.perms = perms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public boolean isAccessAllowed(<span class="type">ServletRequest</span> request, <span class="type">ServletResponse</span> response, <span class="type">Object</span> mappedValue) <span class="keyword">throws</span> <span class="type">IOException</span> &#123;</span><br><span class="line">        accessTokenLoginFilter.executeLogin(request,response);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.isAccessAllowed(request,response,perms);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样带来的缺点是不能像<code>PermissionsAuthorizationFilter</code>那样优雅的配置过滤器了。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ShiroFilterFactoryBean factoryBean = <span class="keyword">new</span> <span class="type">ShiroFilterFactoryBean</span>();</span><br><span class="line">Map&lt;<span class="keyword">String</span>, Filter&gt; filterMap = <span class="keyword">new</span> <span class="type">HashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">filterMap.put(<span class="string">&quot;permedit&quot;</span>,<span class="keyword">new</span> <span class="type">AccessTokenAuthorizedFilter</span>(<span class="keyword">new</span> <span class="type">String</span>[]&#123;<span class="string">&quot;edit&quot;</span>&#125;));</span><br><span class="line">factoryBean.setFilters(filterMap);</span><br><span class="line">factoryBean.setSecurityManager(manager);</span><br><span class="line">LinkedHashMap&lt;<span class="keyword">String</span>,<span class="keyword">String</span>&gt; filterRuleMap = <span class="keyword">new</span> <span class="type">LinkedHashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="comment">//拥有edit权限</span></span><br><span class="line">filterRuleMap.put(<span class="string">&quot;/user-provider/user/edit&quot;</span>,<span class="string">&quot;permedit&quot;</span>);</span><br><span class="line">factoryBean.setFilterChainDefinitionMap(filterRuleMap);</span><br><span class="line"><span class="keyword">return</span> factoryBean;</span><br></pre></td></tr></table></figure><p>接下来的优化就是看能不能有更好的设计方式，能像原生的shiro那样优雅的配置</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filterRuleMap.<span class="keyword">put</span>(<span class="string">&quot;/user-provider/user/edit&quot;</span>,<span class="string">&quot;perms[edit]&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="参考链接">参考链接</h2><p><a href="https://zzkenyon.github.io/2018/06/02/shiro-zuul%E9%89%B4%E6%9D%83%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/">鉴权模块-登录鉴权设计 | 黑风雅过吟 (zzkenyon.github.io)</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Auth </tag>
            
            <tag> Design </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解&#39;左派/右派、左倾/右倾、左翼/右翼&#39;</title>
      <link href="/posts/ce4c3005.html"/>
      <url>/posts/ce4c3005.html</url>
      
        <content type="html"><![CDATA[<h1>了解’左派/右派、左倾/右倾、左翼/右翼’</h1><p><strong>一、总论</strong></p><p><strong>1. 左派/右派属于国际政治一级分类：</strong></p><p><strong>左派通常主张积极改革，革除旧制度，建立新的意识形态和制度；右派一般较为保守，主张稳妥、秩序、渐进、缓慢的改革方式，强调维护传统。</strong></p><p><strong>2.左倾/右倾是左派的二级分类</strong>：</p><p>在左派内部，“左”倾和右倾在社会主义立场上存在认知偏差。</p><p><strong>左倾：左倾是指政治上追求进步、同情劳动人民的倾向；</strong></p><p><strong>带引号的“左”倾：是指政治思想上超越客观，脱离社会现实条件，陷入空想、盲动和冒险的倾向，表现为急于求成，主观地夸大革命力量，轻视敌人力量和客观困难，在革命和建设中冒进；</strong></p><p><strong>右倾：是指政治思想上，认识落后于实际，在革命斗争中过高估计敌人力量，过低估计革命力量，在实践中发展成为“右倾机会主义”和“右倾投降主义”，在斗争中往往放弃原则，牺牲无产阶级根本利益而求得妥协。</strong></p><p><strong>3.左翼/右翼为右派的二级分类</strong>：</p><p>在右派内部，左翼和右翼在自由资本主义立场上存在认识偏差。</p><p><strong>左翼：提倡社会公平，增加社会福利，改良资本主义弊病，在政策上给工人阶级带来实惠，缓和资产阶级与工人阶级矛盾；</strong></p><p><strong>右翼：支持自然竞争，反对增长社会福利，反对资本主义改革，维持旧有的自由市场经济体系。</strong></p><p><strong>左派、右派是方向之分，左倾/右倾、左翼/右翼是同方向的路线之分。</strong></p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291224296.jpg%2526thumbnail%253D660x2147483647%2526quality%253D80%2526type%253Djpg" alt="img"></p><p><strong>二、世界政治中“左”和“右”的起源</strong></p><p>**左派和右派的称呼最初起源于18世纪末的法国大革命。**在大革命期间国民议会中，两伙持不同政见的人分别坐在议会的两侧，温和派的保王党人都坐在右边，激进的革命党人都坐在左边。</p><p>坐在左侧的议员们主张平等、反对君主制、支持共和、反教权、提倡世俗主义，被称为左派。</p><p>坐在右侧的议员们则多为保王党、维护天主教会和贵族利益，以及已经晋升为资产阶级者的利益、守护传统价值，被称为右派。</p><p>当时，两者最大的差别在于，<strong>左派想要实行激进革命，而右派则想要维持现状，因此，前者被称为激进主义者，而后者被称为保守主义（渐进的改良）者。</strong></p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291224135.jpg%2526thumbnail%253D660x2147483647%2526quality%253D80%2526type%253Djpg" alt="img"></p><p><strong>三、“左”和“右”的当今含义</strong></p><p><strong>相比法国大革命时期，如今“左和右”的含义已更加宽泛</strong>，在不同国家存在区别划分，不能简单把“左”划成“激进”，把“右”等同“保守”，需要分具体问题来讨论；而且“<strong>左和右</strong>”<strong>是相对概念，要在具体情境下看是跟谁比。</strong></p><p><strong>左</strong>——支持平等原则，限制权贵富裕阶层，倡导社会资源分配平等，社会财富向多数人倾斜，缩减贫富差距，主张政府干预经济，反对资产阶级独大、垄断；</p><p><strong>右</strong>——追求自由主义，最大限度地为权贵松绑，倡导利己主义，能者多得，反对政府干预经济，维护既得利益者的地位，拒绝以高福利政策滋养闲人。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291224043.jpg%2526thumbnail%253D660x2147483647%2526quality%253D80%2526type%253Djpg" alt="img"></p><p><strong>举几个例子：</strong></p><p>美国民主党是著名左翼政党，主张平权，重视环保，施行全民医保；而共和党则是右翼政党，也叫保守党派，鼓吹美国至上、白人至上、驱逐非法移民。</p><p>英国工党代表劳动者的利益，属于左翼，保守党代表资产阶级，划分为右翼。</p><p><strong>但美国不管是民主党还是共和党，英国无论是工党还是保守党，相对社会主义而言，都是右派。</strong></p><p>“欧美白左们”忽视客观规律，以激进和极端方式主张女权运动、环保主义、福利社会、多元文化、民族交融、世界主义、国际主义、人道主义、维护同性恋权益，已成为偏执的代名词。</p><p>法国总统马克龙，在竞选时有个对手叫“玛丽娜·勒庞”，勒庞的观点和川普相似，主张退出欧元区、反全球化、驱逐非法移民，属于右翼。</p><p>德国右翼政党选择党民粹主义浓厚，要求加强边境管制，不要让难民进入德国境内，主张退出欧盟。</p><p>日本右翼分子指那些依然崇尚军国主义的保守顽固分子。日本最著名右翼政治家是石原慎太郎，参拜靖国神社，美化日本侵略历史；日本的左翼政治家则是强调对历史进行反省的，比如村山富市、福田康夫两位首相。</p><p>法西斯是极右翼主义。</p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ZZ左右 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS-JUC的基石</title>
      <link href="/posts/62475263.html"/>
      <url>/posts/62475263.html</url>
      
        <content type="html"><![CDATA[<h1>0.preface</h1><p>在JDK 5之前Java语言是靠synchronized关键字保证同步的，这会导致有锁</p><p>锁机制存在以下问题：</p><p>（1）在多线程竞争下，加锁、释放锁会导致比较多的上下文切换和调度延时，引起性能问题。</p><p>（2）一个线程持有锁会导致其它所有需要此锁的线程挂起。</p><p>（3）如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能风险。</p><p>volatile是不错的机制，但是volatile不能保证原子性。因此对于同步最终还是要回到锁机制上来。</p><p><em>独占锁是一种悲观锁，synchronized就是一种独占锁，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。乐观锁用到的机制就是CAS，Compare and Swap。</em></p><h1>1. CAS</h1><p>CAS，Compare And Swap，即比较并交换。Doug lea大神在同步组件中大量使用CAS技术鬼斧神工地实现了Java多线程的并发操作。整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8的版本中也调整为了CAS+Synchronized。毫不夸张的说CAS是整个JUC的基石。</p><p>当前的处理器基本都支持 CAS，只不过不同的厂家的实现不一样罢了。CAS 有三个操作数：内存值 V、旧的预期值 A、要修改的值 B。</p><p>当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。</p><p>如果我们不用 CAS，那么代码大致是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        i = j;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然这段代码在并发下是肯定有问题的，有可能线程 1 运行到了第 5 行正准备运行第 7 行，线程 2 运行了，把 i 修改为 10，线程切换回去，线程1由于先前已经满足第 5 行的 if 了，所以导致两个线程同时修改了变量 i。</p><p>解决办法也很简单，给 compareAndSwapInt 方法加锁同步就行了，这样，compareAndSwapInt 方法就变成了一个原子操作。CAS 也是一样的道理</p><p>CAS 也是通过 <strong>Unsafe</strong> 实现的，看下 Unsafe 下的三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object o, <span class="type">long</span> offset, Object expected, Object x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">int</span> expected, <span class="type">int</span> x)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object o, <span class="type">long</span> offset, <span class="type">long</span> expected, <span class="type">long</span> x)</span>;</span><br></pre></td></tr></table></figure><ul><li>o：目标Java变量引用。</li><li>offset：目标Java变量中的目标属性的偏移地址。</li><li>expected：目标Java变量中的目标属性的期望的当前值。</li><li>x：目标Java变量中的目标属性的目标更新值。</li></ul><p>JDK8中基于CAS扩展出来的方法有<code>getAndAddInt</code>、<code>getAndAddLong</code>、<code>getAndSetInt</code>、<code>getAndSetLong</code>、<code>getAndSetObject</code>，它们的作用都是：通过CAS设置新的值，返回旧的值。</p><blockquote><p>CAS是一条CPU的原子指令（cmpxchg指令），不会造成所谓的数据不一致问题，Unsafe提供的CAS方法（如compareAndSwapXXX）底层实现即为CPU指令cmpxchg。</p></blockquote><p>下面就以AtomicInteger为例来分析CAS的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicInteger</span> <span class="keyword">extends</span> <span class="title class_">Number</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于这段代码中出现的几个成员属性</strong>：</p><ol><li>Unsafe是 CAS 的核心类，前面已经讲过了。</li><li>valueOffset 表示的是变量值在内存中的偏移地址，因为 Unsafe 就是根据内存偏移地址获取数据的原值的。</li><li>value 是用 volatile 修饰的，这是非常关键的，保证多线程环境下看见的是同一个</li></ol><p>下面找一个方法 getAndIncrement 来研究一下 AtomicInteger 是如何实现的，比如我们常用的 addAndGet 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Unsafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndAddInt</span><span class="params">(Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4)</span> &#123;</span><br><span class="line">    <span class="type">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="built_in">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="built_in">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CPU提供了两种方法来实现多处理器的原子操作：总线加锁或者缓存加锁。</p><p><strong>总线加锁</strong>：总线加锁就是就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住,那么该处理器可以独占使用共享内存。但是这种处理方式显得有点儿霸道，不厚道，他把CPU和内存之间的通信锁住了，在锁定期间，其他处理器都不能其他内存地址的数据，其开销有点儿大。所以就有了缓存加锁。</p><p><strong>缓存加锁</strong>：其实针对于上面那种情况我们只需要保证在同一时刻对某个内存地址的操作是原子性的即可。缓存加锁就是缓存在内存区域的数据如果在加锁期间，当它执行锁操作写回内存时，处理器不在输出LOCK#信号，而是修改内部的内存地址，利用缓存一致性协议来保证原子性。缓存一致性机制可以保证同一个内存区域的数据仅能被一个处理器修改，也就是说当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行。</p><h1>2. CAS缺陷</h1><p>CAS虽然高效地解决了原子操作，但是还是存在一些缺陷的，主要表现在三个方法：循环时间太长、只能保证一个共享变量原子操作、ABA问题。</p><p><strong>循环时间太长</strong></p><p>如果CAS一直不成功呢？这种情况绝对有可能发生，如果自旋CAS长时间地不成功，则会给CPU带来非常大的开销。在JUC中有些地方就限制了CAS自旋的次数，例如BlockingQueue的SynchronousQueue。</p><p><strong>只能保证一个共享变量原子操作</strong></p><p>看了CAS的实现就知道这只能针对一个共享变量，如果是多个共享变量就只能使用锁了，当然如果你有办法把多个变量整成一个变量，利用CAS也不错。例如读写锁中state的高地位</p><p><strong>ABA问题</strong></p><p>CAS需要检查操作值有没有发生改变，如果没有发生改变则更新。但是存在这样一种情况：如果一个值原来是A，变成了B，然后又变成了A，那么在CAS检查的时候会发现没有改变，但是实质上它已经发生了改变，这就是所谓的ABA问题。对于ABA问题其解决方案是加上版本号，即在每个变量都加上一个版本号，每次改变时加1，即A —&gt; B —&gt; A，变成1A —&gt; 2B —&gt; 3A。</p><p>用一个例子来阐述ABA问题所带来的影响。</p><p>有如下链表</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291219465.png" alt="img"></p><p>假如我们想要把A替换为B，也就是compareAndSet(A,B)。线程1执行A替换为B的操作，线程2主要：A 、B出栈，然后C、A入栈。最终该链表如下：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291219651.png" alt="img"></p><p>完成后线程1发现仍然是A，那么compareAndSet(A,B)成功，但是这时会存在一个问题就是B.next = null，compareAndSet(A,B)后，会导致C丢失，该栈仅有一个B元素，平白无故把C给丢失了。</p><p>CAS的ABA隐患问题，解决方案则是版本号，Java提供了AtomicStampedReference来解决。AtomicStampedReference通过包装[E,Integer]的元组来对对象标记版本戳stamp，从而避免ABA问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> &#123;</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compareAndSet有四个参数，分别表示：预期引用、更新后的引用、预期标志、更新后的标志。 解预期的引用 == 当前引用，预期的标识 == 当前标识，如果更新后的引用和标志和当前的引用和标志相等则直接返回true，否则通过Pair生成一个新的pair对象与当前pair CAS替换。Pair为AtomicStampedReference的内部类，主要用于记录引用和版本戳信息（标识），定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Pair</span>&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">final</span> T reference;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> stamp;</span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Pair</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.reference = reference;</span><br><span class="line"><span class="built_in">this</span>.stamp = stamp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; Pair&lt;T&gt; <span class="title function_">of</span><span class="params">(T reference, <span class="type">int</span> stamp)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;T&gt;(reference, stamp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pair记录着对象的引用和版本戳，版本戳为int型，保持自增。同时Pair是一个不可变对象，其所有属性全部定义为final，对外提供一个of方法，该方法返回一个新建的Pari对象。pair对象定义为volatile，保证多线程环境下的可见性。在AtomicStampedReference中，大多方法都是通过调用Pair的of方法来产生一个新的Pair对象</p><p>下面我们将通过一个例子可以可以看到AtomicStampedReference和AtomicInteger的区别。我们定义两个线程，线程1负责将100 —&gt; 110 —&gt; 100，线程2执行 100 —&gt;120，看两者之间的区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">AtomicStampedReference</span> <span class="variable">atomicStampedReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AtomicInteger</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">at1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">110</span>);</span><br><span class="line">                atomicInteger.compareAndSet(<span class="number">110</span>,<span class="number">100</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">at2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);      <span class="comment">// at1,执行完</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;AtomicInteger:&quot;</span> + atomicInteger.compareAndSet(<span class="number">100</span>,<span class="number">120</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        at1.start();</span><br><span class="line">        at2.start();</span><br><span class="line"></span><br><span class="line">        at1.join();</span><br><span class="line">        at2.join();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//AtomicStampedReference</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tsf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//让 tsf2先获取stamp，导致预期时间戳不一致</span></span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 预期引用：100，更新后的引用：110，预期标识getStamp() 更新后的标识getStamp() + 1</span></span><br><span class="line">                atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">110</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">                atomicStampedReference.compareAndSet(<span class="number">110</span>,<span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">tsf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicStampedReference.getStamp();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">2</span>);      <span class="comment">//线程tsf1执行完</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;AtomicStampedReference:&quot;</span> +atomicStampedReference.compareAndSet(<span class="number">100</span>,<span class="number">120</span>,stamp,stamp + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        tsf1.start();</span><br><span class="line">        tsf2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AtomicInteger:true</span><br><span class="line">AtomicStampedReference:false</span><br></pre></td></tr></table></figure><p>运行结果充分展示了AtomicInteger的ABA问题和AtomicStampedReference解决ABA问题。</p><p>不过目前来说这个类比较”鸡肋”，因为大部分情况下 ABA 问题并不会影响程序并发的正确性，如果需要解决 ABA 问题，使用传统的互斥同步可能回避原子类更加高效。</p><h1>3. CAS与synchronized</h1><p>简单的来说 CAS 适用于写比较少的情况下（多读场景，冲突一般较少），synchronized 适用于写比较多的情况下（多写场景，冲突一般较多）</p><ul><li>对于资源竞争较少（线程冲突较轻）的情况，使用 Synchronized 同步锁进行线程阻塞和唤醒切换以及用户态内核态间的切换操作额外浪费消耗 cpu 资源；而 CAS 基于硬件实现，不需要进入内核，不需要切换线程，操作自旋几率较少，因此可以获得更高的性能。</li><li>对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。</li></ul><h1>4. 参考资料</h1><p><a href="https://mp.weixin.qq.com/s/1N4Z3Gp2qrlxtGtyiwiunw">https://mp.weixin.qq.com/s/1N4Z3Gp2qrlxtGtyiwiunw</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CAS </tag>
            
            <tag> Concurent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lock</title>
      <link href="/posts/27bd3430.html"/>
      <url>/posts/27bd3430.html</url>
      
        <content type="html"><![CDATA[<h1>0.preface</h1><h2 id="概述">概述</h2><blockquote><p>Lock 是 <strong>java.util.concurrent.locks</strong> 包 下的接口，Lock 实现提供了比 synchronized 关键字 更广泛的锁操作，它能以更优雅的方式处理线程同步问题。Lock提供了比synchronized更多的功能。</p><ol><li>Lock和ReadWriteLock是两大锁的根接口，<strong>Lock代表实现类是ReentrantLock（可重入锁），ReadWriteLock（读写锁）的代表实现类是ReentrantReadWriteLock</strong>。</li><li>Lock 接口支持那些语义不同（<strong>重入、公平</strong>等）的锁规则，可以在非阻塞式结构的上下文（包括 hand-over-hand 和锁重排算法）中使用这些规则。</li><li>ReadWriteLock 接口以类似方式定义了一些<strong>读取者可以共享而写入者独占的锁</strong>。此包只提供了一个实现 <strong>ReentrantReadWriteLock</strong>。</li><li>Lock是<strong>可重入锁，可中断锁</strong>，可以实现<strong>公平锁</strong>和<strong>读写锁</strong>，<strong>写锁为排它锁，读锁为共享锁</strong>。ReentrantLock也是一种排他锁</li></ol></blockquote><h2 id="与synchronized的区别">与synchronized的区别</h2><blockquote><ol><li><p>synchronized是关键字，是JVM层面的，而Lock是一个接口，是JDK提供的API。</p></li><li><p>当一个线程获取了synchronized锁，其他线程便只能一直等待直至占有锁的线程释放锁。当发生以下情况之一线程才会释放锁：<br>　　a.占有锁的线程执行完了该代码，然后释放对锁的占有。<br>　　b.占有锁线程执行发生异常，此时JVM会让线程自动释放锁。<br>　　c.占有锁线程进入 WAITING 状态从而释放锁，例如在该线程中调用wait()方法等。</p><p>但是如果占有锁的线程由于要等待IO或者因为其他原因（比如调用sleep方法）而使线程阻塞了，但是又没有释放锁，那么线程就只能一直等待，那么这时我们可能需要一种可以不让线程无期限的等待下去的方法，比如只等待一定的时间（tryLock(long time, TimeUnit unit)或者能被人为中断lockInterrup0tibly()，这种情况我们需要Lock。</p></li><li><p>当多个线程读写文件时，读操作和写操作会发生冲突现象，写操作和写操作也会发生冲突现象，但是读操作和读操作不会发生冲突现象，但是如果采用synchronized进行同步的话，就会导致当多个线程都只是进行读操作时也只有获取锁的线程才能进行读操作，其他线程只能等待锁释放后才能读，Lock则可以实现当多个线程都只是进行读操作时，线程之间不会发生冲突，例如：ReentrantReadWriteLock()。</p></li><li><p>可以通过Lock得知线程有没有成功获取到锁 (例如：ReentrantLock) ，但这个是synchronized无法办到的。</p></li><li><p>锁属性上的区别：synchronized是不可中断锁和非公平锁，ReentrantLock可以进行中断操作并别可以控制是否是公平锁。</p></li><li><p>synchronized能锁住方法和代码块，而Lock只能锁住代码块。</p></li><li><p>synchronized无法判断锁的状态，而Lock可以知道线程有没有拿到锁。</p></li><li><p>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时，此时Lock的性能要远远优于synchronized。</p></li></ol></blockquote><h1>1. Lock</h1><p>Lock是一个接口，方法定义如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void lock() // 如果锁可用就获得锁，如果锁不可用就阻塞直到锁释放，不能被中断</span><br><span class="line">void lockInterruptibly() // 和 lock()方法相似, 但阻塞的线程可中断，抛出 java.lang.InterruptedException异常</span><br><span class="line">boolean tryLock() // 非阻塞获取锁;尝试获取锁，如果成功返回true</span><br><span class="line">boolean tryLock(long timeout, TimeUnit timeUnit) //带有超时时间的获取锁方法</span><br><span class="line">void unlock() // 释放锁</span><br></pre></td></tr></table></figure><p>实现Lock接口的类有很多，以下为几个常见的锁实现</p><ul><li>ReentrantLock：表示重入锁，它是唯一一个实现了Lock接口的类。重入锁指的是线程在获得锁之后，再次获取该锁不需要阻塞，而是直接关联一次计数器增加重入次数</li><li>ReentrantReadWriteLock：重入读写锁，它实现了ReadWriteLock接口，在这个类中维护了两个锁，一个是ReadLock，一个是WriteLock，他们都分别实现了Lock接口。读写锁是一种适合读多写少的场景下解决线程安全问题的工具，基本原则是：<code>读和读不互斥、读和写互斥、写和写互斥</code>。也就是说涉及到影响数据变化的操作都会存在互斥。</li><li>StampedLock： stampedLock是JDK8引入的新的锁机制，可以简单认为是读写锁的一个改进版本，读写锁虽然通过分离读和写的功能使得读和读之间可以完全并发，但是读和写是有冲突的，如果大量的读线程存在，可能会引起写线程的饥饿。stampedLock是一种乐观的读策略，使得乐观锁完全不会阻塞写线程</li></ul><p><strong>lock()</strong></p><p>对于 Lock 接口而言，获取锁和释放锁都是显式的，不像 synchronized 那样是隐式的，Lock 不会像 synchronized 一样在异常时自动释放锁（synchronized 即使不写对应的代码也可以释放），lock 的加锁和释放锁都必须以代码的形式写出来。</p><p>使用 lock() 时必须由我们自己主动去释放锁，因此最佳实践是执行 lock() 后，首先在 try{} 中操作同步资源，如果有必要就用 catch{} 块捕获异常，然后在 finally{} 中释放锁，以保证发生异常时锁一定被释放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">    //获取到了被本锁保护的资源，处理任务</span><br><span class="line">    //捕获异常</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">    lock.unlock();   //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不遵守在 finally 里释放锁的规范，就会让 Lock 变得非常危险。 因为你不知道未来什么时候由于异常的发生，导致跳过了 unlock() 语句，使得这个锁永远不能被释放了，其他线程也无法再获得这个锁。 这就是 Lock 相比于 synchronized 的一个劣势，使用 synchronized 时不需要担心这个问题。</p><p>与此同时，lock() 方法不能被中断，这会带来很大的隐患：一旦陷入死锁，lock() 就会陷入永久等待，所以一般我们用 tryLock() 等其他更高级的方法来代替 lock()。</p><p><strong>tryLock()</strong></p><p>tryLock() 用来尝试获取锁，如果当前锁没有被其他线程占用，则获取成功，返回 true，否则返回 false，代表获取锁失败。 相比于 lock()，这样的方法显然功能更强大，我们可以根据是否能获取到锁来决定后续程序的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">if(lock.tryLock()) &#123;</span><br><span class="line">     try&#123;</span><br><span class="line">         //处理任务</span><br><span class="line">     &#125;finally&#123;</span><br><span class="line">         lock.unlock();   //释放锁</span><br><span class="line">     &#125; </span><br><span class="line">&#125;else &#123;</span><br><span class="line">    //如果不能获取锁，则做其他事情，比如等待几秒钟后重试，或者跳过这个任务</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>tryLock(long time, TimeUnit unit)</strong></p><p>tryLock() 的重载方法是 tryLock(long time, TimeUnit unit)，这个方法和 tryLock() 很类似，区别在于 tryLock(long time, TimeUnit unit) 方法会有一个超时时间，在拿不到锁时会等待一定的时间，如果在时间期限结束后，还获取不到锁，就会返回 false；如果一开始就获取锁或者等待期间内获取到锁，则返回 true。</p><p>这个方法解决了 lock() 方法容易发生死锁的问题，使用 tryLock(long time, TimeUnit unit) 时，在等待了一段指定的超时时间后，线程会主动放弃这把锁的获取，避免永久等待；在等待的期间，也可以随时中断线程，这就避免了死锁的发生。</p><p><strong>lockInterruptibly()</strong></p><p>这个方法的作用就是去获取锁，如果这个锁当前是可以获得的，那么这个方法会立刻返回，但是如果这个锁当前是不能获得的（被其他线程持有），那么当前线程便会开始等待，除非它等到了这把锁或者是在等待的过程中被中断了，否则这个线程便会一直在这里执行这行代码。一句话总结就是，除非当前线程在获取锁期间被中断，否则便会一直尝试获取直到获取到为止。</p><p>lockInterruptibly() 是可以响应中断的。相比于不能响应中断的 synchronized 锁，lockInterruptibly() 可以让程序更灵活，可以在获取锁的同时，保持对中断的响应。我们可以把这个方法理解为超时时间是无穷长的 tryLock(long time, TimeUnit unit)，因为 tryLock(long time, TimeUnit unit) 和 lockInterruptibly() 都能响应中断，只不过 lockInterruptibly() 永远不会超时。这个方法本身是会抛出 InterruptedException</p><p><strong>unlock()</strong></p><p>对于 ReentrantLock 而言，执行 unlock() 的时候，内部会把锁的“被持有计数器”减 1，直到减到 0 就代表当前这把锁已经完全释放了，如果减 1 后计数器不为 0，说明这把锁之前被“重入”了，那么锁并没有真正释放，仅仅是减少了持有的次数。</p><h1>2. synchronized 和 Lock 的区别</h1><ul><li><strong>用法区别</strong></li></ul><p>synchronized 关键字可以加在方法上，不需要指定锁对象，也可以新建一个同步代码块并且自定义 monitor 锁对象。</p><p>Lock 接口必须显示用 Lock 锁对象开始加锁 lock() 和解锁 unlock()，并且一般会在 finally 块中确保用 unlock() 来解锁，以防发生死锁。</p><p>synchronized 的加解锁是隐式的，尤其是抛异常的时候也能保证释放锁，但是 Java 代码中并没有相关的体现。</p><ul><li><strong>加解锁顺序不同</strong></li></ul><p>对于 Lock 而言如果有多把 Lock 锁，Lock 可以不完全按照加锁的反序解锁，比如我们可以先获取 Lock1 锁，再获取 Lock2 锁，解锁时则先解锁 Lock1，再解锁 Lock2，加解锁有一定的灵活度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock1.lock();</span><br><span class="line">lock2.lock();</span><br><span class="line">...</span><br><span class="line">lock1.unlock();</span><br><span class="line">lock2.unlock();</span><br></pre></td></tr></table></figure><p>但是 synchronized 无法做到，synchronized 解锁的顺序和加锁的顺序必须完全相反</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized(obj1)&#123;</span><br><span class="line">    synchronized(obj2)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在这里，顺序就是先对 obj1 加锁，然后对 obj2 加锁，然后对 obj2 解锁，最后解锁 obj1。 这是因为 synchronized 加解锁是由 JVM 实现的，在执行完 synchronized 块后会自动解锁，所以会按照 synchronized 的嵌套顺序加解锁，不能自行控制。</p><ul><li><strong>synchronized 锁不够灵活</strong></li></ul><p>一旦 synchronized 锁已经被某个线程获得了，此时其他线程如果还想获得，那它只能被阻塞，直到持有锁的线程运行完毕或者发生异常从而释放这个锁。如果持有锁的线程持有很长时间才释放，那么整个程序的运行效率就会降低，而且如果持有锁的线程永远不释放锁，那么尝试获取锁的线程只能永远等下去。</p><p>相比之下，Lock 类在等锁的过程中，如果使用的是 lockInterruptibly 方法，那么如果觉得等待的时间太长了不想再继续等待，可以中断退出，也可以用 tryLock() 等方法尝试获取锁，如果获取不到锁也可以做别的事，更加灵活。</p><ul><li><strong>synchronized 锁只能同时被一个线程拥有，但是 Lock 锁没有这个限制</strong></li></ul><p>例如在读写锁中的读锁，是可以同时被多个线程持有的，可是 synchronized 做不到。</p><ul><li><strong>原理区别</strong></li></ul><p>synchronized 是内置锁，由 JVM 实现获取锁和释放锁的原理，还分为偏向锁、轻量级锁、重量级锁。</p><ul><li><strong>是否可以设置公平/非公平</strong></li></ul><p>公平锁是指多个线程在等待同一个锁时，根据先来后到的原则依次获得锁。ReentrantLock 等 Lock 实现类可以根据自己的需要来设置公平或非公平，synchronized 则不能设置。</p><ul><li><strong>性能区别</strong></li></ul><p>在 Java 5 以及之前，synchronized 的性能比较低，但是到了 Java 6 以后，发生了变化，因为 JDK 对 synchronized 进行了很多优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，所以后期的 Java 版本里的 synchronized 的性能并不比 Lock 差。</p><p>Lock 根据实现不同，有不同的原理，例如 ReentrantLock 内部是通过 AQS 来获取和释放锁的。</p><h1>3. 如何选择synchronized 和 Lock</h1><ul><li>如果能不用最好既不使用 Lock 也不使用 synchronized。因为在许多情况下你可以使用 java.util.concurrent 包中的机制，它会为你处理所有的加锁和解锁操作，也就是推荐优先使用工具类来加解锁。</li><li>如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全。</li><li>如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock。</li></ul><h1>4. 公平锁和非公平锁</h1><p>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p><p>非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p><p>直接用语言描述可能有点抽象，下面用一个例子来讲述一下公平锁和非公平锁。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291216691.png" alt="img"></p><p>如上图所示，假设有一口水井，有管理员看守，管理员有一把锁，只有拿到锁的人才能够打水，打完水要把锁还给管理员。每个过来打水的人都要管理员的允许并拿到锁之后才能去打水，如果前面有人正在打水，那么这个想要打水的人就必须排队。管理员会查看下一个要去打水的人是不是队伍里排最前面的人，如果是的话，才会给你锁让你去打水；如果你不是排第一的人，就必须去队尾排队，这就是公平锁。</p><p>但是对于非公平锁，管理员对打水的人没有要求。即使等待队伍里有排队等待的人，但如果在上一个人刚打完水把锁还给管理员而且管理员还没有允许等待队伍里下一个人去打水时，刚好来了一个插队的人，这个插队的人是可以直接从管理员那里拿到锁去打水，不需要排队，原本排队等待的人只能继续等待。如下图所示：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291216516.png" alt="img"></p><p><strong>非公平锁插队的时机</strong></p><p>假设当前线程在请求获取锁的时候，恰巧前一个持有锁的线程释放了这把锁，那么当前申请锁的线程就可以不顾已经等待的线程而选择立刻插队。但是如果当前线程请求的时候，前一个线程并没有在那一时刻释放锁，那么当前线程还是一样会进入等待队列。</p><blockquote><p>非公平是ReentrantLock的默认策略.</p></blockquote><p><strong>为什么要有非公平锁</strong></p><p>假设线程 A 持有一把锁，线程 B 请求这把锁，由于线程 A 已经持有这把锁了，所以线程 B 会陷入等待，在等待的时候线程 B 会被挂起，也就是进入阻塞状态。</p><p>那么当线程 A 释放锁的时候，本该轮到线程 B 苏醒获取锁，但如果此时突然有一个线程 C 插队请求这把锁，那么根据非公平的策略，会把这把锁给线程 C。</p><p>这是因为唤醒线程 B 是需要很大开销的，很有可能在唤醒之前，线程 C 已经拿到了这把锁并且执行完任务释放了这把锁。相比于等待唤醒线程 B 的漫长过程，插队的行为会让线程 C 本身跳过陷入阻塞的过程，如果在锁代码中执行的内容不多的话，线程 C 就可以很快完成任务，并且在线程 B 被完全唤醒之前，就把这个锁交出去。</p><p>这样是一个双赢的局面，对于线程 C 而言，不需要等待提高了它的效率，而对于线程 B 而言，它获得锁的时间并没有推迟，因为等它被唤醒的时候，线程 C 早就释放锁了，因为线程 C 的执行速度相比于线程 B 的唤醒速度，是很快的。</p><p>所以 Java 设计者设计非公平锁，是为了提高整体的运行效率。</p><p>公平锁的优点在于各个线程公平平等，每个线程等待一段时间后，都有执行的机会，而它的缺点就在于整体执行速度更慢，吞吐量更小。 相反非公平锁的优势就在于整体执行速度更快，吞吐量更大，但同时也可能产生线程饥饿问题，也就是说如果一直有线程插队，那么在等待队列中的线程可能长时间得不到运行。</p><p><strong>tryLock()方法是不公平的</strong> 针对 tryLock() 方法，它不遵守设定的公平原则。 例如，当有线程执行 tryLock() 方法的时候，一旦有线程释放了锁，那么这个正在 tryLock 的线程就能获取到锁，即使设置的是公平锁模式，即使在它之前已经有其他正在等待队列中等待的线程，简单地说就是 tryLock 可以插队。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean tryLock() &#123;</span><br><span class="line">    return sync.nonfairTryAcquire(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5. 参考资料</h1><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=260">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=260</a></p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=261">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=261</a></p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=262">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=262</a></p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=265">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=265</a></p><p><a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=266">https://kaiwu.lagou.com/course/courseInfo.htm?courseId=16#/detail/pc?id=266</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lock </tag>
            
            <tag> Concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读写锁-ReadWriteLock</title>
      <link href="/posts/3f178489.html"/>
      <url>/posts/3f178489.html</url>
      
        <content type="html"><![CDATA[<p>在没有读写锁之前，我们假设使用普通的 ReentrantLock，那么虽然我们保证了线程安全，但是也浪费了一定的资源，因为如果多个读操作同时进行，其实并没有线程安全问题，我们可以允许让多个读操作并行，以便提高程序效率。 但是写操作不是线程安全的，如果多个线程同时写，或者在写的同时进行读操作，便会造成线程安全问题。</p><p>我们的读写锁就解决了这样的问题，它设定了一套规则，既可以保证多个线程同时读的效率，同时又可以保证有写入操作时的线程安全。 整体思路是它有两把锁，第 1 把锁是写锁，获得写锁之后，既可以读数据又可以修改数据，而第 2 把锁是读锁，获得读锁之后，只能查看数据，不能修改数据。读锁可以被多个线程同时持有，所以多个线程可以同时查看数据。 在读的地方合理使用读锁，在写的地方合理使用写锁，灵活控制，可以提高程序的执行效率。</p><h1>1. 读写锁的获取规则</h1><p>我们在使用读写锁时遵守下面的获取规则：</p><ul><li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请读锁，可以申请成功。</li><li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁，因为读写不能同时操作。</li><li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，都必须等待之前的线程释放写锁，同样也因为读写不能同时，并且两个线程不应该同时写。</li></ul><p>所以我们用一句话总结：要么是一个或多个线程同时有读锁，要么是一个线程有写锁，但是两者不会同时出现。也可以总结为：读读共享、其他都互斥（写写互斥、读写互斥、写读互斥）。</p><p>Reader 线程正在读取，Writer 线程正在等待</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291208374.jpg" alt="img"></p><p>Writer 线程正在写入，Reader 线程正在等待</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291208795.jpg" alt="img"></p><p>相比于 ReentrantLock 适用于一般场合，ReadWriteLock 适用于读多写少的情况，合理使用可以进一步提高并发效率。</p><h1>2. 读锁的插队策略</h1><p>ReentrantReadWriteLock的Sync实现中中定义了两个抽象方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Acquires and releases use the same code for fair and</span><br><span class="line"> * nonfair locks, but differ in whether/how they allow barging</span><br><span class="line"> * when queues are non-empty.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns true if the current thread, when trying to acquire</span><br><span class="line"> * the read lock, and otherwise eligible to do so, should block</span><br><span class="line"> * because of policy for overtaking other waiting threads.</span><br><span class="line"> */</span><br><span class="line">abstract boolean readerShouldBlock();</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns true if the current thread, when trying to acquire</span><br><span class="line"> * the write lock, and otherwise eligible to do so, should block</span><br><span class="line"> * because of policy for overtaking other waiting threads.</span><br><span class="line"> */</span><br><span class="line">abstract boolean writerShouldBlock();</span><br></pre></td></tr></table></figure><p>FairSync的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final boolean writerShouldBlock() &#123;</span><br><span class="line">  return hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br><span class="line">final boolean readerShouldBlock() &#123;</span><br><span class="line">  return hasQueuedPredecessors();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在公平锁的情况下，只要等待队列中有线程在等待，也就是 hasQueuedPredecessors() 返回 true 的时候，那么 writer 和 reader 都会 block，也就是一律不允许插队，都乖乖去排队，这也符合公平锁的思想。</strong></p><p>NonfairSync的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">final boolean writerShouldBlock() &#123;</span><br><span class="line">  return false; // writers can always barge</span><br><span class="line">&#125;</span><br><span class="line">final boolean readerShouldBlock() &#123;</span><br><span class="line">  /* As a heuristic to avoid indefinite writer starvation,</span><br><span class="line">   * block if the thread that momentarily appears to be head</span><br><span class="line">   * of queue, if one exists, is a waiting writer.  This is</span><br><span class="line">   * only a probabilistic effect since a new reader will not</span><br><span class="line">   * block if there is a waiting writer behind other enabled</span><br><span class="line">   * readers that have not yet drained from the queue.</span><br><span class="line">   */</span><br><span class="line">  return apparentlyFirstQueuedIsExclusive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 writerShouldBlock() 这个方法中始终返回 false，可以看出，对于想获取写锁的线程而言，由于返回值是 false，所以它是随时可以插队的，这就和我们的 ReentrantLock 的设计思想是一样的，但是读锁却不一样。</p><p>假设线程 2 和线程 4 正在同时读取，线程 3 想要写入，但是由于线程 2 和线程 4 已经持有读锁了，所以线程 3 就进入等待队列进行等待。此时，线程 5 突然跑过来想要插队获取读锁：</p><p>面对这种情况有两种应对策略：</p><ul><li><strong>允许插队</strong> 由于现在有线程在读，而线程 5 又不会特别增加它们读的负担，因为线程们可以共用这把锁，所以第一种策略就是让线程 5 直接加入到线程 2 和线程 4 一起去读取。这种策略看上去增加了效率，但是有一个严重的问题，那就是如果想要读取的线程不停地增加，比如线程 6，那么线程 6 也可以插队，这就会导致读锁长时间内不会被释放，导致线程 3 长时间内拿不到写锁，也就是那个需要拿到写锁的线程会陷入“饥饿”状态，它将在长时间内得不到执行。</li><li><strong>不允许插队</strong> 这种策略认为由于线程 3 已经提前等待了，所以虽然线程 5 如果直接插队成功，可以提高效率，但是我们依然让线程 5 去排队等待：按照这种策略线程 5 会被放入等待队列中，并且排在线程 3 的后面，让线程 3 优先于线程 5 执行，这样可以避免“饥饿”状态，这对于程序的健壮性是很有好处的，直到线程 3 运行完毕，线程 5 才有机会运行，这样谁都不会等待太久的时间。</li></ul><p><strong>所以我们可以看出，即便是非公平锁，只要等待队列的头结点是尝试获取写锁的线程，那么读锁依然是不能插队的，目的是避免“饥饿”。</strong></p><p>验证代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class ReadLockJumpQueue &#123;</span><br><span class="line"></span><br><span class="line">    private static final ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();</span><br><span class="line">    private static final ReentrantReadWriteLock.ReadLock readLock = reentrantReadWriteLock.readLock();</span><br><span class="line">    private static final ReentrantReadWriteLock.WriteLock writeLock = reentrantReadWriteLock.writeLock();</span><br><span class="line"></span><br><span class="line">    private static void read() &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;得到读锁，正在读取&quot;);</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;释放读锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void write() &#123;</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;得到写锁，正在写入&quot;);</span><br><span class="line">            Thread.sleep(2000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + &quot;释放写锁&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new Thread(() -&gt; read(), &quot;Thread-2&quot;).start();</span><br><span class="line">        new Thread(() -&gt; read(), &quot;Thread-4&quot;).start();</span><br><span class="line">        new Thread(() -&gt; write(), &quot;Thread-3&quot;).start();</span><br><span class="line">        new Thread(() -&gt; read(), &quot;Thread-5&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>3. 锁降级</h1><p>锁降级的目的是保证本线程中对data修改了之后，在释放写锁之后数据仍然是一致的，即其他线程是不能获取写锁的。</p><blockquote><p>锁降级是为了让当前线程感知到数据的变化。</p></blockquote><p>ReentrantReadWriteLock的javadoc中有一段示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class CachedData &#123;</span><br><span class="line"> </span><br><span class="line">    Object data;</span><br><span class="line">    volatile boolean cacheValid;</span><br><span class="line">    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"> </span><br><span class="line">    void processCachedData() &#123;</span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">        if (!cacheValid) &#123;</span><br><span class="line">            //在获取写锁之前，必须首先释放读锁。</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">            rwl.writeLock().lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                //这里需要再次判断数据的有效性,因为在我们释放读锁和获取写锁的空隙之内，可能有其他线程修改了数据。</span><br><span class="line">                if (!cacheValid) &#123;</span><br><span class="line">                    data = new Object();</span><br><span class="line">                    cacheValid = true;</span><br><span class="line">                &#125;</span><br><span class="line">                //在不释放写锁的情况下，直接获取读锁，这就是读写锁的降级。</span><br><span class="line">                rwl.readLock().lock();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                //释放了写锁，但是依然持有读锁</span><br><span class="line">                rwl.writeLock().unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        try &#123;</span><br><span class="line">            System.out.println(data);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放读锁</span><br><span class="line">            rwl.readLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果先释放写锁，再释放读锁，可能在获取之前会有其他线程获取到写锁，阻塞读锁的获取，当前线程就无法感知数据的变化了，所以要先持有写锁保证数据无变化，在获取读锁，然后释放写锁</p><p><strong>不支持锁升级</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    upgrade();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public static void upgrade() &#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    System.out.println(&quot;获取到了读锁&quot;);</span><br><span class="line">    rwl.writeLock().lock();</span><br><span class="line">    System.out.println(&quot;成功升级&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码会打印出“获取到了读锁”，但是却不会打印出“成功升级”，因为 ReentrantReadWriteLock 不支持读锁升级到写锁。</p><p>我们知道读写锁的特点是如果线程都申请读锁，是可以多个线程同时持有的，可是如果是写锁，只能有一个线程持有，并且不可能存在读锁和写锁同时持有的情况。</p><p>正是因为不可能有读锁和写锁同时持有的情况，所以升级写锁的过程中，需要等到所有的读锁都释放，此时才能进行升级。</p><p>假设线程 A 和 B 都想升级到写锁，那么对于线程 A 而言，它需要等待其他所有线程，包括线程 B 在内释放读锁。而线程 B 也需要等待所有的线程，包括线程 A 释放读锁。这就是一种非常典型的死锁的情况。谁都愿不愿意率先释放掉自己手中的锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> ReadWriteLock </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AQS-AbstractQueuedSynchronizer</title>
      <link href="/posts/fa9a5ea7.html"/>
      <url>/posts/fa9a5ea7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>​谈到并发，我们不得不说<code>AQS(AbstractQueuedSynchronizer)</code>，所谓的<code>AQS</code>即是抽象的队列式的同步器，内部定义了很多锁相关的方法，我们熟知的<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>等都是基于<code>AQS</code>来实现的。</p><p>​AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，<strong>那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制</strong>，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列(**虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系)。**AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点(Node)来实现锁的分配。 AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p></blockquote><h1>1. 锁原理 - 信号量 vs 管程</h1><p>在并发编程领域，有两大核心问题：<strong>互斥</strong>与<strong>同步</strong>，互斥即同一时刻只允许一个线程访问共享资源，同步，即线程之间如何通信、协作，一般这两大问题可以通过<strong>信号量</strong>和<strong>管程</strong>来解决。</p><h2 id="1-1-信号量">1.1. 信号量</h2><p>信号量（Semaphore）是操作系统提供的一种进程间常见的通信方式，主要用来协调并发程序对共享资源的访问，操作系统可以保证对信号量操作的<strong>原子性</strong>。它是怎么实现的呢。</p><ul><li>信号量由一个共享整型变量 S 和两个原子操作 PV 组成，S 只能通过 P 和 V 操作来改变</li><li>P 操作：即请求资源，意味着 S 要减 1，如果 S &lt; 0, 则表示没有资源了，此时线程要进入等待队列（同步队列）等待</li><li>V 操作: 即释放资源，意味着 S 要加 1， 如果 S 小于等于 0，说明等待队列里有线程，此时就需要唤醒线程。</li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203055.png" alt="img"></p><p>信号量机制的引入解决了进程同步和互斥问题，但信号量的大量同步操作分散在各个进程中不便于管理，还有可能导致系统死锁。如：生产者消费者问题中将P、V颠倒可能死锁，另外条件越多，需要的信号量就越多，需要更加谨慎地处理信号量之间的处理顺序，否则很容易造成死锁现象。</p><p>基于信号量给编程带来的隐患，于是有了提出了对开发者更加友好的并发编程模型-<strong>管程</strong></p><h2 id="1-2-管程">1.2. 管程</h2><p>Dijkstra 于 1971 年提出：把所有进程对某一种<strong>临界资源</strong>的同步操作都集中起来，构成一个所谓的秘书进程。凡要访问该临界资源的进程，都需先报告秘书，由秘书来实现诸进程对同一临界资源的<strong>互斥</strong>使用，这种机制就是管程。</p><p>管程是一种在信号量机制上进行改进的并发编程模型，解决了信号量在临界区的 PV 操作上配对的麻烦，把配对的 PV 操作集中在一起而形成的并发编程方法理论，极大降低了使用和理解成本。</p><p>管程由四部分组成：</p><ol><li>管程内部的共享变量。</li><li>管程内部的条件变量。</li><li>管程内部并行执行的进程。</li><li>对于局部与管程内部的共享数据设置初始值的语句。</li></ol><p>由此可见，管程就是一个对象监视器。任何线程想要访问该资源（共享变量），就要排队进入监控范围。进入之后，接受检查，不符合条件，则要继续等待，直到被通知，然后继续进入监视器。</p><p>需要注意的事，信号量和管程两者是等价的，信号量可以实现管程，管程也可以实现信号量，只是两者的表现形式不同而已，管程对开发者更加友好。</p><p>两者的区别如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203146.png" alt="img"></p><p>管程为了解决信号量在临界区的 PV 操作上的配对的麻烦，把配对的 PV 操作集中在一起，并且加入了条件变量的概念，使得在多条件下线程间的同步实现变得更加简单。</p><p>怎么理解管程中的入口等待队列，共享变量，条件变量等概念，有时候技术上的概念较难理解，我们可以借助生活中的场景来帮助我们理解，就以我们的就医场景为例来简单说明一下，正常的就医流程如下：</p><ol><li>病人去挂号后，去侯诊室等待叫号</li><li>叫到自己时，就可以进入就诊室就诊了</li><li>就诊时，有两种情况，一种是医生很快就确定病人的病，并作出诊断，诊断完成后，就通知下一位病人进来就诊，一种是医生无法确定病因，需要病人去做个验血 / CT 检查才能确定病情，于是病人就先去验个血 / CT</li><li>病人验完血 / 做完 CT 后，重新取号，等待叫号（进入入口等待队列）</li><li>病人等到自己的号,病人又重新拿着验血 / CT 报告去找医生就诊</li></ol><p>整个流程如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291205162.png" alt="img"></p><p>那么管程是如何解决<strong>互斥</strong>和<strong>同步</strong>的呢</p><p>首先来看<strong>互斥</strong>，上文中医生即<strong>共享资源</strong>（也即共享变量），就诊室即为<strong>临界区</strong>，病人即<strong>线程</strong>，任何病人如果想要访问临界区，必须首先获取共享资源（即医生），入口一次只允许一个线程经过，在共享资源被占有的情况下，如果再有线程想占有共享资源，就需要到等待队列去等候，等到获取共享资源的线程释放资源后，等待队列中的线程就可以去竞争共享资源了，这样就解决了互斥问题，所以本质上管程是通过将共享资源及其对共享资源的操作（线程安全地获取和释放）封装起来来保证互斥性的。</p><p>再来看<strong>同步</strong>，同步是通过文中的条件变量及其等待队列实现的，同步的实现分两种情况</p><ol><li>病人进入就诊室后，无需做验血 / CT 等操作，于是医生诊断完成后，就会释放共享资源（解锁）去通知（notify，notifyAll）入口等待队列的下一个病人，下一个病人听到叫号后就能看医生了。</li><li>如果病人进入就诊室后需要做验血 / CT 等操作，会去验血 / CT 队列（条件队列）排队， 同时释放共享变量（医生），通知入口等待队列的其他病人（线程）去获取共享变量（医生），获得许可的线程执行完临界区的逻辑后会唤醒条件变量等待队列中的线程，将它放到入口等待队列中 ，等到其获取共享变量（医生）时，即可进入入口（临界区）处理。</li></ol><p>在 Java 里，锁大多是依赖于管程来实现的，以大家熟悉的内置锁 synchronized 为例，它的实现原理如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203818.png" alt="img"></p><p>可以看到 synchronized 锁也是基于管程实现的，只不过它只有且只有一个条件变量（就是锁对象本身）而已，这也是为什么JDK 要实现 Lock 锁的原因之一，Lock 支持多个条件变量。</p><h1>2. AQS</h1><p>AQS全称为AbstractQueuedSynchronizer，它提供了一个FIFO队列，可以看成是一个用来实现同步锁以及其他涉及到同步功能的核心组件，常见的有:ReentrantLock、CountDownLatch等。</p><p>AQS是一个抽象类，主要是通过继承的方式来使用，它本身没有实现任何的同步接口，仅仅是定义了同步状态的获取以及释放的方法来提供自定义的同步组件。</p><p>从使用层面来说，AQS的功能分为两种：独占和共享</p><ul><li>独占锁，每次只能有一个线程持有锁，比如前面给大家演示的ReentrantLock就是以独占方式实现的互斥锁</li><li>共享锁，允许多个线程同时获取锁，并发访问共享资源，比如ReentrantReadWriteLock</li></ul><h2 id="2-1-AQS的内部实现">2.1. AQS的内部实现</h2><p>AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。</p><p>CLH：Craig、Landin and Hagersten队列，是单向链表，AQS中的队列是CLH变体的虚拟双向队列（FIFO），AQS是通过将每条请求共享资源的线程封装成一个节点来实现锁的分配。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291205760.png" alt="img"></p><p>AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State值的修改。</p><p>以实现独占锁为例（即当前资源只能被一个线程占有），其实现原理如下：state 初始化 0，在多线程条件下，线程要执行临界区的代码，必须首先获取 state，某个线程获取成功之后， state 加 1，其他线程再获取的话由于共享资源已被占用，所以会到 FIFO 等待队列去等待，等占有 state 的线程执行完临界区的代码释放资源( state 减 1)后，会唤醒 FIFO 中的下一个等待线程（head 中的下一个结点）去获取 state。</p><p>state 由于是多线程共享变量，所以必须定义成 volatile，以保证 state 的可见性, 同时虽然 volatile 能保证可见性，但不能保证原子性，所以 AQS 提供了对 state 的原子操作方法，保证了线程安全。</p><p>如果当前线程竞争锁失败，那么AQS会把当前线程以及等待状态信息构造成一个Node加入到同步队列中，同时再阻塞该线程。当获取锁的线程释放锁以后，会从队列中唤醒一个阻塞的节点(线程)。</p><p>AQS 中实现的 FIFO 队列（CLH 队列）其实是双向链表实现的，由 head, tail 节点表示，head 结点代表当前占用的线程，其他节点由于暂时获取不到锁所以依次排队等待锁释放</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203563.png" alt="img"></p><p>我们再看下AQS的另外几个核心属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双向链表的首尾结点，代表入口等待队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步状态值（锁的数量）</span></span><br><span class="line"><span class="comment"> * 当state=0时，表示无锁状态</span></span><br><span class="line"><span class="comment"> * 当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承自父类AbstractOwnableSynchronizer的属性，</span></span><br><span class="line"><span class="comment"> * The current owner of exclusive mode synchronization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><p>AQS中维护了一个名为<strong>state</strong>的字段，意为同步状态，是由Volatile修饰的，用于展示当前临界资源的获锁情况。我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203629.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203142.jpg" alt="img"></p><p>除此之外，AQS内部还定义了一个静态类Node，表示CLH队列的每一个结点，该结点的作用是对每一个等待获取资源做了封装，包含了需要同步的线程本身、线程等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="comment">/**SHARED、EXCLUSIVE用于设置nextWaiter，用于表示当前节点是共享的，还是互斥的，分别用于共享锁和独占锁 */</span></span><br><span class="line"><span class="comment">/** 表示线程以共享的模式等待锁 **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"><span class="comment">/** 表示线程正在以独占的方式等待锁 **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** int类型的常量CANCELLED、SIGNAL、CONDITION、PROPAGATE用于设置waitStatus，用于在ConditionObject中使用，可以实现await/signal模型。 **/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  SIGNAL(-1) ：线程的后继线程正/已被阻塞，当该线程release或cancel时要唤醒这个后继线程(unpark)</span></span><br><span class="line"><span class="comment"> *  CANCELLED(1)：因为超时或中断，该线程已经被取消</span></span><br><span class="line"><span class="comment"> *  CONDITION(-2)：表明该线程被处于条件队列，就是因为调用了&gt;- Condition.await而被阻塞</span></span><br><span class="line"><span class="comment"> *  PROPAGATE(-3)：这个值是在共享锁的时候会用到，唤醒了一个节点，会尝试唤醒下一个节点，如果当前节点未阻塞（阻塞前就获得了锁）,那么当前节点的状态会被设置成-3， 当前线程处在SHARED情况下</span></span><br><span class="line"><span class="comment"> *  0：0代表无状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前驱节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后继节点</span></span><br><span class="line"><span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待的线程</span></span><br><span class="line"><span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储在condition队列中的后继节点</span></span><br><span class="line">Node nextWaiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将线程构造成一个Node，添加到等待队列</span></span><br><span class="line">Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line"><span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line"><span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法会在Condition队列使用</span></span><br><span class="line">Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line"><span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line"><span class="built_in">this</span>.thread = thread;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里面定义了一个表示当前Node结点等待状态的字段<code>waitStatus</code>，该字段的取值包含了CANCELLED(1)、SIGNAL(-1)、CONDITION(-2)、PROPAGATE(-3)、0，这五个值代表了不同的特定场景：</p><ul><li><strong>CANCELLED</strong>：表示当前结点已取消调度。当timeout或被中断（响应中断的情况下），会触发变更为此状态，进入该状态后的结点将不会再变化。</li><li><strong>SIGNAL</strong>：表示后继结点在等待当前结点唤醒。<strong>后继结点入队时，会将前继结点的状态更新为SIGNAL</strong>（记住这个-1的值，因为后面我们讲的时候经常会提到）</li><li><strong>CONDITION</strong>：表示结点等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。(注：<strong>Condition</strong>是AQS的一个组件，后面会细说)</li><li><strong>PROPAGATE</strong>：共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li><strong>0</strong>：新结点入队时的默认状态。</li></ul><p>也就是说，当waitStatus为<strong>负值表示结点处于有效等待状态，为正值的时候表示结点已被取消。</strong></p><h2 id="2-2-释放锁以及添加线程对于队列的变化">2.2. 释放锁以及添加线程对于队列的变化</h2><p><strong>添加节点</strong></p><p>当出现锁竞争以及释放锁的时候，AQS同步队列中的节点会发生变化，首先看一下添加节点的场景。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203194.png" alt="img"></p><p>这里会涉及到两个变化</p><ul><li>新的线程封装成Node节点追加到同步队列中，设置prev节点以及修改当前节点的前置节点的next节点指向自己</li><li>通过CAS将tail重新指向新的尾部节点</li></ul><p><strong>释放锁移除节点</strong></p><p>head节点表示获取锁成功的节点，当头结点在释放同步状态时，会唤醒后继节点，如果后继节点获得锁成功，会把自己设置为头结点，节点的变化过程如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203236.png" alt="img"></p><p>这个过程也是涉及到两个变化</p><ul><li>修改head节点指向下一个获得锁的节点</li><li>新的获得锁的节点，将prev的指针指向null</li></ul><p>这里有一个小的变化，就是设置head节点不需要用CAS，原因是设置head节点是由获得锁的线程来完成的，而同步锁只能由一个线程获得，所以不需要CAS保证，只需要把head节点设置为原首节点的后继节点，并且断开原head节点的next引用即可</p><p>接下来，我们通过ReentrantLock的加锁和解锁流程，来看看线程是如何加入等待队列的，以及队列中每个节点的状态值是如何变化的。</p><h1>3. ReentrantLock</h1><p>以ReentrantLock为例，来分析AQS在重入锁中的使用。毕竟单纯分析AQS没有太多的含义。先理解这个类图，可以方便我们理解AQS的原理</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203461.png" alt="img"></p><p>我们先初略看下ReentrantLock的核心结构</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span>, java.io.Serializable &#123;</span><br><span class="line">    <span class="comment">//继承自AQS</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">       <span class="comment">// ..... 非公平锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">FairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">       <span class="comment">// ..... 公平锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync是一个静态内部类，它继承了AQS这个抽象类，前面说过AQS是一个同步工具，主要用来实现同步控制。我们在利用这个工具的时候，会继承它来实现同步控制功能。 通过进一步分析，发现Sync这个类有两个具体的实现，分别是<code>NofairSync(非公平锁)</code>,<code>FailSync(公平锁)</code>.</p><ul><li>公平锁 表示所有线程严格按照FIFO来获取锁</li><li>非公平锁 表示可以存在抢占锁的功能，也就是说不管当前队列上是否存在其他线程等待，新线程都有机会抢占锁</li></ul><h2 id="3-1-ReentrantLock-lock">3.1. ReentrantLock.lock()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">sync.lock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来的分析仍然以非公平锁作为主要分析逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 通过cas操作来修改state状态，表示争抢锁的操作</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">// 设置当前获得锁状态的线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 尝试去获取锁</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于这里是非公平锁，所以调用lock方法时，先去通过cas去抢占锁，期望是0，表示没有线程获得锁</li><li>如果抢占锁成功，保存获得锁成功的当前线程<code>setExclusiveOwnerThread(Thread.currentThread());</code></li><li>如果 CAS 设置 state 为 1 失败（代表获取锁失败），调用AQS的acquire来走锁竞争逻辑</li></ul><p>我们假定有两个线程A和B同时竞争锁，A进来先抢占到锁，此时的AQS模型图就类似这样：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203801.png" alt="img"></p><p><strong>compareAndSetState(0, 1)</strong></p><ul><li>当state=0时，表示无锁状态</li><li>当state&gt;0时，表示已经有线程获得了锁，也就是state=1，但是因为ReentrantLock允许重入，所以同一个线程多次获得同步锁的时候，state会递增，比如重入5次，那么state=5。 而在释放锁的时候，同样需要释放5次直到state=0其他线程才有资格获得锁</li></ul><p><strong>acquire(1)</strong></p><p>acquire是AQS中的方法，如果CAS操作未能成功，说明state已经不为0，此时继续acquire(1)操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要逻辑是</p><ul><li>通过tryAcquire尝试获取独占锁，如果成功返回true，失败返回false</li><li>如果tryAcquire失败，则会通过addWaiter方法将当前线程封装成Node添加到AQS队列尾部，并标记为独占模式</li><li>acquireQueued，将Node作为参数**，通过自旋去尝试获取锁。**</li><li>selfInterrupt：自我中断，就是既拿不到锁，又在等待时被中断了，线程就会进行自我中断selfInterrupt()，将中断补上。</li></ul><p>我们一个个来看源码，并结合上面的两个线程来做场景分析。</p><p><strong>NonfairSync.tryAcquire</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的作用是尝试获取锁，如果成功返回true，不成功返回false。它是重写AQS类中的tryAcquire方法</p><p><strong>nonfairTryAcquire(acquires)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 获得当前执行的线程</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 获得state的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// state=0说明当前是无锁状态</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过cas操作来替换state的值改为1</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 保存当前获得锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果是同一个线程来获得锁，则直接增加重入次数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此段代码可知锁的获取主要分两种情况</p><ol><li>state 为 0 时，代表锁已经被释放，可以去获取，于是使用 CAS 去重新获取锁资源，如果获取成功，则代表竞争锁成功，使用 setExclusiveOwnerThread(current) 记录下此时占有锁的线程，看到这里的 CAS，大家应该不难理解为啥当前实现是非公平锁了，因为队列中的线程与新线程都可以 CAS 获取锁啊，新来的线程不需要排队</li><li>如果 state 不为 0，代表之前已有线程占有了锁，如果此时的线程依然是之前占有锁的线程（current == getExclusiveOwnerThread() 为 true），代表此线程再一次占有了锁（可重入锁），此时更新 state，记录下锁被占有的次数（锁的重入次数）,这里的 setState 方法不需要使用 CAS 更新，因为此时的锁就是当前线程占有的，其他线程没有机会进入这段代码执行。所以此时更新 state 是线程安全的。</li></ol><p>当然，因为之前锁已经被线程A占领了，所以这时候<code>tryAcquire</code>会返回false，继续下面的流程。</p><p><strong>addWaiter(Node.EXCLUSIVE)</strong></p><p>当tryAcquire方法获取锁失败以后，则会先调用addWaiter将当前线程封装成Node，然后添加到AQS队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装成Node，并且mode为独占锁</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// tail不为空的情况，说明队列中存在节点数据</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前线程的Node的prev节点指向tail</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过cas讲node添加到AQS队列</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// cas成功，把旧的tail的next指针指向新的tail</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// tail=null，将node添加到同步队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先会创建一个和当前线程绑定的<code>Node</code>节点，<code>Node</code>为双向链表。此时等待队列中的<code>tail</code>指针为空，直接调用<code>enq(node)</code>方法将当前线程加入等待队列尾部，然后返回当前结点的前驱结点，</p><p><strong>enq</strong></p><p>enq就是通过自旋操作把当前节点加入到队列中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 如果是第一次添加到队列，那么tail=null</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// CAS的方式创建一个空的Node作为头结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                <span class="comment">// 此时队列中只一个头结点，所以tail也指向它</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进行第二次循环时，tail不为null，进入else区域。将当前线程的Node结点的prev指向tail，然后使用CAS将tail指向Node</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// t此时指向tail,所以可以CAS成功，将tail重新指向Node。此时t为更新前的tail的值，即指向空的头结点，t.next=node，就将头结点的后续结点指向Node，返回头结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一遍循环时，tail指针为空，初始化一个Node结点，并把head和tail结点都指向它，然后第二次循环进来之后，tail结点不为空了，就将当前的结点加入到tail结点后面，也就是这样：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203096.png" alt="img"></p><p>如果此时有另一个线程C进来的话，发现锁已经被A拿走了，然后队列里已经有了线程B，那么线程C就只能乖乖排到线程B的后面去，</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291203149.png" alt="img"></p><p><strong>acquireQueued</strong></p><p>通过tryAcquire()和addWaiter()，我们的线程还是没有拿到资源，并且还被排到了队列的尾部。此时为了拿到资源，能做的事无非两个：</p><p><strong>1. 循环让线程再抢资源。但仔细一推敲就知道不合理，因为如果有多个线程都参与的话，你抢我也抢只会降低系统性能</strong></p><p><strong>2. 进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源</strong></p><p>毫无疑问，选择2更加靠谱，acquireQueued方法做的也是这样的处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记是否会被中断</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取prev节点,若为null即刻抛出NullPointException</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 只有前驱为head才有资格进行锁的抢夺</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 获取锁成功后就不需要再进行同步操作了,获取锁成功的线程作为新的head节点</span></span><br><span class="line">                <span class="comment">// 凡是head节点,head.thread与head.prev永远为null, 但是head.next不为null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果获取锁失败，则根据节点的waitStatus决定是否需要挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 则执行挂起,待下次唤醒的时候检测中断的标志</span></span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果抛出异常则取消锁的获取,则将此线程对应的node的waitStatus改为CANCEL，进行出队(sync queue)操作</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">// 稍后详细分析</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>shouldParkAfterFailedAcquire</strong></p><p>从上面的分析可以看出，只有队列的第二个节点可以有机会争用锁，如果成功获取锁，则此节点晋升为头节点。对于第三个及以后的节点，<code>if (p == head)</code>条件不成立，首先进行<code>shouldParkAfterFailedAcquire(p, node)</code>操作 。</p><p><code>shouldParkAfterFailedAcquire</code>方法是判断一个争用锁的线程是否应该被阻塞。它首先判断一个节点的前置节点的状态是否为Node.SIGNAL，如果是，是说明此节点已经将状态设置-“如果锁释放，则应当通知它”，所以它可以安全的阻塞了，返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果是SIGNAL状态，意味着当前线程需要被unpark唤醒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果前节点的状态大于0，即为CANCELLED状态时，则会从前节点开始逐步循环找到一个没有被“CANCELLED”节点设置为当前节点的前节点，返回false。在下次循环执行shouldParkAfterFailedAcquire时，返回true。这个操作实际是把队列中CANCELLED的节点剔除掉。</span></span><br><span class="line"><span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment"> * indicate retry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">pred.next = node;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果前继节点为“0”或者“共享锁”状态，则设置前继节点为SIGNAL状态。</span></span><br><span class="line">compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquireQueued</code>方法的流程是这样的：</p><ol><li>CAS自旋，先判断当前传入的Node的前结点是否为head结点，是的话就尝试获取锁，获取锁成功的话就把当前结点置为head，之前的head置为null(方便GC)，然后返回</li><li>如果前驱结点不是head或者加锁失败的话，就调用<code>shouldParkAfterFailedAcquire</code>，将前驱节点的<strong>waitStatus</strong>变为了<strong>SIGNAL=-1</strong>，最后执行<code>parkAndChecknIterrupt</code>方法，调用<code>LockSupport.park()</code>挂起当前线程，<code>parkAndCheckInterrupt</code>在挂起线程后会判断线程是否被中断，如果被中断的话，就会重新跑<code>acquireQueued</code>方法的CAS自旋操作，直到获取资源。</li></ol><blockquote><p>LockSupport.park方法会让当前线程进入waitting状态，在这种状态下，线程被唤醒的情况有两种，一是被unpark()，二是被interrupt()，所以，如果是第二种情况的话，需要返回被中断的标志，然后在<code>acquire</code>顶层方法的窗口那里自我中断补上</p></blockquote><p><strong>parkAndCheckInterrupt</strong></p><p>如果shouldParkAfterFailedAcquire返回了true，则会执行：<code>parkAndCheckInterrupt()</code>方法，它是通过LockSupport.park(this)将当前线程挂起到WATING状态，它需要等待一个中断、unpark方法来唤醒它，通过这样一种FIFO的机制的等待，来实现了Lock的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">parkAndCheckInterrupt</span><span class="params">()</span> &#123;</span><br><span class="line">    LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>LockSupport</strong> LockSupport类是Java6引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public native void unpark(Thread jthread);  </span><br><span class="line">public native void park(boolean isAbsolute, long time);  </span><br></pre></td></tr></table></figure><p>unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。 permit相当于0/1的开关，默认是0，调用一次unpark就加1变成了1.调用一次park会消费permit，又会变成0。 如果再调用一次park会阻塞，因为permit已经是0了。直到permit变成1.这时调用unpark会把permit设置为1.每个线程都有一个相关的permit，permit最多只有一个，重复调用unpark不会累积</p></blockquote><p>此时，因为线程A还未释放锁，所以线程B状态都是被挂起的，</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202237.png" alt="img"></p><p><strong>cancelAcquire</strong></p><p>最后看一下cancelAcquire 方法，如果线程自旋中因为异常等原因获取锁最终失败，则会调用此方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cancelAcquire</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 将无效节点过滤</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">// 设置该节点不关联任何线程，也就是虚节点（由于线程要被取消了，所以将 thread 线程清掉）</span></span><br><span class="line">    node.thread = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过前驱节点，跳过取消状态的node</span></span><br><span class="line">    <span class="comment">// 将 node 的 pre 指向之前第一个非取消状态的结点（即跳过所有取消状态的结点）,waitStatus &gt; 0 表示当前结点状态为取消状态</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取过滤后的前驱节点的后继节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">predNext</span> <span class="operator">=</span> pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把当前node的状态设置为CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，将从后往前的第一个非取消状态的节点设置为尾节点</span></span><br><span class="line">    <span class="comment">// 更新失败的话，则进入else，如果更新成功，将tail的后继节点设置为null</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果当前节点取消了，就要把当前节点的前驱节点指向当前节点的后继节点，</span></span><br><span class="line">        <span class="comment">// 但是我们之前也说了，要唤醒或阻塞结点，须在其前驱节点的状态为 SIGNAL 的条件才能操作，</span></span><br><span class="line">        <span class="comment">// 所以在设置 pre 的 next 节点时要保证 pre 结点的状态为 SIGNAL</span></span><br><span class="line">        <span class="comment">// 如果当前节点不是head的后继节点，1:判断当前节点前驱节点的是否为SIGNAL，2:如果不是，则把前驱节点设置为SINGAL看是否成功</span></span><br><span class="line">    <span class="comment">// 如果1和2中有一个为true，再判断当前节点的线程是否为null</span></span><br><span class="line">    <span class="comment">// 如果上述条件都满足，把当前节点的前驱节点的后继指针指向当前节点的后继节点</span></span><br><span class="line">        <span class="type">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点是head的后继节点，或者上述条件不满足，那就唤醒当前节点的后继节点</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前的流程：</p><ol><li>获取当前节点的前驱节点，如果前驱节点的状态是CANCELLED，那就一直往前遍历，找到第一个waitStatus &lt;= 0的节点，将找到的Pred节点和当前Node关联，将当前Node设置为CANCELLED。</li><li>根据当前节点的位置，考虑以下三种情况：</li><li><ol><li>当前节点是尾节点。</li><li>当前节点是Head的后继节点。</li><li>当前节点不是Head的后继节点，也不是尾节点。</li></ol></li></ol><p>1、首先第一步当前节点之前有取消结点时，则逻辑如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202444.png" alt="img"></p><p>2、如果当前结点既非头结点的后继结点，也非尾结点，即步骤 1 所示，则最终结果如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202781.png" alt="img"></p><p>shouldParkAfterFailedAcquire方法会将 node 的 pre 指向之前 waitStatus 为非 CANCEL 的节点，所以当 T4 执行这段代码时，会变成如下情况</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202896.png" alt="img"></p><p>可以看到此时中间的两个 CANCEL 节点不可达了，会被 GC</p><p>3、如果当前结点为 tail 结点，则结果如下，这种情况下当前结点不可达，会被 GC</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202155.png" alt="img"></p><p>4、如果当前结点为 head 的后继结点时，如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202332.png" alt="img"></p><p>结果中的 CANCEL 结点同样会在 tail 结点自旋调用 shouldParkAfterFailedAcquire 后不可达，如下</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202067.png" alt="img"></p><p>通过上面的流程，我们对于CANCELLED节点状态的产生和变化已经有了大致的了解，但是为什么所有的变化都是对Next指针进行了操作，而没有对Prev指针进行操作呢？什么情况下会对Prev指针进行操作？</p><ol><li>执行cancelAcquire的时候，当前节点的前置节点可能已经从队列中出去了（已经执行过Try代码块中的shouldParkAfterFailedAcquire方法了），如果此时修改Prev指针，有可能会导致Prev指向另一个已经移除队列的Node，因此这块变化Prev指针不安全。</li><li>shouldParkAfterFailedAcquire方法中，会执行下面的代码，其实就是在处理Prev指针。shouldParkAfterFailedAcquire是获取锁失败的情况下才会执行，进入该方法后，说明共享资源已被获取，当前节点之前的节点都不会出现变化，因此这个时候变更Prev指针比较安全。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    node.prev = pred = pred.prev;</span><br><span class="line">&#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>到这里，加锁的流程就分析完了，</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202674.png" alt="img"></p><h2 id="3-2-ReentrantLock-unlock">3.2. ReentrantLock.unlock</h2><p>加锁的过程分析完以后，再来分析一下释放锁的过程，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用release方法，这个方法里面做两件事：</p><ol><li>释放锁 ；</li><li>唤醒park的线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的判断条件为什么是h != null &amp;&amp; h.waitStatus != 0？</p><blockquote><p>（1）h == null Head还没初始化。初始情况下，head == null，第一个节点入队，Head会被初始化一个虚拟节点。所以说，这里如果还没来得及入队，就会出现head == null 的情况。 （2）h != null &amp;&amp; waitStatus == 0 表明后继节点对应的线程仍在运行中，不需要唤醒。 （3）h != null &amp;&amp; waitStatus &lt; 0 表明后继节点可能被阻塞了，需要唤醒。</p></blockquote><p><strong>tryRelease</strong></p><p>这个动作可以认为就是一个设置锁状态的操作，而且是将状态减掉传入的参数值（参数是1），如果结果状态为0，就将排它锁的Owner设置为null，以使得其它的线程有机会进行执行。</p><p>在排它锁中，加锁的时候状态会增加1（当然可以自己修改这个值），在解锁的时候减掉1，同一个锁，在可以重入后，可能会被叠加为2、3、4这些值，只有unlock()的次数与lock()的次数对应才会将Owner线程设置为空，而且也只有这种情况下才会返回true。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 这里是将锁的数量减</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 由于重入的关系，不是每次释放锁c都等于0，直到最后一次释放锁时，才会把当前线程释放</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时AQS中的数据就会变成这样：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202359.png" alt="img"></p><p>完全释放资源后，当前线程要做的就是唤醒CLH队列中第一个在等待资源的线程，也就是head结点后面的线程，此时调用的方法是<code>unparkSuccessor()</code>，</p><p><strong>unparkSuccessor</strong></p><p>在方法unparkSuccessor(Node)中，就意味着真正要释放锁了，它传入的是head节点（head节点是占用锁的节点），当前线程被释放之后，需要唤醒下一个节点的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment"> * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment"> * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line"><span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 将head结点的状态置为0</span></span><br><span class="line">compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 判断后继节点是否为空或者是否是取消状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line"><span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点, 至于为什么从尾部开始向前遍历，因为在doAcquireInterruptibly.cancelAcquire方法的处理过程中只设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的</span></span><br><span class="line">        <span class="comment">// PS:没懂</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line"><span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">s = t;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 内部首先会发生的动作是获取head节点的next节点，如果获取到的节点不为空，则直接通过：“LockSupport.unpark()”方法来释放对应的被挂起的线程，这样一来将会有一个节点唤醒后继续进入循环进一步尝试tryAcquire()方法来获取锁</span></span><br><span class="line"><span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法的逻辑很简单，就是先将head的结点状态置为0，避免下面找结点的时候再找到head，然后找到队列中最前面的有效结点，然后唤醒，我们假设这个时候线程A已经释放锁，那么此时队列中排最前边竞争锁的线程B就会被唤醒。然后被唤醒的线程B就会尝试用CAS获取锁，回到<code>acquireQueued</code>方法的逻辑，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">for (;;) &#123;</span><br><span class="line">    final Node p = node.predecessor();</span><br><span class="line">    if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">        setHead(node);</span><br><span class="line">        p.next = null; // help GC</span><br><span class="line">        failed = false;</span><br><span class="line">        return interrupted;</span><br><span class="line">    &#125;</span><br><span class="line">    if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">        parkAndCheckInterrupt())</span><br><span class="line">        interrupted = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程B获取锁之后，会把当前结点赋值给head，然后原先的前驱结点 (也就是原来的head结点) 去掉引用链，方便回收，这样一来，线程B获取锁的整个过程就完成了，此时AQS的数据就会变成这样：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202310.png" alt="img"></p><p>**为什么要从后往前找第一个非Cancelled的节点呢？**原因如下，通过addWaiter方法节点入队并不是原子操作，也就是说，<code>node.prev = pred; compareAndSetTail(pred, node)</code> 这两个地方可以看作Tail入队的原子操作，但是此时<code>pred.next = node;</code>还没执行，如果这个时候执行了<code>unparkSuccessor</code>方法，就没办法从前往后找了，所以需要从后往前找。还有一点原因，在产生CANCELLED状态节点的时候，先断开的是Next指针，Prev指针并未断开，因此也是必须要从后往前遍历才能够遍历完全部的Node。</p><p>综上所述，如果是从前往后找，由于极端情况下入队的非原子操作和CANCELLED节点产生过程中断开Next指针的操作，可能会导致无法遍历所有的节点。所以，唤醒对应的线程后，对应的线程就会继续往下执行。继续执行acquireQueued方法以后，中断如何处理？</p><h1>4. <strong>公平锁实现原理</strong></h1><p>公平锁在加锁的时候，会先判断<code>AQS</code>等待队列中是存在节点，如果存在节点则会直接入队等待，具体代码如下.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">    final Thread current = Thread.currentThread();</span><br><span class="line">    int c = getState();</span><br><span class="line">    if (c == 0) &#123;</span><br><span class="line">        if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(0, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        int nextc = c + acquires;</span><br><span class="line">        if (nextc &lt; 0)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会先判断<code>state</code>值，如果不为0且获取锁的线程不是当前线程，直接返回false代表获取锁失败，被加入等待队列。如果是当前线程则可重入获取锁。</p><p>如果<code>state=0</code>则代表此时没有线程持有锁，执行<code>hasQueuedPredecessors()</code>判断<code>AQS</code>等待队列中是否有元素存在，如果存在其他等待线程，那么自己也会加入到等待队列尾部，做到真正的先来后到，有序加锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断<code>head</code>是否等于<code>tail</code>，如果队列中只有一个<code>Node</code>节点，那么<code>head</code>会等于<code>tail</code>，接着判断<code>head</code>的后置节点，这里肯定会是<code>null</code>，如果此<code>Node</code>节点对应的线程和当前的线程是同一个线程，那么则会返回<code>false</code>，代表没有等待节点或者等待节点就是当前线程创建的<code>Node</code>节点。此时当前线程会尝试获取锁。</p><p>如果<code>head</code>和<code>tail</code>不相等，说明队列中有等待线程创建的节点，此时直接返回<code>true</code>，如果只有一个节点，而此节点的线程和当前线程不一致，也会返回<code>true</code></p><h1>5. <strong>Condition实现原理</strong></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Condition`是在`java 1.5`中才出现的，它用来替代传统的`Object`的`wait()`、`notify()`实现线程间的协作，相比使用`Object`的`wait()`、`notify()`，使用`Condition`中的`await()`、`signal()`这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用`Condition</span><br></pre></td></tr></table></figure><p>其中<code>AbstractQueueSynchronizer</code>中实现了<code>Condition</code>中的方法，主要对外提供<code>awaite(Object.wait())</code>和<code>signal(Object.notify())</code>调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionDemo &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ReentrantLock lock = new ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line">        Thread tA = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;线程A加锁成功&quot;);</span><br><span class="line">                System.out.println(&quot;线程A执行await被挂起&quot;);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(&quot;线程A被唤醒成功&quot;);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(&quot;线程A释放锁成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread tB = new Thread(() -&gt; &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            try &#123;</span><br><span class="line">                System.out.println(&quot;线程B加锁成功&quot;);</span><br><span class="line">                condition.signal();</span><br><span class="line">                System.out.println(&quot;线程B唤醒线程A&quot;);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">                System.out.println(&quot;线程B释放锁成功&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行main函数后结果输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">线程A加锁成功</span><br><span class="line">线程A执行await被挂起</span><br><span class="line">线程B加锁成功</span><br><span class="line">线程B唤醒线程A</span><br><span class="line">线程B释放锁成功</span><br><span class="line">线程A被唤醒成功</span><br><span class="line">线程A释放锁成功</span><br></pre></td></tr></table></figure><p>代码执行的结果很容易理解，线程A先获取锁，然后调用<code>await()</code>方法挂起当前线程并释放锁，线程B这时候拿到锁，然后调用<code>signal</code>唤醒线程A。</p><p>毫无疑问，这两个方法让线程的状态发生了变化，我们仔细来研究一下</p><p>翻看AQS的源码，我们会发现Condition中定义了两个属性<code>firstWaiter</code>和<code>lastWaiter</code>，前面说了，AQS中包含了一个FIFO的CLH等待队列，每个Conditon对象就包含这样一个等待队列，而这两个属性分别表示的是等待队列中的首尾结点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionObject implements Condition, java.io.Serializable &#123;</span><br><span class="line">/** First node of condition queue. */</span><br><span class="line">private transient Node firstWaiter;</span><br><span class="line">/** Last node of condition queue. */</span><br><span class="line">private transient Node lastWaiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：Condition当中的等待队列和AQS主体的同步等待队列是分开的，两个队列虽然结构体相同，但是作用域是分开的</strong></p><p><strong>await</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public final void await() throws InterruptedException &#123;</span><br><span class="line">    if (Thread.interrupted())</span><br><span class="line">        throw new InterruptedException();</span><br><span class="line">    // 将当前线程加入到等待队列中</span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    // 完全释放占有的资源，并返回资源数</span><br><span class="line">    int savedState = fullyRelease(node);</span><br><span class="line">    int interruptMode = 0;</span><br><span class="line">    // 循环判断当前结点是不是在Condition的队列中，是的话挂起</span><br><span class="line">    while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个线程调用<strong>Condition.await()方法，将会以当前线程构造结点，这个结点的<code>waitStatus</code>赋值为Node.CONDITION</strong>，也就是-2，并将结点从尾部加入等待队列，然后尾部结点就会指向这个新增的结点，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Node addConditionWaiter() &#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    // If lastWaiter is cancelled, clean out.</span><br><span class="line">    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = new Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    if (t == null)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    else</span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依然用上面的demo来演示，此时，线程A获取锁并调用**Condition.await()**方法后，AQS内部的数据结构会变成这样：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202771.png" alt="img"></p><p>在Condition队列中插入对应的结点后，线程A会释放所持有的资源，走到while循环那层逻辑，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (!isOnSyncQueue(node)) &#123;</span><br><span class="line"> LockSupport.park(this);</span><br><span class="line"> if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>isOnSyncQueue</code>方法的会判断当前的线程节点是不是在同步队列中，这个时候此结点还在Condition队列中，所以该方法返回false，这样的话循环会一直持续下去，线程被挂起，等待被唤醒，此时，线程A的流程暂时停止了。</p><p>当线程A调用<code>await()</code>方法挂起的时候，线程B获取到了线程A释放的资源，然后执行<code>signal()</code>方法：</p><p><strong>signal</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final void signal() &#123;</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    if (first != null)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断当前线程是否为获取锁的线程，如果不是则直接抛出异常。接着调用<code>doSignal()</code>方法来唤醒线程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private void doSignal(Node first) &#123;</span><br><span class="line">// 循环，从队列一直往后找不为空的首结点</span><br><span class="line">    do &#123;</span><br><span class="line">        if ( (firstWaiter = first.nextWaiter) == null)</span><br><span class="line">            lastWaiter = null;</span><br><span class="line">        first.nextWaiter = null;</span><br><span class="line">    &#125; while (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != null);</span><br><span class="line">&#125;</span><br><span class="line">final boolean transferForSignal(Node node) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * CAS循环，将结点的waitStatus改为0</span><br><span class="line">     */</span><br><span class="line">    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * 此方法会把当前结点加入到等待队列中，并返回前驱结点</span><br><span class="line">     */</span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    int ws = p.waitStatus;</span><br><span class="line">    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从<code>doSignal</code>的代码中可以看出，这时候程序寻找的是Condition等待队列中首结点firstWaiter的结点，此时该结点指向的是线程A的结点，所以之后的流程作用的都是线程A的结点。</p><p>这里分析下<code>transferForSignal</code>方法，先通过CAS自旋将结点<strong>waitStatus</strong>改为0，然后就把结点放入到同步队列 (此队列不是Condition的等待队列) 中，然后再用CAS将同步队列中该结点的前驱结点waitStatus改为Node.SIGNAL，也就是-1，</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202343.png" alt="img"></p><p>回到<code>await()</code>方法，当线程A的结点被加入同步队列中时，<code>isOnSyncQueue()</code>会返回true，跳出循环，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">while (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(this);</span><br><span class="line">        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    if (node.nextWaiter != null) // clean up if cancelled</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    if (interruptMode != 0)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure><p>接着执行<code>acquireQueued()</code>方法，尝试重新获取锁，如果获取锁失败继续会被挂起，直到另外线程释放锁才被唤醒。</p><p>所以，当线程B释放完锁后，线程A被唤醒，继续尝试获取锁，至此流程结束。</p><p>对于这整个通信过程，我们可以画一张流程图展示下：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202299.png" alt="img"></p><h1>6. JUC中的应用场景</h1><p>除了上边ReentrantLock的可重入性的应用，AQS作为并发编程的框架，为很多其他同步工具提供了良好的解决方案。下面列出了JUC中的几种同步工具，大体介绍一下AQS的应用场景：</p><table><thead><tr><th style="text-align:left">同步工具</th><th style="text-align:left">同步工具与AQS的关联</th></tr></thead><tbody><tr><td style="text-align:left">ReentrantLock</td><td style="text-align:left">使用AQS保存锁重复持有的次数。当一个线程获取锁时，ReentrantLock记录当前获得锁的线程标识，用于检测是否重复获取，以及错误线程试图解锁操作时异常情况的处理。</td></tr><tr><td style="text-align:left">ReentrantReadWriteLock</td><td style="text-align:left">使用AQS同步状态中的16位保存写锁持有的次数，剩下的16位用于保存读锁的持有次数。</td></tr><tr><td style="text-align:left">Semaphore</td><td style="text-align:left">使用AQS同步状态来保存信号量的当前计数。tryRelease会增加计数，acquireShared会减少计数。</td></tr><tr><td style="text-align:left">CountDownLatch</td><td style="text-align:left">使用AQS同步状态来表示计数。计数为0时，所有的Acquire操作（CountDownLatch的await方法）才可以通过。</td></tr><tr><td style="text-align:left">ThreadPoolExecutor</td><td style="text-align:left">Worker利用AQS同步状态实现对独占线程变量的设置（tryAcquire和tryRelease）。</td></tr></tbody></table><h2 id="6-1-ReentrantReadWriteLock">6.1. ReentrantReadWriteLock</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>从代码中获取读写状态可以看出其是把state（int32位）字段分成高16位与低16位，其中高16位表示读锁个数，低16位表示写锁个数，如下图所示</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406291202343.jpg" alt="img"></p><h2 id="6-2-自定义同步工具">6.2. 自定义同步工具</h2><p>了解AQS基本原理以后，按照上面所说的AQS知识点，自己实现一个同步工具</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeeLock</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span> <span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span> <span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span> <span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span> <span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeeMain</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">LeeLock</span> <span class="variable">leeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeeLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span> <span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    leeLock.lock();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    leeLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码每次运行结果都会是20000。通过简单的几行代码就能实现同步功能，这就是AQS的强大之处。</p><h1>7. 参考资料</h1><p><a href="https://segmentfault.com/a/1190000017372067">https://segmentfault.com/a/1190000017372067</a></p><p><a href="https://mp.weixin.qq.com/s/sA01gxC4EbgypCsQt5pVog">https://mp.weixin.qq.com/s/sA01gxC4EbgypCsQt5pVog</a></p><p><a href="https://mp.weixin.qq.com/s/y_e3ciU-hiqlb5vseuOFyw">https://mp.weixin.qq.com/s/y_e3ciU-hiqlb5vseuOFyw</a></p><p><a href="https://mp.weixin.qq.com/s/tMI6qV_ItuTqlKZiUnAlmg">https://mp.weixin.qq.com/s/tMI6qV_ItuTqlKZiUnAlmg</a></p><p><a href="https://juejin.cn/post/6844904146127044622">【深入AQS原理】我画了35张图就是为了让你深入 AQS - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Concurrent </tag>
            
            <tag> AQS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>半一致性读</title>
      <link href="/posts/713f9ce4.html"/>
      <url>/posts/713f9ce4.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>复制自https://zhuanlan.zhihu.com/p/150248692</p></blockquote><h1>1. <strong>什么是半一致性读？</strong></h1><p>先看下官方的描述：</p><ul><li>是一种用在 Update 语句中的读操作（一致性读）的优化，是在 RC 事务隔离级别下与一致性读的结合。</li><li>当 Update 语句的 where 条件中匹配到的记录已经上锁，会再次去 InnoDB 引擎层读取对应的行记录，判断是否真的需要上锁（第一次需要由 InnoDB 先返回一个最新的已提交版本）。</li><li>只在 RC 事务隔离级别下或者是设置了 innodb_locks_unsafe_for_binlog=1 的情况下才会发生。</li><li>innodb_locks_unsafe_for_binlog 参数在 8.0 版本中已被去除（可见，这是一个可能会导致数据不一致的参数，官方也不建议使用了）。</li></ul><blockquote><p>所谓半一致性读就是，一个update语句，如果读到一行已经加锁的记录，此时InnoDB返回记录最近提交的版本，由MySQL上层判断此版本是否满足update的where条件。若满足(需要更新)，则MySQL会重新发起一次读操作，此时会读取行的最新版本(并加锁)！</p></blockquote><h1>2. 案例1</h1><p>我们先通过 2 个测试案例来观察半一致性读会对事务产生哪些影响。</p><p><strong>准备数据</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; desc t;</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">| Field | Type | Null | Key | Default | Extra |</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">| id    | int  | YES  |     | NULL    |       |</span><br><span class="line">| sal   | int  | YES  |     | NULL    |       |</span><br><span class="line">+-------+------+------+-----+---------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | sal  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |  100 |</span><br><span class="line">|    2 |  200 |</span><br><span class="line">|    3 |  300 |</span><br><span class="line">|    4 |  400 |</span><br><span class="line">|    5 |  500 |</span><br><span class="line">|    6 |  600 |</span><br><span class="line">|    7 |  700 |</span><br><span class="line">|    8 |  800 |</span><br><span class="line">|    9 |  900 |</span><br><span class="line">|   10 | 1000 |</span><br><span class="line">+------+------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show variables like &#x27;transaction_isolation&#x27;;</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| Variable_name         | Value          |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">| transaction_isolation | READ-COMMITTED |</span><br><span class="line">+-----------------------+----------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 设置参数innodb_status_output_locks=on，否则看不到IX锁</span><br><span class="line">mysql&gt; show variables like &#x27;innodb_status_output_locks&#x27;;</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| Variable_name              | Value |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">| innodb_status_output_locks | ON    |</span><br><span class="line">+----------------------------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><p><strong>session1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t where id &gt; 3 and id &lt; 6 for update;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | sal  |</span><br><span class="line">+------+------+</span><br><span class="line">|    4 |  400 |</span><br><span class="line">|    5 |  500 |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>查看事务状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line">...</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 6699539</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 6699526 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 3</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421163334236736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421163334235880, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 6699538, ACTIVE 3 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 9, OS thread handle 139688312157952, query id 36 localhost root starting</span><br><span class="line">show engine innodb status</span><br><span class="line">TABLE LOCK table `ds0`.`t` trx id 6699538 lock mode IX</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699538 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b903; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663621; asc    f6!;;</span><br><span class="line"> 2: len 7; hex 82000001170110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000190; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b904; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663622; asc    f6&quot;;;</span><br><span class="line"> 2: len 7; hex 810000010e0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 4: len 4; hex 800001f4; asc     ;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>线程9的事务6699538，获取到了1个表级插入意向锁IX，2个记录锁，对应id=4,id=5的这两条记录</p><p><strong>session2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t where id = 7 for update;</span><br><span class="line"># 等待锁</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 6699540</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 6699526 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421163334236736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421163334235880, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 6699539, ACTIVE 10 sec fetching rows</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 1 row lock(s)</span><br><span class="line">MySQL thread id 11, OS thread handle 139688309319424, query id 78 localhost root executing</span><br><span class="line">select * from t where id = 7 for update</span><br><span class="line">------- TRX HAS BEEN WAITING 10 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699539 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b903; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663621; asc    f6!;;</span><br><span class="line"> 2: len 7; hex 82000001170110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000190; asc     ;;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">TABLE LOCK table `ds0`.`t` trx id 6699539 lock mode IX</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699539 lock_mode X locks rec but not gap</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699539 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b903; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663621; asc    f6!;;</span><br><span class="line"> 2: len 7; hex 82000001170110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000190; asc     ;;</span><br><span class="line"></span><br><span class="line">---TRANSACTION 6699538, ACTIVE 523 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 9, OS thread handle 139688312157952, query id 79 localhost root starting</span><br><span class="line">show engine innodb status</span><br><span class="line">TABLE LOCK table `ds0`.`t` trx id 6699538 lock mode IX</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699538 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b903; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663621; asc    f6!;;</span><br><span class="line"> 2: len 7; hex 82000001170110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000190; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b904; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663622; asc    f6&quot;;;</span><br><span class="line"> 2: len 7; hex 810000010e0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 4: len 4; hex 800001f4; asc     ;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到线程11的6699539事务正在请求并等待1个记录锁，id=4的这条记录。<strong>为什么？</strong></p><p>innodb锁等待超时后再观察一次，线程11的事务6699539的事务仍然没有结束，对t表持有IX锁，并且仍然在等待id=4的行锁释放</p><p><strong>session3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update t set sal = sal + 1 where id = 7;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line">Rows matched: 1  Changed: 1  Warnings: 0</span><br></pre></td></tr></table></figure><p>在 Session 1 事务仍然未结束的情况下，Session 3 的事务未被阻塞，可以正常执行。</p><p>查看3个语句的执行计划</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t where id&gt;3 and id&lt;6 for update;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |    11.11 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain select * from t where id = 7 for update;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |    10.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; explain update t set sal=sal+1 where id=7;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | UPDATE      | t     | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   10 |   100.00 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>由于 t 表没有索引，执行计划必然是走全表扫描，也就是每条被读取到的记录，都会上行锁。那为何 Session 1 只锁了id=4，id=5 的这两条，并没有锁全表呢？而同样是请求 id=7 的记录，为何 Session 2 无法获取锁资源，Session 3 却能成功执行？也许大家从上面的锁分析可以很快得到结论，由于 Session 1 只占用了 id=4、id=5 的行锁，那么 Session 3 去请求 id=7 的自然不会有冲突（似乎挺有道理）</p><p>那么 Session 2 对 id=7 的请求，为何会被锁定呢？</p><p>带着这些疑问，我们继续看第 2 个案例。</p><h1>3. 案例2</h1><p>这次 Session 1 执行的 Select 语句不带 where 条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t for update;</span><br><span class="line">+------+------+</span><br><span class="line">| id   | sal  |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 |  100 |</span><br><span class="line">|    2 |  200 |</span><br><span class="line">|    3 |  300 |</span><br><span class="line">|    4 |  400 |</span><br><span class="line">|    5 |  500 |</span><br><span class="line">|    6 |  600 |</span><br><span class="line">|    7 |  700 |</span><br><span class="line">|    8 |  800 |</span><br><span class="line">|    9 |  900 |</span><br><span class="line">|   10 | 1000 |</span><br><span class="line">+------+------+</span><br><span class="line">10 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show engine innodb status;</span><br><span class="line">------------</span><br><span class="line">TRANSACTIONS</span><br><span class="line">------------</span><br><span class="line">Trx id counter 6699544</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 6699543 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 0</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">---TRANSACTION 421163334239304, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421163334238448, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421163334236736, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 421163334235880, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">---TRANSACTION 6699543, ACTIVE 14 sec</span><br><span class="line">2 lock struct(s), heap size 1136, 10 row lock(s)</span><br><span class="line">MySQL thread id 9, OS thread handle 139688312157952, query id 350 localhost root starting</span><br><span class="line">show engine innodb status</span><br><span class="line">TABLE LOCK table `ds0`.`t` trx id 6699543 lock mode IX</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699543 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b900; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 00000066361a; asc    f6 ;;</span><br><span class="line"> 2: len 7; hex 810000011a0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000064; asc    d;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b901; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 00000066361b; asc    f6 ;;</span><br><span class="line"> 2: len 7; hex 820000010b0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000002; asc     ;;</span><br><span class="line"> 4: len 4; hex 800000c8; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 4 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b902; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663620; asc    f6 ;;</span><br><span class="line"> 2: len 7; hex 810000010c0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000003; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000012c; asc    ,;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 5 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b903; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663621; asc    f6!;;</span><br><span class="line"> 2: len 7; hex 82000001170110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000004; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000190; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 6 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b904; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663622; asc    f6&quot;;;</span><br><span class="line"> 2: len 7; hex 810000010e0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 4: len 4; hex 800001f4; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 7 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b905; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663623; asc    f6#;;</span><br><span class="line"> 2: len 7; hex 820000010d0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000006; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000258; asc    X;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 8 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b906; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663624; asc    f6$;;</span><br><span class="line"> 2: len 7; hex 810000010f0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000007; asc     ;;</span><br><span class="line"> 4: len 4; hex 800002bc; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 9 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b907; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663625; asc    f6%;;</span><br><span class="line"> 2: len 7; hex 820000010e0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000008; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000320; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 10 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b908; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663626; asc    f6&amp;;;</span><br><span class="line"> 2: len 7; hex 81000001100110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000009; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000384; asc     ;;</span><br><span class="line"></span><br><span class="line">Record lock, heap no 11 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b909; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 000000663627; asc    f6&#x27;;;</span><br><span class="line"> 2: len 7; hex 820000010f0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 800003e8; asc     ;;</span><br></pre></td></tr></table></figure><p>线程9的6699543事务获得了1个IX表锁和10个X记录锁，即：把表中的10条记录都锁定了</p><blockquote><p>t表上没有索引，MySQL默认会创建GEN_CLUST_INDEX的聚簇索引，而语句没有加where条件，只能走全表</p></blockquote><p><strong>session2</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from t where id = 7 for update;</span><br><span class="line"># 等待锁</span><br></pre></td></tr></table></figure><p>与之前案例 1 相同，也是锁等待超时退出。</p><p>这次线程11的事务6699544从第1条记录就开始加锁了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">---TRANSACTION 6699544, ACTIVE 41 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s)</span><br><span class="line">MySQL thread id 11, OS thread handle 139688309319424, query id 368 localhost root executing</span><br><span class="line">select * from t where id = 7 for update</span><br><span class="line">------- TRX HAS BEEN WAITING 41 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699544 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b900; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 00000066361a; asc    f6 ;;</span><br><span class="line"> 2: len 7; hex 810000011a0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000064; asc    d;;</span><br><span class="line"></span><br><span class="line">------------------</span><br><span class="line">TABLE LOCK table `ds0`.`t` trx id 6699544 lock mode IX</span><br><span class="line">RECORD LOCKS space id 8692 page no 4 n bits 80 index GEN_CLUST_INDEX of table `ds0`.`t` trx id 6699544 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 6; hex 00000048b900; asc    H  ;;</span><br><span class="line"> 1: len 6; hex 00000066361a; asc    f6 ;;</span><br><span class="line"> 2: len 7; hex 810000011a0110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000001; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000064; asc    d;;</span><br></pre></td></tr></table></figure><p><strong>session3</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; begin;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; update t set sal = sal + 1 where id = 7;</span><br><span class="line">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure><p>与案例 1 不同的是，这次 Update 语句也遭遇锁等待超时退出了。</p><h1>4. <strong>案例分析</strong></h1><p>由于 t 表上不存在索引，3 个会话执行的语句都是<strong>全表扫描</strong>，在 RC 事务隔离级别下，这些语句都是需要发起当前读的操作（读取t表上最新的已提交事务版本），需要对读取到的全部记录加上记录锁（即行锁、也可称为 InnoDB 锁，大多数情况下，RC 隔离级别没有 Gap 锁，因此基本不太会出现 Next-Key 锁，对高并发场景比较友好）。</p><p><strong>案例 1</strong></p><ul><li>Session 1：开始需要对每条记录加锁，由于不需要维护可重复读，也不需要锁 Gap，当返回 MySQL Server 层通过 where 条件过滤后，最终只对 id=4、id=5 的记录加了锁。</li><li>Session 2：从 id=1 开始读取记录并加锁，当读取到 id=4 的记录时，<strong>由于 Session 1 先对 id=4 的记录上了锁，就无法再对其进行加锁操作，我们看到它一直在等待 id=4 的 X 锁，直到锁等待超时报错，为何是 id=4，而不是 id=5？因为是按聚簇索引一条条读取记录的，所以锁也需要一条条加，当上一条记录的锁资源没获取到，就不会对下一条记录加锁。</strong></li><li>Session 3：同样地，最开始也需要对读取到的记录一条条加锁，由于 id=7 的记录与 id=4、id=5 上的行锁并不冲突，此处可以利用半一致性读对 Update 的优化特性，提前将 id=7 上的行锁释放掉了，因此 Update 不会被阻塞，事务得以正常执行。</li></ul><p><strong>案例 2</strong></p><ul><li>Session 1：Select 语句没有用 where 条件，通过全表扫描访问到的所有记录都无法通过 MySQL Server 层过滤，因此将 t 表的全部记录都上了 X 锁。</li><li>Session 2：由于 Session 1 已经将全部记录都上了 X 锁，Session 2 当前读的 Select 操作由于无法获取任何记录的 X 锁，就被阻塞了。</li><li>Session 3：同样地，Session 1 持有的全记录 X 锁，使 Session 3 的 where 条件落到了匹配的区间内，表示 Session 1 对 id=7 的行确实需要更新，必须上锁，因此 Session 3 的 Update 被阻塞。</li></ul><h1>5. <strong>总结</strong></h1><p>在 RC 事务隔离级别下，Update 语句可以利用到半一致性读的特性，会多进行一次判断，当 where 条件匹配到的记录与当前持有锁的事务中的记录不冲突时，就会提前释放 InnoDB 锁，虽然这样做违背了二阶段加锁协议，但却可以减少锁冲突，提高事务并发能力，是一种很好的优化行为。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DataBase </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis的单线程和多线程</title>
      <link href="/posts/ec752e67.html"/>
      <url>/posts/ec752e67.html</url>
      
        <content type="html"><![CDATA[<h1>Redis的单线程和多线程</h1><blockquote><p>Redis到底是多线程还是单线程？</p></blockquote><h5 id="简单回答">简单回答</h5><p>Redis 是从4开始慢慢支持多线程的，直到 Redis6/7 后才稳定</p><h5 id="详解">详解</h5><p>这种问法其实并不严谨，单线程还是多线程需要视<strong>版本</strong>而定。</p><p>Redis的版本很多3.X、4.X、6.X，版本不同架构也是不同的，<strong>不限定版本</strong>问是否单线程也不太严谨。</p><p>版本3.×（最早版本），也就是大家口口相传的Redis是单线程；</p><p>版本4.×，严格意义来说也不是单线程，而是负责处理客户端请求的线程单线程，但是开始加了点多线程的东西（异步删除）；</p><p>版本6.x 开始，<strong>全面支持</strong>多线程。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910297.png" alt="img"></p><h6 id="Redis的“单线程”">Redis的“单线程”</h6><p>Redis的“单线程”主要是指Redis的<strong>网络IO</strong>和<strong>键值对读写</strong>是由<strong>一个线程</strong>来完成的，Redis在处理客户端的请求时包括获取（socket读）、解析、执行、内容返回（socket写）等都由一个<strong>顺序串行的主线程处理</strong>（第一篇介绍过的那些原子的命令），这也是Redis对外提供键值存储服务的主要流程。</p><p>Redis采用<strong>Reactor模式</strong>的网络模型，对于一个客户端请求，主线程负责一个完整的处理过程，如下图：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910736.png" alt="img"></p><p>补充：</p><p>Reactor 模式是一种<strong>并发模型</strong>，在这种模型中，**主线程（Reactor）**避免了由于等待一或多个并发事件（比如 I/O 操作）的完成而无法继续工作的阻塞。通过使用非阻塞 I/O 操作和事件通知，主线程在并发操作完成时得到通知。</p><p>一般来说，Reactor 模式的工作流程如下：</p><ol><li>应用程序将需要<strong>监听的 I/O 事件</strong>（比如 socket 的可读、可写事件）注册到 Reactor 中，并且关联对应的处理事件。</li><li>Reactor 不断地<strong>轮询</strong>这些事件，当某个事件到达的时候（比如 socket 中有数据可读），Reactor 将这个事件对应的处理事件唤醒，交由一个工作线程（或者称之为 EventHandler）去处理。</li><li>工作线程处理完相应的事件后，通知 Reactor <strong>继续监听</strong>这个事件。</li></ol><p>这种模型非常适合于<strong>大并发，少逻辑</strong>的网络程序中，比如 Nginx 中就用到了这种设计模式。通过这种方式，一个线程可以处理很多连接的事件，而不需要为每个连接都创建一个线程，这样就可以避免线程切换的开销，并且可以更有效地使用系统资源。</p><p>但Redis的其他功能，比如持久化RDB、AOF、异步删除、集群同步数据等都是由额外的线程执行的，因此整个Redis可以看作是多线程的。</p><h6 id="Redis为什么选择单线程？">Redis为什么选择单线程？</h6><p>准确的说，应该是Redis 4.0之前一直采用单线程</p><p>主要原因有：</p><ul><li>使用单线程模型使Redis的<strong>开发和维护更简单</strong></li><li>虽然使用的是单线程，但也可以<strong>并发处理多客户端的请求</strong>（IO多路复用和非阻塞IO）</li><li>对于Redis系统来说，主要的性能瓶颈是<strong>内存</strong>/<strong>网络带宽</strong>，而非CPU</li></ul><h6 id="后来Redis为什么又逐渐加入了多线程特性？">后来Redis为什么又逐渐加入了多线程特性？</h6><ul><li><p>硬件的发展</p></li><li><ul><li>CPU并不是Redis的瓶颈，通常Redis要不受内存限制要不受网络限制，但是随着计算机硬件的发展，多核CPU已经成为常态，为了更大限度的利用CPU</li></ul></li><li><p>单线程的缺点</p></li><li><ul><li>Redis使用单线程也是有一定缺点的，比较典型的就是使用del指令删除大key数据时（比如包含了成千上万个元素的hash集合，关于大key的问题我们会在Redis系列的下一篇专门介绍，这里先简单举个例子），del指令就会造成主线程卡顿。</li><li>由于Redis3.x完全是单线程的，del指令删除时会等待⌛️很久才释放，如果再加上高并发场景(˶‾᷄ ⁻̫ ‾᷅˵)额。。这就是Redis3.x单线程时代最经典的故障，大key删除的头疼问题，于是Redis4.0就新增了多线程模块，也主要是为了解决这个问题。</li><li>此外例如flushdb还有flushall在数据量达到一定程度时，也会造成卡顿，因此一开始Redis就是把某些时间复杂度高，占主线程CPU时间片较高，造成主线程卡顿的操作使用多线程来处理（bio子线程），以减少主线程阻塞时间，从而减少那个诸如del操作导致性能和稳定性的问题。</li></ul></li></ul><p>总的来说，就是<strong>与时俱进</strong>(￣∇￣)/🎉～～～</p><h4 id="Redis为什么快？">Redis为什么快？</h4><h5 id="回答">回答</h5><p>Redis 3.0 单线程时代依旧很快的原因：</p><ul><li><strong>基于内存操作</strong>：Rdis的所有数据都存在内存中，因此所有的运算都是内存级别的，所以他的性能比较高</li><li><strong>数据结构简单</strong>：Rdis的数据结构是专门设计的，而这些简单的数据结构的查找和操作的时间大部分复杂度都是O(1)，因此性能比较高</li><li><strong>多路复用和非阻塞I/O</strong>：Redis使用多路复用功能来监听多个socket连接客户端，这样就可以使用一个线程连接来处理多个请求，减少线程切换带来的</li><li><strong>避免上下文切换</strong>：因为是单线程模型，因此就避免了不必要的上下文切换和多线程竞争，这就省去了多线程切换带来的时间和性能上的消耗，而且单线程</li></ul><p>现在Redis快的原因</p><p>在上面原因的基础上</p><ul><li><strong>IO多路复用</strong> + <strong>epoll函数</strong>使用</li></ul><p>接下来我们详细介绍下IO多路复用</p><h3 id="IO多路复用">IO多路复用</h3><p>IO多路复用（IO multiplexing）是Unix网络编程的5种IO模型之一。</p><h4 id="Unix网络编程的5种IO模型">Unix网络编程的5种IO模型</h4><ul><li>Blocking IO 阻塞IO</li><li>NoneBlocking IO 非阻塞IO</li><li>IO multiplexing IO 多路复用</li><li>signal driven IO 信号驱动IO</li><li>asynchronous IO 异步IO</li></ul><p>Redis一直被大家熟知的就是它的单线程架构，虽然从Redis4.0开始使用了多线程，也是为了处理数据删除、快照删除等耗时操作，从网络IO处理到实际的读写命令处理都是由主线程独自处理的（心疼下主线程）。</p><p>在Redis 6/7中，Redis全面支持了多线程。这是由于随着硬件性能的提升，Redis的性能瓶颈主要出现在网络IO上，就是完全靠单个主线程处理网络请求的速度跟不上底层网络硬件的速度，于是采用多个线程处理网络IO，提高网络请求处理的并行度。</p><p>但是，<strong>Redis的多IO线程只是用来处理网络请求</strong>的，对于<strong>读写操作命令 Redis 仍然使用单线程</strong>来处理。这是因为，Redis处理请求时，网络处理经常是瓶颈，通过多个IO线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命令操作，就不用为了保证Lua脚本、事务的原子性，额外开发多线程互斥加锁机制了（不管加锁操作处理），这样一来，Redis 线程模型实现就简单了。</p><h4 id="主线程和IO线程怎么协作完成请求处理的">主线程和IO线程怎么协作完成请求处理的</h4><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910462.png" alt="img"></p><h5 id="四个阶段">四个阶段</h5><ul><li>阶段一：服务端和客户端建立Socket连接，并分配处理线程 首先，<strong>主线程</strong>负责接收<strong>建立连接请求</strong>，当有客户端请求和实例建立Socket连接时，主线程会<strong>创建和客户端的连接</strong>，<strong>并把Socket放入全局等待队列中</strong>，紧接着，<strong>主线程通过轮询方法把Socket连接分配给IO线程</strong>。</li><li>阶设二：IO线程读取并解折请求 主线程一旦把Socket分配给IO线程，就会进入阻塞状态，等待IO线程完成客户端请求的读取和解析，因为有多个IO线程在并行处理，所以，这个过程很快就可以完成。</li><li>阶段三：主线程执行请求操作 等到IO线程解析完请求，<strong>主线程</strong>还是会以单线程的方式<strong>执行这些命令操作。</strong></li><li>阶设四：IO线程回写Socket和主线程清空全局队列 当<strong>主线程执行完请求操作后，会把需要返回的结果写入缓冲区</strong>，然后，<strong>主线程会阻塞等待IO线程</strong>，把这些结果回写到Socket中，并返回给客户端。和IO线程读取和解析请求一样，IO线程回写Socket时，也是有多个线程在并发执行，所以回写Socket的速度也很快。等到IO线程回写Socket完毕，主线程会清空全局队列，等待客户端的后续请求。</li></ul><h4 id="浅谈IO多路复用">浅谈IO多路复用</h4><p>由于IO多路复用（IO multiplexing）是Unix网络编程的5种IO模型之一，我们先介绍下Linux的相关内容，便于理解（熟悉的人可以直接跳到下一趴）。</p><p>在Linux中，一切皆文件，这就要提到“文件描述符”这个概念了。</p><h5 id="文件描述符（FileDescriptor-FD）">文件描述符（FileDescriptor, FD）</h5><p>文件描述符是计算机科学中的一个术语，是一个用于表述<strong>指向文件的引用</strong>的抽象化概念。</p><p>文件描述符在形式上是一个非负整数，实际上它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向该进程返回一个文件描述符。</p><p>在程序设计中，文件描述符这一概念往往只适用于UNIX或者Linux这样的操作系统。</p><h5 id="什么是IO多路复用">什么是IO多路复用</h5><p>一种同步的IO模型，实现一个线程监视多个文件句柄，一旦某个文件句柄就绪，就能通知到对应程序进行相应的读写操作，没有文件句柄就绪时，就会阻塞应用程序，从而释放CPU资源。</p><p>我们来介绍几个概念：</p><ul><li><p>I/O</p></li><li><ul><li>网络I/O，尤其在操作系统层面指数据在内核态和用户态之间的读写操作</li></ul></li><li><p>多路</p></li><li><ul><li>多个客户端连接（连接就是套接字描述符，即socket或者channel）</li></ul></li><li><p>复用</p></li><li><ul><li>复用一个或者几个线程连接</li></ul></li><li><p>IO多路复用</p></li><li><ul><li>也就是说一个或者一组线程处理多个TCP，使用单进程就能实现同时处理多个客户端的连接，无需创建或者维护过多的进程/线程</li></ul></li></ul><p>总结</p><ul><li>一个服务端进程可以同时处理多个套接字描述符</li><li>实现多路复用的模型有3种：可以分select-&gt;poll-&gt;epoll3个阶段来描述</li></ul><h5 id="场景模拟">场景模拟</h5><p>不知道大家有没有注意过麻辣烫店是怎么做煮麻辣烫的，他们可不是一碗一碗单独的锅单独的灶煮的（太费💰），一般是有一个方形大锅，整个锅里加满水，下面一个灶加热，大锅里分成一个个小格子（就类似重庆火锅那种九宫格），每个小格子里煮一个客人选的菜。</p><p>基本流程就是，客人选完菜去收银那里称斤付款（人多则需要排队），服务员每收到一个客人选的菜，就把它们倒进一个小格子里煮，然后再回来收下一位的……还会时不时看看哪个小格子里的菜熟了，就把它盛到碗里，端回给客人</p><p>我们根据模拟情景来简单概括下IO多路复用模型：</p><p>将用户Socket对应的文件描述符（FileDescriptor）注册进epoll，然后epoll帮你监听哪些Socket上有消息到达，这样就避免了大量的无用操作，此时的Socket应该采用非阻塞模式，这样整个过程只在调用select、poll、epoll这些函数是才会阻塞，收发客户消息是不会阻塞的，整个进程/线程就会被充分利用起来，这就是事件驱动，所谓的reactor反应模式。</p><p>在单个线程通过<strong>记录跟踪每一个Socket（I/O流）的状态</strong>来同时管理多个I/O流，一个服务端进程可以同时处理多个套接字描述符，以此来<strong>提高服务器的吞吐能力</strong>。</p><p>大家都用过nginx，nginx使用epoll接收请求，ngnix会有很多链接进来，epoll会把他们都监视起来，然后像拨开关一样，谁有数据就拨向谁，然后调用相应的代码处理。Redis类似同理，这就是IO多路复用原理，有请求就响应，没请求不打扰。</p><p>IO多路复用达到的效果就是只使用一个服务端进程可以同时处理多个套接字描述符连接。</p><p>客户端请求服务端时，实际就是在服务端的Socket文件中写入客户端对应的文件描述符（FileDescriptor），如果有多个客户端同时请求服务端，为每次请求分配一个线程，类似每次来就new一个太耗费服务端资源，因此，只使用一个线程来监听多个文件描述符，即IO多路复用。</p><p>采用IO多路复用技术可以让单个线程高效的处理多个连接请求，一个服务端进程可以同时处理多个套接字描述符。</p><p>从Rdis6开始，就新增了多线程的功能来提高I/O的读写性能，他的主要实现思路是<strong>将主线程的IO读写任务拆分给一组独立的线程去执行</strong>，这样就可以使多个Socket的读写可以并行化了，采用多路I/O复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗)，将最耗时的Socket的读取、请求解析、写入单独外包出去，剩下的命令执行仍然由主线程串行执行并和内存的数据交互。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161910584.png" alt="img"></p><p>于是，网络IO操作就变成多线程了，其他核心操作仍然是主线程单独处理（线程安全）</p><h4 id="总结">总结</h4><ul><li>Redis的工作线程是单线程的，但是整个Redis是多线程的</li><li>Redis6/7将网络数据读写、请求协议解析通过多个IO线程来处理，真正执行命令的线程仍然是主线程单独进行操作（单线程），一举两得，既解决网络IO问题（多个IO线程），有保证了线程安全且处理方式简单（单线程执行命令）</li></ul><h3 id="Redis-7-默认设置是否开启了多线程？">Redis 7 默认设置是否开启了多线程？</h3><p>如果你在实际应用中，发现Redis实例的CPU开销不大但吞吐量却没有提升，可以考虑使用Reds7的多线程机制（默认关闭，需手动开启），加速网络处理，进而提升实例的吞吐量。</p><p>Redis7将所有的数据放在内存中，内存的响应时长大约为100纳秒，对于小数据，Redis服务器可以处理8W到10W的QPS（实验室数据，极限），但是对于大部分的公司已经够用了，所以在Redis6.0以后，多线程机制默认是关闭的，如果需要使用，则要在redis.conf配置文件中修改，主要改两个地方：</p><ol><li>设置io-threads-do-redis配置项为yes，表示启动多线程</li><li>设置线程个数，io-threads 个数，关于个数的设置，官方的建议是如果为4核的CPU，建议线程数设置为2或3，如果为8核CPU建议线程数设置为6（线程数一定要小于机器核数，并非越大越好）</li></ol><h3 id="总结-2">总结</h3><p>Redis基于<strong>内存操作</strong>、<strong>数据结构简单</strong>、<strong>多路复用</strong>和<strong>非阻塞I/O</strong>等特性，避免了不必要的上下文切换，在单线程的环境下依旧很快。但对于大数据的key删除还是会卡顿，因此在4.0版本中引入了多线程unlink key/flushall async等命令，主要用于Redis数据的异步删除。而在Redis6/7中引入了I/O多线程的读写，增加了吞吐量，而<strong>命令的执行依旧是有主线程串行执行的</strong>，因此在多线程下操作Redis既<strong>能保持良好的性能</strong>和<strong>响应速度</strong>，并且<strong>不会出现线程安全的问题</strong>。</p><h3 id="相关链接">相关链接</h3><p><a href="https://blog.csdn.net/aqin1012/article/details/131944713">【Redis】高级篇： 一篇文章讲清楚Redis的单线程和多线程_redis的i文件描述符-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis十大数据类型</title>
      <link href="/posts/dfb5c41c.html"/>
      <url>/posts/dfb5c41c.html</url>
      
        <content type="html"><![CDATA[<h1>Redis十大数据类型</h1><h2 id="类型">类型</h2><blockquote><p>这里的类型是Value，Key一般都是String</p></blockquote><ul><li>Strings</li><li>Lists</li><li>Sets</li><li>Sorted Sets （ZSET）</li><li>Hashes</li><li>Streams</li><li>Geospatial</li><li>HyperLogLog</li><li>Bitmaps</li><li>Bitfields</li></ul><h4 id="String-字符串">String 字符串</h4><ul><li>Redis中最基本的类型，一个Key可以对应一个Value</li><li>二进制安全的（可以包含任何数据，比如图片或者序列化的对象）</li><li>一个Redis中的字符串value最多可以是512M</li></ul><h4 id="List-列表">List 列表</h4><ul><li>简单的字符串列表，按照被插入的顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）</li><li>底层是个双端链表，最多可以包含2^32-1个元素（4294967295，超过40亿个元素）</li><li>对两端操作性能很高，通过索引下标操作中间节点性能会比较差</li></ul><h4 id="Set-集合">Set 集合</h4><ul><li>String类型的集合</li><li>不允许重复 + 无序</li><li>集合对象的编码可以是intset和hashtable（底层）</li><li>通过<strong>哈希表</strong>实现的，所以查询、删除、添加的时间复杂度都是O(1)</li><li>可以包含2^32-1个元素（4294967295，超过40亿个元素）</li><li>应用场景<ul><li>微信抽奖小程序（sadd/spop/srandmember）</li><li>朋友圈的点赞</li><li>QQ可能认识的人</li></ul></li></ul><h4 id="Sorted-Set-ZSet-有序集合">Sorted Set /ZSet 有序集合</h4><ul><li>与Set一样是String类型的集合</li><li>不同的是每个元素都会关联一个double类型的分数（给Redis从小到大排序用的）<ul><li>value变成了一个键值对：score1 value1</li><li>key1 score1 value1 key2 score2 value2</li></ul></li><li>ZSet的成员是唯一的，但分数（score）可以重复</li><li>通过<strong>哈希表</strong>实现的，所以查询、删除、添加的时间复杂度都是O(1)</li><li>可以包含2^32-1个元素（4294967295，超过40亿个元素）</li><li>应用场景<ul><li>各种排行榜</li></ul></li></ul><h4 id="Hash-哈希表">Hash 哈希表</h4><ul><li>K-V 键值对</li><li>可以包含2^32-1个元素（4294967295，超过40亿个元素）</li></ul><h4 id="GEO-地理空间">GEO 地理空间</h4><ul><li>原理（实际上是个ZSet，score变成了经纬度）<ul><li>核心思想：将球体转换为平面，区块转换为一点</li><li>主要分为3步：<ul><li>将三维地球变为二维坐标</li><li>将二维坐标转换为一维的点块</li><li>将一维的点块转换为二进制再通过base32编码</li></ul></li></ul></li><li>主要用于存储地理位置信息，并对存储的信息进行操作，包括<ul><li>添加地理位置的坐标</li><li>获取地理位置的坐标</li><li>计算两个位置之间的距离</li><li>……</li></ul></li><li>应用场景<ul><li>美团地图位置附近的酒店</li><li>高德地图附近的核酸点</li></ul></li></ul><h4 id="HyperLogLog-基数统计">HyperLogLog 基数统计</h4><ul><li>用完做基数统计的算法<ul><li>基数：是一种数据集，去重后的真实个数</li><li>基数统计：用于统计一个几乎中不重复的元素的个数，就是对集合去重后剩余元素的计算，即<strong>去重脱水后的真实数据</strong></li></ul></li><li>优点是在输入元素的数量或者体积特别大时，计算基数所需的空间总是固定且很小的<ul><li>每个HyperLogLog键只需要12kb内存，就可以计算出接近2^64个不同的元素的基数</li><li>这和元素越多耗费内存越多的集合产生了鲜明的对比</li></ul></li><li>但HyperLogLog并不会记录每个元素的具体值</li><li>可用于统计某个网站/文章的UV、用户搜索🔍关键词的数量、用户每天搜索不同词条的个数<ul><li>UV unique visitor 独立访客（一般为用户IP）</li></ul></li></ul><h4 id="Bitmap-位图">Bitmap 位图</h4><ul><li>Bit arrays（or simply bitmaps）Bitmap是用String作为底层数据结构实现的一种统计二值状态的数据类型</li><li>一个字节占8位（1 byte = 8 bit）</li><li>由0和1组成的二进制位的<strong>bit数组</strong>（1 bit 只能存1个0/1）</li><li>一般用于状态记录📝<ul><li>用户是否登陆过</li><li>电影广告是否被点击播放过</li><li>上下班打卡统计</li></ul></li></ul><h4 id="BitField-位域">BitField 位域</h4><ul><li>可以一次性操作多个比特<strong>位域</strong>（连续的多个比特位），它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果（其实就是一次性对多个比特位进行操作）</li></ul><h4 id="Stream-流">Stream 流</h4><ul><li>Redis 5.0 新增的数据结构 : <strong>MQ消息中间件+阻塞队列</strong></li><li>主要用于<strong>消息队列</strong>（MQ，Message Queue）<ul><li>支持消息队列的持久化</li><li>支持自动生成全局唯一ID</li><li>支持ack确认消息的模式</li><li>支持消费组（多个消费者）模式等</li></ul></li><li>Redis本身有一个发布/订阅来实现消息队列的功能，但他的缺点是消息无法持久化，如果出现网络断开、Redis宕机等，消息就会被丢弃<ul><li>即发布/订阅可以分发消息，但无法记录历史消息</li></ul></li><li>Redis的Stream提供了消息的持久化以及主从备份复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失，让消息队列更加稳定和可靠</li></ul><h2 id="常用命令">常用命令</h2><h4 id="key-操作指令">key 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left"><strong>备注</strong></th></tr></thead><tbody><tr><td style="text-align:left">key *</td><td style="text-align:left">查看当前库所有key</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">exists key</td><td style="text-align:left">判断某个key是否存在</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">type key</td><td style="text-align:left">查看某个key的类型</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">del key</td><td style="text-align:left">删除指定的key</td><td style="text-align:left">原子的</td></tr><tr><td style="text-align:left">unlink key</td><td style="text-align:left">非阻塞删除（仅将key从keyspace元数据中移除）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">ttl key</td><td style="text-align:left">查看还有多少秒过期（-1表示永不过期，-2表示已过期）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">expire key 秒钟</td><td style="text-align:left">为给定的key设置过期时间</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">move key dbindex</td><td style="text-align:left">将当前数据库的key移动到给定的数据库db中（dbindex的值为0-15）</td><td style="text-align:left">默认0</td></tr><tr><td style="text-align:left">dbsize</td><td style="text-align:left">查看当前数据库key的数量</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">flushdb</td><td style="text-align:left">清空当前库</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">flushall</td><td style="text-align:left">清空全部库</td><td style="text-align:left"></td></tr></tbody></table><h4 id="String-操作指令">String 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th></th></tr></thead><tbody><tr><td style="text-align:left">set key value [<code>NX</code></td><td style="text-align:left"><code>XX</code>] [<code>GET</code>][<code>EX seconds</code></td><td style="text-align:left"><code>PX milliseconds</code></td><td><code>EXAT unit-time-milliseconds</code></td></tr><tr><td style="text-align:left">批处理</td><td style="text-align:left">mset key value [key value …]</td><td style="text-align:left">同时设置多个值</td><td></td></tr><tr><td style="text-align:left">mget key value [key value …]</td><td style="text-align:left">同时获取多个值</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">msetnx key value</td><td style="text-align:left">key不存在才设置</td><td style="text-align:left">所有的key都不存在才会设置成功</td><td></td></tr><tr><td style="text-align:left">getrange key <code>start</code> <code>end</code></td><td style="text-align:left">获取指定区域内的值</td><td style="text-align:left"><code>start</code> 开始下标（从0开始）<code>end</code> 结束下标</td><td></td></tr><tr><td style="text-align:left">setrange key <code>offset</code> <code>vaue</code></td><td style="text-align:left">设置指定区域内的值</td><td style="text-align:left"><code>offset</code> 开始下标<code>vaue</code> 设置数量</td><td></td></tr><tr><td style="text-align:left">数值增减（必须是数字才行）</td><td style="text-align:left">INCR key</td><td style="text-align:left">递增数字</td><td></td></tr><tr><td style="text-align:left">INCRBY key <code>increment</code></td><td style="text-align:left">增加减少指定的参数</td><td style="text-align:left"><code>increment</code> 指步长</td><td></td></tr><tr><td style="text-align:left">DECR key</td><td style="text-align:left">递减数值</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">DECRBY key <code>decrement</code></td><td style="text-align:left">减少指定的参数</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">STRLEN key</td><td style="text-align:left">获取字符串长度</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">APPENG key value</td><td style="text-align:left">内容追加</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">分布式锁（原子操作）</td><td style="text-align:left">setnx key value</td><td style="text-align:left">key不存在才设置</td><td>nx: set if not exsit</td></tr><tr><td style="text-align:left">setex key <code>seconds</code> value</td><td style="text-align:left">同时设置值和过期时间</td><td style="text-align:left">ex: set with expire</td><td></td></tr><tr><td style="text-align:left">getset key value</td><td style="text-align:left">先get后set</td><td style="text-align:left">等价于 set key value get</td><td></td></tr></tbody></table><h4 id="List-操作指令">List 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">lpush key value</td><td style="text-align:left">从左边👈设置/添加</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">rpush key value</td><td style="text-align:left">从右边👉设置/添加</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lrange key <code>start</code> <code>stop</code></td><td style="text-align:left">从左边👈开始遍历</td><td style="text-align:left"><code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标<code>lrange key 0 -1</code> 表示遍历全部</td></tr><tr><td style="text-align:left">lpop</td><td style="text-align:left">弹出最左边的值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">rpop</td><td style="text-align:left">弹出最右边的值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lindex</td><td style="text-align:left">按照索引下标获得元素（从上到下）</td><td style="text-align:left">左（上）右（下）</td></tr><tr><td style="text-align:left">llen</td><td style="text-align:left">获取list中的元素个数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lrem key <code>N</code> value</td><td style="text-align:left">删除N值为value的元素</td><td style="text-align:left"><code>N</code> 表示删除值的个数</td></tr><tr><td style="text-align:left">ltrim key <code>start</code> <code>stop</code></td><td style="text-align:left">截取指定索引范围的值再赋值给key</td><td style="text-align:left"><code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标</td></tr><tr><td style="text-align:left">rpoplpush key1 key2</td><td style="text-align:left">从key1中弹出最右边的，加入到key2的最左端并返回</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lset key <code>index</code> value</td><td style="text-align:left">将key中序号为<code>index</code>的值设置为value</td><td style="text-align:left"><code>index</code> 要设置的值的序号（没有该序号则会报错）</td></tr><tr><td style="text-align:left">linsert key before/after <code>pivot</code> <code>element</code></td><td style="text-align:left">在key中值为<code>pivot</code>的元素前/后插入值为<code>element</code>的元素</td><td style="text-align:left"><code>pivot</code> 已有值<code>element</code> 插入值从上向向下👇第一个等于<code>pivot</code>的值</td></tr></tbody></table><h4 id="Set-操作指令">Set 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th></th></tr></thead><tbody><tr><td style="text-align:left">sadd key <code>member</code> [<code>member</code>…]</td><td style="text-align:left">添加元素</td><td style="text-align:left">自动去重</td><td></td></tr><tr><td style="text-align:left">smembers key</td><td style="text-align:left">遍历所有元素</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">sismember key <code>member</code></td><td style="text-align:left">判断元素是否在集合中</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">srem key <code>member</code>[<code>member</code>…]</td><td style="text-align:left">删除元素</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">scard key</td><td style="text-align:left">获取集合里面的元素个数</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">srandmember key [<code>n</code>]</td><td style="text-align:left">从集合中随机展现<code>n</code>个元素，不删除</td><td style="text-align:left"><code>n</code> 展示元素的个数</td><td></td></tr><tr><td style="text-align:left">spop key [<code>n</code>]</td><td style="text-align:left">从集合中随机弹出/删除<code>n</code>个元素</td><td style="text-align:left"><code>n</code> 弹出/删除元素的个数</td><td></td></tr><tr><td style="text-align:left">smove key1 key2 [<code>value</code>]</td><td style="text-align:left">将key1中的某个值<code>value</code>赋值给key2</td><td style="text-align:left"><code>value</code>：key1中的某个值</td><td></td></tr><tr><td style="text-align:left">集合运算</td><td style="text-align:left">sdiff key [key…]</td><td style="text-align:left">差集运算 A - B</td><td></td></tr><tr><td style="text-align:left">sunion key [key…]</td><td style="text-align:left">并运算 A U B</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">sinter key [key…]</td><td style="text-align:left">交运算 A n B</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">sintercard numkeys key [key…] [limit <code>num</code>]</td><td style="text-align:left">只返回基数（去重统计数）</td><td style="text-align:left"><code>num</code> 返回个数</td><td></td></tr></tbody></table><h4 id="ZSet-操作指令">ZSet 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">zadd key [<code>NX</code></td><td style="text-align:left"><code>XX</code>] [<code>GT</code></td><td style="text-align:left"><code>LT</code>] [<code>CH</code>] [<code>INCR</code>] score member [score member …]</td></tr><tr><td style="text-align:left">zrange key <code>start</code> <code>stop</code> [<code>withscores</code>]</td><td style="text-align:left">按照元素分数从小到大的顺序，返回索引从start到stop之间的所有元素</td><td style="text-align:left"><code>withscores</code> 带分数<code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标</td></tr><tr><td style="text-align:left">zrevrange key <code>start</code> <code>stop</code> [<code>withscores</code>]</td><td style="text-align:left">zrange的反转（从大到小）</td><td style="text-align:left"><code>withscores</code> 带分数<code>start</code> 开始下标（从0开始）<code>stop</code> 结束下标</td></tr><tr><td style="text-align:left">zrangebyscore key <code>min</code> <code>max</code> [<code>withscores</code>][<code>limit offset count</code>]</td><td style="text-align:left">获取指定分数范围的元素</td><td style="text-align:left"><code>(min</code> 不包含<code>limit offset count</code> 从<code>offset</code>开始取<code>count</code>个</td></tr><tr><td style="text-align:left">zscore key member</td><td style="text-align:left">获取元素的分数</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zcard key</td><td style="text-align:left">获取集合中元素的数量</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zrem key <code>member</code></td><td style="text-align:left">删除值为指定分数的元素</td><td style="text-align:left"><code>member</code> 要删除元素的value值</td></tr><tr><td style="text-align:left">zincrby key <code>increment</code> member</td><td style="text-align:left">增加某个元素的分数</td><td style="text-align:left"><code>increment</code> 增加的值</td></tr><tr><td style="text-align:left">zcount key <code>min</code> <code>max</code></td><td style="text-align:left">获取指定分数范围内的元素个数</td><td style="text-align:left"><code>min</code> 开始<code>max</code> 结束</td></tr><tr><td style="text-align:left">zmpop</td><td style="text-align:left">从键名列表中的第一个非空排序集中弹出一个或多个元素，他们是成员分数对</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zrank key values</td><td style="text-align:left">获取下标值（从0开始）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">zrevrank key values</td><td style="text-align:left">逆序获取下标值</td><td style="text-align:left"></td></tr></tbody></table><h4 id="Hash操作指令">Hash操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th></th></tr></thead><tbody><tr><td style="text-align:left">hset key <code>field value</code> [<code>field value</code>…]</td><td style="text-align:left">添加/设置</td><td style="text-align:left"><code>field value</code> 也是某个元素内的属性键值对</td><td></td></tr><tr><td style="text-align:left">hget key field</td><td style="text-align:left">获取键为key的元素中的field属性的值</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">批处理</td><td style="text-align:left">hmset key <code>field value</code> [<code>field value</code>…]</td><td style="text-align:left">批量添加/设置</td><td></td></tr><tr><td style="text-align:left">hget key <code>field</code> [<code>field</code> …]</td><td style="text-align:left">批量获取</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hgetall key</td><td style="text-align:left">获取键为key的元素中的全部属性</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hlen key</td><td style="text-align:left">获取某个key内的全部数量</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hexists key</td><td style="text-align:left">判断是否存在键值为key值（0不存在）</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hkeys key</td><td style="text-align:left">获取键值为key值元素的所有字段名（<code>field</code>）</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hvals key</td><td style="text-align:left">获取键值为key值元素的所有字段值（<code>value</code>）</td><td style="text-align:left"></td><td></td></tr><tr><td style="text-align:left">hincrby/hincrbyfloat key <code>field</code> <code>increment</code></td><td style="text-align:left">给键值为key值元素中<code>field</code>的字段值加<code>increment</code></td><td style="text-align:left">hincrby 加整数hincrbyfloat 加小数</td><td></td></tr><tr><td style="text-align:left">hsetnx key <code>field value</code> [<code>field value</code>…]</td><td style="text-align:left">不存在才会新建成功</td><td style="text-align:left"></td><td></td></tr></tbody></table><h4 id="GEO-操作指令">GEO 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">geoadd key</td><td style="text-align:left">添加经纬度坐标</td><td style="text-align:left">出现中文乱码，redis-cli启动时加个<code>--raw</code></td></tr><tr><td style="text-align:left">geopos</td><td style="text-align:left">从键里面返回所有给定元素的位置（经纬度）</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">geodist key <code>member1</code> <code>member2</code> [<code>m</code></td><td style="text-align:left"><code>km</code></td><td style="text-align:left"><code>ft</code></td></tr><tr><td style="text-align:left">georadius key <code>longitude</code> <code>latitude</code> <code>radius</code> `m</td><td style="text-align:left">km</td><td style="text-align:left">ft</td></tr><tr><td style="text-align:left">georadiusbymember key member <code>radius</code> `m</td><td style="text-align:left">km</td><td style="text-align:left">ft</td></tr><tr><td style="text-align:left">geohash</td><td style="text-align:left">返回坐标的geohash表示</td><td style="text-align:left">geohash算法生成的base32编码值</td></tr></tbody></table><h4 id="HyperLogLog-操作指令">HyperLogLog 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th></tr></thead><tbody><tr><td style="text-align:left">pfadd key <code>element</code> [<code>element</code>]…</td><td style="text-align:left">添加指定的元素</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">pfcount key [key …]</td><td style="text-align:left">返回给定的基数估计值</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">pfmerge <code>destkey</code> <code>sourcekey</code> [<code>sourcekey</code>…]</td><td style="text-align:left">合并统计</td><td style="text-align:left"></td></tr></tbody></table><h4 id="Bitmap-操作指令">Bitmap 操作指令</h4><table><thead><tr><th style="text-align:left"><strong>指令</strong></th><th style="text-align:left"><strong>作用</strong></th><th style="text-align:left">可选项说明及备注</th><th style="text-align:left">时间复杂度</th></tr></thead><tbody><tr><td style="text-align:left">setbit key <code>offset</code> <code>value</code></td><td style="text-align:left">为键为key的元素序号为<code>offset</code>的值设置值为<code>value</code></td><td style="text-align:left"><code>offset</code> 偏移量（从0开始）<code>value</code> 值</td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">getbit key <code>offset</code></td><td style="text-align:left">获取指定key的第<code>offset</code>位</td><td style="text-align:left"></td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">strlen key</td><td style="text-align:left">统计字节数占用多少（按字节）</td><td style="text-align:left"></td><td style="text-align:left">O(1)</td></tr><tr><td style="text-align:left">bitcount key <code>start</code> <code>end</code></td><td style="text-align:left">返回指定范围[<code>start</code>, <code>end</code>]内值为1的数量</td><td style="text-align:left"><code>start</code> 开始序号<code>end</code> 结束序号</td><td style="text-align:left">O(n)</td></tr><tr><td style="text-align:left">bitop <code>operation</code> <code>destkey</code> key</td><td style="text-align:left">对不同的二进制存储数据进行位运算（AND、OR、NOT、XOR）</td><td style="text-align:left"><code>operation</code> 包括AND、OR、NOT、XOR<code>destkey</code> 新产生的值的key</td><td style="text-align:left">O(n)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无职转GO？入了Golang的坑就要好好看不起Java</title>
      <link href="/posts/745a3632.html"/>
      <url>/posts/745a3632.html</url>
      
        <content type="html"><![CDATA[<h1>无职转GO？入了Golang的坑就要好好看不起Java</h1><h2 id="Part-1-Go的优势？"><em><strong>Part.1 Go的优势？</strong></em></h2><p>Go是一种由谷歌公司开发的编程语言，也被称为Golang。相较于其他编程语言，Go有一些明显的优势：</p><p>1.并发处理能力：Go天生支持并发，应用于Web<a href="https://cloud.tencent.com/act/pro/promotion-cvm?from_column=20065&amp;from=20065">服务器</a>开发中非常合适。</p><p>2.快速编译：Go编译器可以快速生成机器码，大大提高了开发效率。</p><p>3.内存管理：Go拥有高效的垃圾回收机制，确保了程序运行时的稳定性。</p><p>以上优势使得Go适合用于高并发的Web服务和分布式系统开发，而这正是字节跳动所必须面对的。</p><h2 id="Part-2-架构设计？"><em><strong>Part.2 架构设计？</strong></em></h2><p>字节跳动在选择Go作为服务器端开发语言后，还进行了架构设计。在这个设计中，主要有以下几个方面的考虑：</p><p>1.高可扩展性：采用分布式架构，加上云服务的支持，在用户规模激增时依然能保证服务的平稳运行。</p><p>2.模块化开发：对于大型项目，采用模块化开发能有效地提高开发和维护的效率。</p><p>3.可重用性：将一些常用的代码封装成工具包，可以在别的项目中重用，从而避免重复工作。</p><p>4.监控和异常处理：在系统运行过程中，需要对运行情况进行监控和异常处理，这是重要的工作之一。</p><p>以上架构设计方案，使得字节跳动的Go开发团队能更好地应对业务需求的复杂性和日益增长的用户规模。</p><h2 id="Part-3-应用场景？"><em><strong>Part.3 应用场景？</strong></em></h2><p>在字节跳动的基础设施中，Go年日处理能力已经达到了几千万级别。此外，在字节跳动的多个应用场景中，Go也展现出了非常良好的性能表现：</p><p>1.推送服务：字节跳动在推送服务中使用了Go，不仅性能出色，而且可以轻松实现服务的扩展。</p><p>2.搜索服务：在搜索服务中，Go的高并发处理能力和快速编译速度得到了充分发挥。</p><p>3.<a href="https://cloud.tencent.com/product/vts?from_column=20065&amp;from=20065">视频转码</a>服务：通过Go的协程和通道特性，可以很好地实现视频转码的任务并发处理。</p><p>以上应用场景可以看出，Go作为服务器端开发语言，在高并发和大规模业务应用场景下有着非常出色的表现。</p><p>选择一种优秀的服务器端开发语言是非常重要的。Go是一种适合高并发Web服务和分布式系统开发的语言，而且具有快速编译、内存管理和并发处理等诸多优势。字节跳动选择Go作为服务器端开发语言，并进行了相应的架构设计和优化，从而实现了高可扩展性、模块化开发、可重用性和监控异常处理等目标。在多个场景应用中，Go也展现出了非常良好的性能表现。选择Go，是字节跳动成功发展的关键之一。</p><h2 id="Part-4-Go语言的高并发特性？"><em><strong>Part.4  Go语言的高并发特性？</strong></em></h2><h3 id="1-引言：Go语言高并发的背景和意义"><strong>1. 引言：Go语言高并发的背景和意义</strong></h3><p>随着互联网发展，由于大量的用户并发访问，高并发成为了应用程序的一个大问题。Go语言因为其设计的简洁性、优良的并发特性、强大的语法等特点而受到了广泛的欢迎。Go语言的高并发特性为开发者处理高并发问题提供了便捷的手段，极大地提高了程序的运行效率。</p><h3 id="2-Goroutine：Go语言高并发的基石"><strong>2. Goroutine：Go语言高并发的基石</strong></h3><h4 id="2-1-Goroutine是什么？"><em><strong>2.1 Goroutine是什么？</strong></em></h4><p>Goroutine是Go语言中实现并发的一种机制，可以理解为“轻量级线程”，相较于传统的线程，它的创建和销毁的开销都非常小，可以同时运行上万个 goroutine 而不会占用过多的内存。在 Go 语言中，通过 go 关键字就可以启动一个 goroutine。</p><h4 id="2-2-Goroutine的调度器"><em><strong>2.2 Goroutine的调度器</strong></em></h4><p>Go语言的 Goroutine 调度器是 Go 语言运行时系统的一部分，采用的是协程和线程的混合调度方式（M：N调度），可根据硬件真实线程资源进行动态调整，保证了并发和性能之间的平衡。</p><h4 id="2-3-Goroutine的轻量级"><em><strong>2.3 Goroutine的轻量级</strong></em></h4><p>Goroutine 的创建和销毁非常轻量级，在 go 语言中可以在短时间内创建大量的 Goroutine。Goroutine 的栈空间大小只有2KB，因此每个 Goroutine 的内存占用非常小。</p><h3 id="3-Channel：多Goroutine之间通讯的桥梁"><strong><strong>3. Channel：多Goroutine之间通讯的桥梁</strong></strong></h3><h4 id="3-1-Channel的定义和声明"><em><strong>3.1 Channel的定义和声明</strong></em></h4><p>Go 语言内置了两种类型的Channel，分别为带缓冲区的和不带缓冲区的，以下是带缓存Channel的定义和声明：</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">make</span>(chan <span class="title class_">Type</span>, bufferSize)</span><br></pre></td></tr></table></figure><h4 id="3-2-Channel的用法"><em><strong>3.2 Channel的用法</strong></em></h4><p>Go语言的Channel在Goroutine协作上有着极大的作用，可以在其中一个Goroutine卡主等待其协程取走，或者多个Goroutine之间进行数据传递与同步，比如：</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">func <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// go程之间通信，初始化一个channel类型变量</span></span><br><span class="line">    msg := <span class="title function_">make</span>(chan string, <span class="number">1</span>)</span><br><span class="line">    go <span class="title function_">func</span>(<span class="params"></span>) &#123; msg &lt;- <span class="string">&quot;Hello World&quot;</span> &#125;()</span><br><span class="line">    <span class="comment">// 读取信息</span></span><br><span class="line">    res := <span class="language-xml">&lt;-msg</span></span><br><span class="line"><span class="language-xml">    fmt.Println(res)</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-Channel的底层实现"><em><strong>3.3 Channel的底层实现</strong></em></h4><p>可以将channel看作一个队列，先进先出，底层是由互斥锁和条件变量实现的。在有缓冲的情况下，队列容量不会扩张，超出容量部分的元素向队列内添加时将会阻塞作者Goroutine，队列为空时在读取队列中的元素时也会阻塞执行者Goroutine。在无缓存模式下，通道没有额外的缓冲区，每个接收者都会阻塞，直到发送者将值发送到通道中。</p><h3 id="4-select：多路复用的神器"><strong>4. select：多路复用的神器</strong></h3><h4 id="4-1-select的基本语法和作用"><em><strong>4.1 select的基本语法和作用</strong></em></h4><p>select 语句是Go语言中用于处理异步 IO 操作的一个关键子句，使用 select 可以监听多个 channel 的数据流动，一旦其中某个 channel 有数据流动，则对应的case分支就会被执行。</p><h4 id="4-2-select和Channel的结合"><em><strong>4.2 select和Channel的结合</strong></em></h4><p>在读写Channel时可以结合使用select语句，比如：</p><p>代码语言：javascript</p><p>复制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func <span class="title function_">customSleep</span>(<span class="params">s int</span>) &#123;</span><br><span class="line">    select &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="language-xml">&lt;-time.After(time.Duration(s) * time.Second):</span></span><br><span class="line"><span class="language-xml">        return</span></span><br><span class="line"><span class="language-xml">    &#125;</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">func main() &#123;</span></span><br><span class="line"><span class="language-xml">    fmt.Println(&quot;Start&quot;)</span></span><br><span class="line"><span class="language-xml">    customSleep(5)</span></span><br><span class="line"><span class="language-xml">    fmt.Println(&quot;End&quot;)</span></span><br><span class="line"><span class="language-xml">&#125;</span></span><br></pre></td></tr></table></figure><p>这段代码通过 select 监听 time.After() 的 channel，当该 channel 被触发，则 customSleep() 中的 goroutine 将会退出。</p><h3 id="5-并发安全的特性"><strong>5. 并发安全的特性</strong></h3><h4 id="5-1-原子操作和互斥锁"><em><strong>5.1 原子操作和互斥锁</strong></em></h4><p>Go语言的并发特性支持原子操作和互斥锁来保证程序的并发安全。可以通过 atomic 包实现原子操作，通过 sync 包实现互斥锁，从而解决多个 Goroutine 同时访问共享资源的问题。</p><h4 id="5-2-WaitGroup和Once的使用"><em><strong>5.2 WaitGroup和Once的使用</strong></em></h4><p>sync 包中提供的 WaitGroup 和 Once 分别用于等待组和执行一次的场景。比如WaitGroup可以用来等待所有 Goroutine 完成后再执行下一步操作，Once可以用来确保某个函数只被执行一次。</p><h4 id="5-3-其他的并发安全特性"><em><strong>5.3 其他的并发安全特性</strong></em></h4><p>Go语言还提供了一些其他的并发安全的特性，比如Mutex、RWMutex等，这些特性允许多个 Goroutine 同时读取一个资源，但是只允许一个 Goroutine 写入数据，在写入数据时，所有 Goroutine 都需要等待，从而避免了并发写入造成的数据竞争和语义混乱的情况。</p><p>本文详细介绍了Go语言高并发的特点和优势，主要包括Goroutine、Channel、select、并发安全等多个方面。Go语言的高并发特性在应对互联网大规模并发访问方面提供了极大的便利，让程序员能够很方便地编写高效、稳定的并发程序。</p><h2 id="总结">总结</h2><p>Go语言（Golang）由谷歌开发，具有并发处理能力强、编译速度快和内存管理高效等优势，非常适用于高并发Web服务和分布式系统。字节跳动采用Go语言，并通过模块化开发、高可扩展性和监控异常处理等架构设计，实现了高效的推送、搜索和视频转码服务，成功应对了复杂业务需求和用户增长。Go语言的Goroutine、Channel和select等特性极大地提高了程序的并发处理能力和运行效率。</p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFF-服务于前端的后端</title>
      <link href="/posts/bd0326b3.html"/>
      <url>/posts/bd0326b3.html</url>
      
        <content type="html"><![CDATA[<h1>BFF-服务于前端的后端</h1><h2 id="前端演化史">前端演化史</h2><h3 id="Web-1-0">Web 1.0</h3><p>故事都得从long long ago说起，让我们先来回顾web 1.0，那时候的网站如下所示：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161832067.webp" alt="img"></p><p>Web 1.0</p><p>第一代Web架构很简单，纯后端网页渲染；就是客户端每次向服务器请求都会返回一个特定的html页面，js都没啥大用场。我学生时代流行的JSP就属于这个范畴。后来上班了，发现厂里的操作更风骚，用的是<strong>string拼接html</strong>的动态渲染技术，当时极为震惊。</p><h3 id="Web-2-0">Web 2.0</h3><p>时间又到了10年前，手机业务开始蓬勃发展；受限于网络传输，由后端反复送html到前端（后端渲染）的技术很难适应新的业务场景。</p><p>这时候聪明的小伙子们想到了将数据格式转化成JSON，并通过api调用提供给前端使用——前后端解耦。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161832302.webp" alt="img"></p><p>Web 2.0</p><p>此后的变化是一系列的JS前端框架方兴未艾；得益于技术演进，前后端技术正式分离，Web交互空前丰富。</p><h3 id="微服务时代">微服务时代</h3><p>前端在剧烈演进，后端也悄然发生着变化：微服务、中台战略这类词汇充斥在各类技术架构中。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161832031.webp" alt="img"></p><p>Micro-services</p><p>客户端与微服务交互成为了新的考量。应对微服务的方案很多：</p><ul><li><p>API Gateway</p><p>比较直观的方案就是利用api网关分发请求：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161832903.webp" alt="img"></p><p>API Gateway</p></li><li><p>CORS</p><p>第二个想到的是前端跨域请求。前端分别向不同微服务发出请求，再将回调数据在Flux层处理后反映在DOM上。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161832123.webp" alt="img"></p><p>CORS</p></li></ul><hr><p>上述两种方案，在业务权责上有明显偏重。怎么看出来呢？看数据的组装、聚合、裁剪放在哪一块就行了。</p><p>做过前端的小伙伴一般都能理解这一点：网页各个子模块的展示是很琐碎的：有时是一个单一字符串的显示，有时是多表联结的表单渲染。</p><p>方案一中，后端有时需要准备力度很细的数据返回，这个就要求前后端频繁沟通。而另一些场景，后端又需要构造各种级联表单，以致微服务之间调度频繁；而微服务的本质是清晰的界限上下文，因此在<strong>某些场景下</strong>这种设计会导致领域建模变得较为复杂。</p><p>再说一下方案二。前端<strong>分层</strong>和<strong>建模</strong>是最近比较流行的设计趋势，有一些流派甚至喊出了前端DDD，我也挺喜欢这种趋势的。说实在，后端编写接口挺麻烦的，不如提供一些粗粒度的api，交由前端酌情处理。只是传输负载可能会比较大；还有就是在多平台开发时，各平台需要重复组织数据，这就显得很冗余了。</p><h3 id="BFF">BFF</h3><p>有没有更优雅的解决方式呢？嗯，不如将组装、聚合、裁剪这部分业务单独拎出来，组成一个叫<code>Back-end for Front-end</code>的中间层。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406161832088.webp" alt="img"></p><p>BFF</p><blockquote><p>没有什么是加一个中间层解决不了的，如果有，就加两个…… ——鲁迅</p></blockquote><p>BFF就是老生长谈的中间层概念，是上述一二方案的折衷解法。实现上没太大限制，就是一层nodejs，能做请求转发和数据转化即可。Nodejs既配合了前端技术栈，也更适应向微服务的并发请求。我自己的项目就是在Node上跑了一个Graphql的服务；也可以做成对前Restful、对后RPC的实现；还可以在BFF上加cache、鉴权等等操作，具体可以根据自身需求改造。</p><h2 id="BFF优缺点">BFF优缺点</h2><p>回顾完前端演化史，我们再来分析BFF利弊。</p><p>BFF作为中间层，优点是：</p><ul><li>前后端彻底分离，即便是后期有微服务迁移，也不需改动前端代码</li><li>业务更向前靠拢，琐碎的api由前端开发自己决定，更适配前端框架</li><li>BFF可以自开mock，插件也能生成API文档，相比后端单开这类服务要方便些吧</li><li>留给后端更清晰的服务边界，只需要提供粗粒度的接口即可</li></ul><p>我自己的项目就直接把<strong>BFF+前端</strong>一齐从后端repo里分离出来，独立开发独立部署。尤其是在多应用场景里，BFF共享后端是很优雅的中台设计。</p><p>当然，BFF的缺点也很明显——增加了系统的复杂度，这会导致一系列的连锁反应</p><ul><li>中间层转发会增加请求延迟。</li><li>需要保证端到端测试</li><li>必须随时准备好后端异常请求</li><li>BFF分成会增加开发成本</li></ul><p>说说我自己的经历吧。我们的项目是由两三个mono应用发展过来的，在大约一年时间里逐步完成了前后端分离、微服务、BFF分层等转型。本以为这一堆操作可以帮助开发人员将心力集中在更细节的业务范围，效率理应有所提升。但后期猛然发现，小朋友的开发方式是这样的：开frontend，开BFF，开各种后端，开local DB；在跨应用交互场景中，还得再开另一套front和BFF。直接吐血了——我已经为他们准备好各层单开的方式了……</p><p>我反复思索了自己的问题：</p><ol><li>系统分层了，但是人的职责并没有分层，反模式！违反了康威定律，三五个开发甚至该考虑服务合并了。</li><li>没有形成技术共识。我是一步步拆分系统过来的，但是那些和我一起经历过拆分的“元老”已经相继离职了，新来的小朋友很难体会当中的曲折。</li></ol><p>所以说系统设计时还是要依据奥卡姆剃刀原则——若无必要，勿增实体。</p><h2 id="小结">小结</h2><p>今天介绍了一个简单的系统设计知识——BFF。我们在回顾前端演变史后，应该可以感觉到，BFF是系统不断演进的结果；在采用BFF设计时，也应该正确地把握演进步调。个人的经验是，BFF比较适合放在系统重构阶段：比如采用<a href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.microsoft.com%2Fen-us%2Fazure%2Farchitecture%2Fpatterns%2Fstrangler">绞杀者模式</a>（strangler pattern）迁移系统（即在遗产代码外添加新功能做成微服务）；BFF既可以扮演旧系统的代理，也可以为新功能提供新形式的接口。</p><hr><h2 id="题外话">题外话</h2><p>最后还有一些妄语吧。大家也看到了BFF这类系统设计并不需要特别深邃的思索，技术实现上也没过多的限制；但真正采用时往往又是另一番景象。究其缘由还是人比系统更复杂。说来道去，开发团队中，若底层能反映问题，中层能上通下达，高层能及时调整，绝大多数所谓的高阶系统都是水到渠成的。不过组织上的事讳莫如深，毕竟不适合随意谈论。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL基础知识总结</title>
      <link href="/posts/badad45e.html"/>
      <url>/posts/badad45e.html</url>
      
        <content type="html"><![CDATA[<h1>SQL基础知识总结</h1><h2 id="一、SQL-概述">一、SQL 概述</h2><h3 id="1、什么是-SQL">1、什么是 SQL</h3><p>==SQL（Structured Query Language）==是“结构化<a href="https://so.csdn.net/so/search?q=%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80&amp;spm=1001.2101.3001.7020">查询语言</a>”，它是对关系型数据库的操作语言。它可以应用到所有关系型数据库中，例如：MySQL、Oracle、SQL Server 等。SQL 标准（ANSI/ISO）有：</p><ul><li>SQL-92：1992 年发布的 SQL 语言标准；</li><li>SQL:1999：1999 年发布的 SQL 语言标签；</li><li>SQL:2003：2003 年发布的 SQL 语言标签；</li></ul><p>这些标准就与 JDK 的版本一样，在新的版本中总要有一些语法的变化。不同时期的数据库对不同标准做了实现。</p><p>虽然 SQL 可以用在所有<a href="https://so.csdn.net/so/search?q=%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&amp;spm=1001.2101.3001.7020">关系型数据库</a>中，但很多数据库还都有标准之后的一些语法，我们可以称之为“方言”。例如 MySQL 中的 LIMIT 语句就是 MySQL 独有的方言，其它数据库都不支持！当然，Oracle 或 SQL Server 都有自己的方言。</p><h3 id="2、语法要求">2、语法要求</h3><ul><li>SQL 语句可以单行或多行书写，以分号结尾；</li><li>可以用空格和缩进来来增强语句的可读性；</li><li>关键字不区别大小写，建议使用大写；</li></ul><hr><h2 id="二、SQL-分类">二、SQL 分类</h2><ul><li>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</li><li>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</li><li>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</li><li>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）</li></ul><h2 id="三、DDL（Data-Definition-Language）：数据定义语言">三、DDL（Data Definition Language）：数据定义语言</h2><h3 id="基本操作">基本操作</h3><p>查看所有数据库：show databases；</p><p>切换数据库：use mydb1，切换到 mydb1 数据库；</p><h3 id="1-操作数据库">1.操作数据库</h3><ol><li>创建数据库：CREATE DATABASE [IF NOT EXISTS] mydb1；</li></ol><p>例如：<code>CREATE DATABASE mydb1</code>，创建一个名为 mydb1 的数据库。如果这个数据已经存在，那么会报错。<br>例如 <code>CREATE DATABASE IF NOT EXISTSmydb1</code>，在名为 mydb1 的数据库不存在时创建该库，这样可以避免报错。</p><hr><ol><li>删除数据库：DROP DATABASE [IF EXISTS] mydb1；</li></ol><p>例如：<code>DROP DATABASE mydb1</code>，删除名为 mydb1 的数据库。如果这个数据库不存在，那么会报错。DROP DATABASE IF EXISTS mydb1，就算 mydb1不存在，也不会的报错。</p><hr><ol><li>修改数据库编码：ALTER DATABASE mydb1 CHARACTER SET utf8</li></ol><p>修改数据库 mydb1 的编码为 utf8。注意，在 MySQL 中所有的 UTF-8 编码都<br>不能使用中间的<code>“-”</code>，即 UTF-8 要书写为 UTF8。</p><hr><h3 id="2-数据类型">2.数据类型</h3><p>MySQL 与 Java、C 一样，也有数据类型MySQL 中数据类型主要应用在列上。<br>常用类型：</p><ul><li><strong>int</strong>：整型</li><li><strong>double</strong>：浮点型，例如 double(5,2)表示最多 5 位，其中必须有 2 位小数，即最大值为 999.99；</li><li><strong>decimal</strong>：泛型型，在表单线方面使用该类型，因为不会出现精度缺失问题；</li><li><strong>char</strong>：固定长度字符串类型；(当输入的字符不够长度时会补空格)</li><li><strong>varchar</strong>：固定长度字符串类型；</li><li><strong>text</strong>：字符串类型；</li><li><strong>blob</strong>：字节类型；</li><li><strong>date</strong>：日期类型，格式为：yyyy-MM-dd；</li><li><strong>time</strong>：时间类型，格式为：hh:mm:ss</li><li><strong>timestamp</strong>：时间戳类型；</li></ul><h3 id="3-操作表">3.操作表</h3><p>创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">列名 列类型, </span><br><span class="line">列名 列类型,</span><br><span class="line">...... </span><br><span class="line">);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><p>例如，创建stu表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu(</span><br><span class="line">sid <span class="type">CHAR</span>(<span class="number">6</span>), </span><br><span class="line">sname <span class="type">VARCHAR</span>(<span class="number">20</span>), </span><br><span class="line">age <span class="type">INT</span>, </span><br><span class="line">gender <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure><p>查看表的结构</p><p>DESC 表名；</p><p>删除表</p><p>DROP TABLE 表名；</p><p>修改表</p><ol><li>添加列：给 stu 表添加 classname 列<br><code>ALTER TABLE stu ADD (classname varchar(100));</code></li><li>修改列的数据类型：修改 stu 表的 gender 列类型为 CHAR(2)<br><code>ALTER TABLE stu MODIFY gender CHAR(2);</code></li><li>修改列名：修改 stu 表的 gender 列名为 sex<br><code>ALTER TABLE stu change gender sex CHAR(2);</code></li><li>删除列：删除 stu 表的 classname 列<br><code>ALTER TABLE stu DROP classname;</code></li><li>修改表名称：修改 stu 表名称为 student<br><code>ALTER TABLE stu RENAME TO student;</code></li></ol><hr><h2 id="四、DML（Data-Manipulation-Language）：数据操作语言">四、DML（Data Manipulation Language）：数据操作语言</h2><h3 id="1-插入数据">1.插入数据</h3><p>语法 1：<br><code>INSERT INTO 表名(列名 1,列名 2, …) ;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(sid, sname,age,gender) <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1001&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>, <span class="number">23</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu(sid, sname) <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1001&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>语法 2：<br><code>INSERT INTO 表名 VALUES(值 1,值 2,…);</code><br>因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1002&#x27;</span>, <span class="string">&#x27;liSi&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>注意：所有字符串数据必须使用单引用！</strong></p><h3 id="2-修改数据">2.修改数据</h3><p>语法：<br><code>UPDATE 表名 SET 列名 1=值 1, … 列名 n=值 n [WHERE 条件];</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’zhangSanSan’, age<span class="operator">=</span>’<span class="number">32</span>’, gender<span class="operator">=</span>’female’ <span class="keyword">WHERE</span> sid<span class="operator">=</span>’s_1001’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’liSi’, age<span class="operator">=</span>’<span class="number">20</span>’<span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">50</span> <span class="keyword">AND</span> gender<span class="operator">=</span>’male’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’wangWu’, age<span class="operator">=</span>’<span class="number">30</span>’<span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">60</span> <span class="keyword">OR</span> gender<span class="operator">=</span>’female’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> gender<span class="operator">=</span>’female’<span class="keyword">WHERE</span> gender <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> sname<span class="operator">=</span>’zhaoLiu’;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><h3 id="3-删除数据">3.删除数据</h3><p>语法 1：<br><code>DELETE FROM 表名 [WHERE 条件];</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sid<span class="operator">=</span>’s_1001’<span class="number">003</span>B;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname<span class="operator">=</span>’chenQi’ <span class="keyword">OR</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>语法 2：<br>TRUNCATE TABLE 表名;</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> stu;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>两者之间的区别：<br>虽然 TRUNCATE 和 DELETE 都可以删除表的所有记录，但有原理不同。DELETE的效率没有 TRUNCATE 高！<br>TRUNCATE 其实属性 DDL 语句，因为它是先 DROP TABLE，再 CREATE TABLE。<br>而且TRUNCATE删除的记录是无法回滚的，但DELETE删除的记录是可以回滚的（回滚是事务的知识！）。</p><hr><h2 id="五、DCL（Data-Control-Language）：数据控制语言">五、DCL（Data Control Language）：数据控制语言</h2><h3 id="1-创建用户">1.创建用户</h3><p>语法：<br><code>CREATE USER ‘用户名’@地址 IDENTIFIED BY '密码';</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘user1’<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> ‘<span class="number">123</span>’;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘user2’@’<span class="operator">%</span>’ IDENTIFIED <span class="keyword">BY</span> ‘<span class="number">123</span>’;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="2-给用户授权">2.给用户授权</h3><p>语法：<br><code>GRANT 权限 1, … , 权限 n ON 数据库.* TO ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">TO</span> user2<span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="3-撤销授权">3.撤销授权</h3><p>语法：<br><code>REVOKE 权限 1, … , 权限 n ON 数据库.* FROM ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="4-查看用户权限">4.查看用户权限</h3><p>语法：<br><code>SHOW GRANTS FOR ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="5-删除用户">5.删除用户</h3><p>语法：<br><code>DROP USER ‘用户名’@地址;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> ‘user1’<span class="variable">@localhost</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="6-修改用户密码（以root身份）">6.修改用户密码（以root身份）</h3><p>语法 ：<br><code>use mysql;</code><br><code>alter user '用户名'@localhost identified by '新密码';</code></p><hr><h2 id="六、DQL（Data-Query-Language）：数据查询语言">六、DQL（Data Query Language）：数据查询语言</h2><p>数据库执行 DQL 语句不会对数据进行改变，而是让数据库发送结果集给客户端。</p><p>语法：<br>select 列名 ----&gt; 要查询的列名称<br>from 表名 ----&gt; 要查询的表名称<br>where 条件 ----&gt; 行条件<br>group by 分组列 ----&gt; 对结果分组<br>having 分组条件 ----&gt; 分组后的行条件<br>order by 排序列 ----&gt; 对结果分组<br>limit 起始行, 行数 ----&gt; 结果限定</p><h3 id="创建数据库：Info，在-Info-下创建如下表：">创建数据库：Info，在 Info 下创建如下表：</h3><p>☆学生表：stu：<br><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/2021021301182633.png" alt="在这里插入图片描述"><br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903498.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stu (</span><br><span class="line">sid <span class="type">CHAR</span>(<span class="number">6</span>), </span><br><span class="line">sname <span class="type">VARCHAR</span>(<span class="number">50</span>), </span><br><span class="line">age <span class="type">INT</span>, </span><br><span class="line">gender <span class="type">VARCHAR</span>(<span class="number">50</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1001&#x27;</span>, <span class="string">&#x27;liuYi&#x27;</span>, <span class="number">35</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1002&#x27;</span>, <span class="string">&#x27;chenEr&#x27;</span>, <span class="number">15</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1003&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>, <span class="number">95</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1004&#x27;</span>, <span class="string">&#x27;liSi&#x27;</span>, <span class="number">65</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1005&#x27;</span>, <span class="string">&#x27;wangWu&#x27;</span>, <span class="number">55</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1006&#x27;</span>, <span class="string">&#x27;zhaoLiu&#x27;</span>, <span class="number">75</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1007&#x27;</span>, <span class="string">&#x27;sunQi&#x27;</span>, <span class="number">25</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1008&#x27;</span>, <span class="string">&#x27;zhouBa&#x27;</span>, <span class="number">45</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1009&#x27;</span>, <span class="string">&#x27;wuJiu&#x27;</span>, <span class="number">85</span>, <span class="string">&#x27;male&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1010&#x27;</span>, <span class="string">&#x27;zhengShi&#x27;</span>, <span class="number">5</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;S_1011&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure><p>☆雇员表：emp<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903446.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">empno <span class="type">INT</span>, </span><br><span class="line">ename <span class="type">VARCHAR</span>(<span class="number">50</span>), </span><br><span class="line">job <span class="type">VARCHAR</span>(<span class="number">50</span>), </span><br><span class="line">mgr <span class="type">INT</span>, </span><br><span class="line">hiredate <span class="type">DATE</span>,</span><br><span class="line">sal <span class="type">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>), </span><br><span class="line">comm <span class="type">decimal</span>(<span class="number">7</span>,<span class="number">2</span>), </span><br><span class="line">deptno <span class="type">INT</span></span><br><span class="line">) ;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7369</span>,<span class="string">&#x27;SMITH&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7902</span>,<span class="string">&#x27;1980-12-17&#x27;</span>,<span class="number">800</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7499</span>,<span class="string">&#x27;ALLEN&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-02-20&#x27;</span>,<span class="number">1600</span>,<span class="number">300</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7521</span>,<span class="string">&#x27;WARD&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-02-22&#x27;</span>,<span class="number">1250</span>,<span class="number">500</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7566</span>,<span class="string">&#x27;JONES&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="number">7839</span>,<span class="string">&#x27;1981-04-02&#x27;</span>,<span class="number">2975</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7654</span>,<span class="string">&#x27;MARTIN&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-09-28&#x27;</span>,<span class="number">1250</span>,<span class="number">1400</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7698</span>,<span class="string">&#x27;BLAKE&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="number">7839</span>,<span class="string">&#x27;1981-05-01&#x27;</span>,<span class="number">2850</span>,<span class="keyword">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7782</span>,<span class="string">&#x27;CLARK&#x27;</span>,<span class="string">&#x27;MANAGER&#x27;</span>,<span class="number">7839</span>,<span class="string">&#x27;1981-06-09&#x27;</span>,<span class="number">2450</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7788</span>,<span class="string">&#x27;SCOTT&#x27;</span>,<span class="string">&#x27;ANALYST&#x27;</span>,<span class="number">7566</span>,<span class="string">&#x27;1987-04-19&#x27;</span>,<span class="number">3000</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7839</span>,<span class="string">&#x27;KING&#x27;</span>,<span class="string">&#x27;PRESIDENT&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;1981-11-17&#x27;</span>,<span class="number">5000</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7844</span>,<span class="string">&#x27;TURNER&#x27;</span>,<span class="string">&#x27;SALESMAN&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-09-08&#x27;</span>,<span class="number">1500</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7876</span>,<span class="string">&#x27;ADAMS&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7788</span>,<span class="string">&#x27;1987-05-23&#x27;</span>,<span class="number">1100</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7900</span>,<span class="string">&#x27;JAMES&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7698</span>,<span class="string">&#x27;1981-12-03&#x27;</span>,<span class="number">950</span>,<span class="keyword">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7902</span>,<span class="string">&#x27;FORD&#x27;</span>,<span class="string">&#x27;ANALYST&#x27;</span>,<span class="number">7566</span>,<span class="string">&#x27;1981-12-03&#x27;</span>,<span class="number">3000</span>,<span class="keyword">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">values</span>(<span class="number">7934</span>,<span class="string">&#x27;MILLER&#x27;</span>,<span class="string">&#x27;CLERK&#x27;</span>,<span class="number">7782</span>,<span class="string">&#x27;1982-01-23&#x27;</span>,<span class="number">1300</span>,<span class="keyword">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure><p>☆部门表：dept<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903646.png" alt="在这里插入图片描述"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">deptno <span class="type">INT</span>, </span><br><span class="line">dname <span class="type">varchar</span>(<span class="number">14</span>),</span><br><span class="line">loc <span class="type">varchar</span>(<span class="number">13</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">10</span>, <span class="string">&#x27;ACCOUNTING&#x27;</span>, <span class="string">&#x27;NEW YORK&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">20</span>, <span class="string">&#x27;RESEARCH&#x27;</span>, <span class="string">&#x27;DALLAS&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">30</span>, <span class="string">&#x27;SALES&#x27;</span>, <span class="string">&#x27;CHICAGO&#x27;</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">values</span>(<span class="number">40</span>, <span class="string">&#x27;OPERATIONS&#x27;</span>, </span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><h3 id="1-基础查询">1.基础查询</h3><p>查询所有列<br><code>SELECT * FROM 表名;</code><br>(* ：通配符，表示所有列)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>查询指定列<br><code>SELECT 列名 1, 列名 2, …列名 n FROM 表名;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sid, sname, age <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="2-条件查询">2.条件查询</h3><p>条件查询介绍<br>条件查询就是在查询时给出 WHERE 子句，在 WHERE 子句中可以使用如下运算符及关键字：</p><ul><li>=、!=、&lt;&gt;、&lt;、&lt;=、&gt;、&gt;=；</li><li>BETWEEN…AND；</li><li>IN(set)；</li><li>IS NULL；</li><li>AND；</li><li>OR；</li><li>NOT；</li></ul><p>举例说明<br>查询性别为女，并且年龄小于 50 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE gender='female' AND age&lt;50;</code></p><p>查询学号为 S_1001，或者姓名为 liSi 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE sid ='S_1001' OR sname='liSi';</code></p><p>查询学号为 S_1001，S_1002，S_1003 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE sid IN ('S_1001','S_1002','S_1003')</code></p><p>查询学号不是 S_1001，S_1002，S_1003 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE sid NOT IN ('S_1001','S_1002','S_1003');</code></p><p>查询年龄为 null 的记录<br><code>SELECT * FROM stu</code><br><code>WHERE age IS NULL;</code></p><p>查询年龄在 20 到 40 之间的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE age&gt;=20 AND age&lt;=40;</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE age BETWEEN 20 AND 40;</code></p><p>查询性别非男的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE gender!='male';</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE gender&lt;&gt;'male';</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE NOT gender='male';</code></p><p>查询姓名不为 null 的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE NOT sname IS NULL;</code><br>或者<br><code>SELECT * FROM stu</code><br><code>WHERE sname IS NOT NULL;</code></p><hr><h3 id="3-模糊查询">3.模糊查询</h3><p><code>SELECT 字段 FROM 表 WHERE 某字段 Like 条件</code><br>其中关于条件，SQL 提供了两种匹配模式：</p><ol><li><code>%</code> ：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情<br>况下若是中文，请使用两个百分号（%%）表示。</li><li><code>_ </code>： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字 符长度语句。</li></ol><p>举例说明<br>查询姓名由 5 个字母构成的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE '_ _ _ _ _';</code></p><p>查询姓名由 5 个字母构成，并且第 5 个字母为“i”的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE '_ _ _ _i';</code></p><p>查询姓名以“z”开头的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE 'z%';</code><br>其中“%”匹配 0~n 个任何字母。</p><p>查询姓名中第 2 个字母为“i”的学生记录<br><code>SELECT * FROM stu</code><br><code>WHERE sname LIKE '_i%';</code></p><p>\查询姓名中包含“a”字母的学生记录<br><code>SELECT * FROM stu WHERE sname LIKE '%a%';</code></p><h3 id="4-字段控制查询">4.字段控制查询</h3><p>去掉重复记录<br>去除重复记录（两行或两行以上记录中系列的上的数据都相同），例如 emp 表中 sal 字段就存在相同的记录。当只查询 emp 表的 sal 字段时，那么会出现重复记录，那么想去除重复记录，需要使用 DISTINCT：<br><code>SELECT DISTINCT sal FROM emp;</code></p><p>查看雇员的月薪与佣金之和<br>因为 sal 和 comm 两列的类型都是数值类型，所以可以做加运算。如果 sal 或 comm 中有一个字段不是数值类型，那么会出错。<br><code>SELECT *,</code><br><code>sal+comm FROM emp;</code><br>comm 列有很多记录的值为 NULL，因为任何东西与 NULL 相加结果还是 NULL，所以结算结果可能会出现 NULL。下面使用了把 NULL 转换成数值 0 的函数 IFNULL：<br><code>SELECT *, sal+IFNULL(comm,0) FROM emp;</code></p><p>给列名添加别名<br>在上面查询中出现列名为 sal+IFNULL(comm,0)，这很不美观，现在我们给这一列给出一个别名，为 total：<br><code>SELECT *, sal+IFNULL(comm,0) AS total FROM emp;</code><br>给列起别名时，是可以省略 AS 关键字的：<br><code>SELECT *, sal+IFNULL(comm,0) total FROM emp;</code></p><hr><h3 id="5-排序">5.排序</h3><p>查询所有学生记录，按年龄升序排序<br><code>SELECT * FROM stu</code><br><code>ORDER BY sage ASC;</code><br>或者<br><code>SELECT * FROM stu ORDER BY sage;</code></p><p>查询所有学生记录，按年龄降序排序<br><code>SELECT * FROM stu</code><br><code>ORDER BY age DESC;</code></p><p>查询所有雇员，按月薪降序排序，如果月薪相同时，按编号升序排序<br><code>SELECT * FROM emp</code><br><code>ORDER BY sal DESC ,empno ASC;</code></p><hr><h3 id="6-聚合函数">6.聚合函数</h3><p>聚合函数是用来做纵向运算的函数：</p><ul><li>COUNT()：统计指定列不为 NULL 的记录行数；</li><li>MAX()：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>MIN()：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>SUM()：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为 0；</li><li>AVG()：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为 0；</li></ul><p>COUNT：当需要纵向统计时可以使用 COUNT()。</p><p>查询 emp 表中记录数：<br><code>SELECT COUNT(*) AS cnt FROM emp;</code></p><p>查询 emp 表中有佣金的人数：<br><code>SELECT COUNT(comm) cnt FROM emp;</code><br>注意，因为 count()函数中给出的是 comm 列，那么只统计 comm 列非 NULL 的行数。</p><p>查询 emp 表中月薪大于 2500 的人数：<br><code>SELECT COUNT(*) FROM emp WHERE sal &gt; 2500;</code></p><p>统计月薪与佣金之和大于 2500 元的人数：<br><code>SELECT COUNT(*) AS cnt FROM emp WHERE sal+IFNULL(comm,0) &gt; 2500;</code><br>查询有佣金的人数，以及有领导的人数：<br><code>SELECT COUNT(comm), COUNT(mgr) FROM emp;</code></p><p>SUM 和 AVG：当需要纵向求和时使用 sum()函数。</p><p>查询所有雇员月薪和：<br><code>SELECT SUM(sal) FROM emp;</code></p><p>查询所有雇员月薪和，以及所有雇员佣金和：<br><code>SELECT SUM(sal), SUM(comm) FROM emp;</code></p><p>查询所有雇员月薪+佣金和：<br><code>SELECT SUM(sal+IFNULL(comm,0)) FROM emp;</code></p><p>统计所有员工平均工资：<br><code>SELECT SUM(sal), COUNT(sal) FROM emp;</code><br>或者<br><code>SELECT AVG(sal) FROM emp;</code></p><p>MAX 和 MIN<br>查询最高工资和最低工资：<br><code>SELECT MAX(sal), MIN(sal) FROM emp;</code></p><h3 id="7-分组查询">7.分组查询</h3><p>分组查询</p><p>当需要分组查询时需要使用 <code>GROUP BY </code>子句，例如查询每个部门的工资和，这说明要使用部分来分组。</p><p>查询每个部门的部门编号和每个部门的工资和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="built_in">SUM</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>查询每个部门的部门编号以及每个部门的人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure><p>查询每个部门的部门编号以及每个部门工资大于 1500 的人数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno ,<span class="built_in">COUNT</span>(<span class="operator">*</span>)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> sal<span class="operator">&gt;</span><span class="number">1500</span>`</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p>HAVING 子句</p><p>查询工资总和大于 9000 的部门编号以及工资和：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> deptno, <span class="built_in">SUM</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">SUM</span>(sal) <span class="operator">&gt;</span> <span class="number">9000</span>;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><p><strong>注意，WHERE 是对分组前记录的条件，如果某行记录没有满足 WHERE 子句的条件，那<br>么这行记录不会参加分组；而 HAVING 是对分组后数据的约束。</strong></p><h3 id="8-LIMIT：用来限定查询结果的起始行，以及总行数。">8.LIMIT：用来限定查询结果的起始行，以及总行数。</h3><p>查询 5 行记录，起始行从 0 开始<br><code>SELECT * FROM emp LIMIT 0, 5;</code><br>注意，起始行从 0 开始，即第一行开始！</p><p>查询 10 行记录，起始行从 3 开始<br><code>SELECT * FROM emp LIMIT 3, 10;</code></p><p>分页查询<br>如果一页记录为 10 条，希望查看第 3 页记录应该怎么查呢？<br> 第一页记录起始行为 0，一共查询 10 行；<br> 第二页记录起始行为 10，一共查询 10 行；<br> 第三页记录起始行为 20，一共查询 10 行；</p><h3 id="9-多表连接查询：-表连接分为内连接和外连接。">9.多表连接查询： 表连接分为内连接和外连接。</h3><p>他们之间最主要的区别：内连接仅选出两张表中互相匹配的记录，外连接会选出其他不匹配的记录。</p><p>例如： 以下是员工表 staff 和职位表 deptno:<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151903280.png" alt="在这里插入图片描述"></p><h4 id="内连接">内连接</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> staff.name,deptname <span class="keyword">from</span> staff,deptno <span class="keyword">where</span></span><br><span class="line">staff.name<span class="operator">=</span>deptno.name;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151901731.png" alt="在这里插入图片描述"></p><h4 id="外连接分为左连接和右连接">外连接分为左连接和右连接</h4><p>左连接：包含左边表中所有的记录，右边表中没有匹配的记录显示为 NULL。<br>右连接：包含右边表中所有的记录，左边表中没有匹配的记录显示为 NULL。</p><p>外连接(左连接)：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> staff.name,deptname <span class="keyword">from</span> staff <span class="keyword">left</span> <span class="keyword">join</span> deptno onstaff.name<span class="operator">=</span>deptno.name;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151901354.png" alt="在这里插入图片描述"><br>外连接（右连接）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> deptname,deptno.name <span class="keyword">from</span> staff <span class="keyword">right</span> <span class="keyword">join</span> deptno ondeptno.name<span class="operator">=</span>staff.name;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151901810.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-缓存穿透、缓存击穿、缓存雪崩</title>
      <link href="/posts/5aff4b42.html"/>
      <url>/posts/5aff4b42.html</url>
      
        <content type="html"><![CDATA[<h1>Redis 缓存穿透，缓存击穿，缓存雪崩</h1><p>在日常开发工作中，缓存技术被广泛利用以增强系统性能和减轻数据库的访问压力。但是，在使用缓存的过程中，我们可能会碰到几个典型问题，比如<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F&amp;spm=1001.2101.3001.7020">缓存穿透</a>、缓存击穿和缓存雪崩。这些问题不仅在实际的应用中需要解决，而且它们也经常在面试中被问到。</p><p>​    然后，大部分的小可爱在准备阶段可能已经熟悉了这些概念，但在面试的紧张氛围下，往往会出现混淆，无法清晰区分缓存穿透、<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF&amp;spm=1001.2101.3001.7020">缓存击穿</a>和缓存雪崩。为了帮助大家深入理解并记住这三种缓存问题，以便在面试或实际工作中能够清晰地识别和解决问题，本文将详细解析这三个缓存问题，并提供一些记忆技巧，确保你不再对它们感到困惑，达到拨云见日、茅塞顿开之功效。</p><h5 id="一、缓存穿透">一、缓存穿透</h5><h6 id="1、什么是缓存穿透？">1、什么是缓存穿透？</h6><p>​    缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。</p><p>​    <strong>那么，我们该怎么记忆缓存穿透呢？</strong></p><p>我们可以这么想，缓存穿透其实就是恶意攻击，就是有人想“穿”过你的防护网(缓存)来“偷”你的家(数据库)，这也就是穿透。或者你这样想，有人想恶意攻击你的数据库，这是不是不好的行为，是不是小偷的行为！这样透和偷，不就联系起来了。那么下次面试官问你缓存穿透是什么的时候。你只要想到透就是偷，就是不好的行为，也就能想到缓存穿透的意思就是别人恶意攻击，故意频繁访问一个不存在的key，来压垮你的数据库。</p><h6 id="2、问题分析">2、问题分析</h6><p>​    缓存穿透现象的核心问题在于请求中使用的key在Redis缓存中无法找到相应的值。这与缓存击穿的情形有本质的不同，后者通常涉及一个有效key的过期失效。在缓存穿透的情况下，传入的key在Redis中根本就不存在。如果黑客故意发送大量不存在的key的请求，这会导致数据库遭受巨大的查询压力，可能会严重威胁到系统的正常运行。因此，在日常开发实践中，对请求参数进行严格的校验是至关重要的。对于那些非法或明显不可能存在的key，系统应该立即返回一个错误提示，而不是让这些请求到达数据库层面。这样不仅可以提升系统的安全性，还能够维护数据库的稳定性和性能。</p><h6 id="3、解决方案">3、解决方案</h6><ul><li><p><strong>缓存空数据</strong></p><p>当出现Redis查不到数据，数据库也查不到数据的情况，我们就把这个key保存到Redis中，设置value=“null”，并设置其一个较短的过期时间，后面再出现查询这个key的请求的时候，直接返回null，就不需要再查询数据库了。</p></li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151846206.png" alt="img"></p><p><strong>优点</strong>：<strong>实现简单</strong>。</p><p><strong>缺点</strong>：1）<strong>耗费内存并且会有失效的情况</strong>。在Redis中缓存大量空值不仅会消耗宝贵的内存资源，而且如果攻击者持续使用随机键进行攻击，这种防御策略就会失效。在这种情况下，不仅数据库可能因过载而崩溃，Redis服务也可能由于内存耗尽而出现拒绝写操作的现象。这样，你的正常需要写入redis的业务也就会跟着受到影响。</p><p>​        2）<strong>数据不一致</strong>。虽然在缓存空值时我们设定了较短的过期时间，但仍存在一种情况：在缓存的空值尚未过期的这段短时间内，数据库中的实际数据可能已经更新，而该键值在数据库中存在了数据。这导致在缓存中的空值仍然被返回，而没有反回真实的数据，从而造成缓存与数据库之间的数据不一致现象。</p><ul><li><strong>布隆过滤器</strong></li></ul><p>​    布隆过滤器提供一种高效的概率型检测机制，用于判断一个元素是否可能在一个集合内。它的工作原理是，当布隆过滤器断言某个键（key）不存在时，这个结论是绝对可靠的；但当它认为某个键存在时，只表示有很高的可能性确实存在，尽管有一定的误判几率。为了缓解缓存穿透的问题，我们可以在Redis缓存层之前部署一道布隆过滤器的防线。将数据库中所有的键导入布隆过滤器中，这样在任何查询到达Redis之前，系统会首先检查该查询的键是否在布隆过滤器中。如果键在布隆过滤器中不存在，那么查询将不会继续前往数据库，而是直接返回结果，以此避免对数据库的不必要访问和潜在的查询压力。通过这样的布隆过滤器前置筛查，我们不仅保护了数据库免受不存在的键的查询压力，还确保了整体系统的性能稳定，即使在高并发查询的环境下也能有效地运作。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151846994.png" alt="img"></p><p><strong>优点</strong>：<strong>占用内存小</strong>。布隆过滤器不需要存储具体的数据项，只需要存储数据的哈希值，因此相比存储实际数据，它占用的内存更少</p><p><strong>缺点</strong>： 1）**存在一定的误判情况。**布隆过滤器存在一定的误判率，即它可能会错误地认为某个不存在的元素存在（假阳性），尽管可以通过调整参数来降低误判率，但无法完全消除。</p><p>​        2）**不可逆性。**布隆过滤器不需要存储具体的数据项，只需要存储数据的哈希值，因此相比存储实际数据，它占用的内存更少。</p><p>​        3）**数据不一致。**为了维护数据的准确性和一致性，理想情况下，当数据库中的数据发生更新时，布隆过滤器也应当进行相应的更新以反映这些变更。然而，布隆过滤器与数据库是两个独立的数据管理实体。所以可能出现的一种情形是，在数据库成功执行了数据更新之后，当尝试更新布隆过滤器时，网络异常发生，导致新增的数据未能及时写入布隆过滤器中。在这种状况下，后续针对这个新加入数据的查询请求将会被布隆过滤器拒绝，因为该数据的键尚未存在于过滤器中。尽管这是一个合理的查询请求，它却被“错误地”拦截了。</p><p>​    在这里，其实我们可以意识到并不存在一个完美无缺的解决方案。最终选择哪种方案必须依据我们的业务场景来定。例如，虽然引入布隆过滤器可以解决缓存穿透导致的内存占用问题，但它同时可能带来其它问题。这也正是我们需要培养的思维方式：每当考虑引入新的技术方栈时，我们必须思考它能够解决哪些问题，以及可能会带来哪些新问题，并要提前规划好如何应对这些潜在的问题**。**</p><p><strong>那么，到底该如何解决这个问题？</strong></p><p>​    在这里，关键的考量因素是我们平台能够承载的并发水平。我们可以根据我们平台的特点去考量平台最大的并发量。然后，再依据最大并发量进行限流，确保即使在极端的高并发情况下，也不会对数据库造成过大压力导致其崩溃。其次，再经过限流后，我们再去考虑并发度高低，并发度低的我们可以简单的使用缓存空值的方案来解决缓存穿透的问题，并发度高的情况下我们还是最好使用布隆过滤器的方案解决缓存穿透问题。</p><p>​     当然，除了上面提到的布隆过滤器和缓存空数据的方案之外，我们还可以通过实施<strong>参数校验</strong>和<strong>拉黑恶意攻击者的IP</strong>来增强对缓存穿透问题的防护。</p><h5 id="二、缓存击穿">二、缓存击穿</h5><h6 id="1、什么是缓存击穿？">1、什么是缓存击穿？</h6><p>​    缓存击穿通常发生在高并发系统中，当某个被频繁访问的数据（热点key）在缓存中的有效期过了，恰好在这个时候有大量的并发请求需要访问这个数据。由于缓存中的数据已经失效，这些并发请求就会直接转发到数据库上，如果数据库的处理能力不足以应对这种突然增加的压力，就可能导致系统响应缓慢甚至崩溃。</p><p>​    <strong>那么，我们该怎么记忆缓存击穿呢？</strong></p><p>​    首先，让我们参考百度百科对“击穿”现象的解释：在强电场的作用下，绝缘材料内部会发生破坏性的放电，导致其绝缘电阻降低，电流增大，最终引发材料的损坏甚至穿孔。现在，我们用这个原理来类比Redis缓存系统中的情况。设想Redis中的缓存数据被组织成一系列的“网格”，这些网格共同构成了一层防御屏障。当某个网格由于某种原因突然变得不可用或丢失时，原本应该被该网格处理的大量请求就会如同电流般穿透这个缺口，直接冲击后端的数据库。这种现象，就类似于电学中的“击穿”，在Redis缓存的语境下，我们称之为缓存击穿。</p><p>​    或者，你也可以这样想。&quot;击穿&quot;中的&quot;击&quot;字与&quot;寄&quot;发音相同。在网络上，当我们说“我寄了”，它通常隐含着“我完了”或者“我死了”的意味。沿着这个思路，缓缓存击穿就好比是某个关键的key“寄”了，导致的大量并发请求打到数据库。所以，只要你能从“击”这个字联想到“寄寄”，便能够自然而然地想到缓存击穿这一概念的具体含义。</p><h6 id="2、问题分析-2">2、问题分析</h6><p>​    核心问题在于，一旦某个热门的key失效，便会导致密集的并发请求直接涌向数据库。因此，解决方案需从两个方向着手：首先，考虑对热点key不设置过期时间以保持其持久有效；其次，探索降低数据库所承受的请求量的方法，以减轻其压力。</p><h6 id="3、解决方案-2">3、解决方案</h6><ul><li>互斥锁</li></ul><p>​    在缓存失效后，通过互斥锁控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151846765.png" alt="img"></p><p><strong>优点</strong>：<strong>1）强一致</strong>。互斥锁能够确保在缓存重建过程中，只有一个线程可以访问数据库并更新缓存，这样可以避免多个线程同时读取到过期的缓存数据，从而保证了数据的强一致性。</p><p>​     <strong>2）实现相对简单</strong>。互斥锁的实现相对简单，不需要复杂的逻辑处理，只需在缓存失效时加锁，更新完毕后释放锁即可。</p><p><strong>缺点</strong>： <strong>吞吐量低</strong>。在高并发的场景下，互斥锁可能会导致系统的可用性降低，因为大量的请求可能会因为等待锁而无法及时得到处理。</p><ul><li>逻辑过期</li></ul><p>​    逻辑过期方案与互斥锁方案在应对缓存击穿问题上确实有着相似之处，它们都通过使用互斥锁来防止同时对同一热点key的缓存进行更新。然而，它们的工作细节和重点略有不同。在逻辑过期方案中，每个缓存项旁边附加了一个额外的字段来表示其逻辑上的过期状态，而不是物理地从缓存系统中移除该数据。这样，即使一个缓存项已标记为逻辑上过期，它仍然存在于缓存中并可以被访问到。这种方法避免了因等待重新加载数据而导致的缓存缺失情况。当一个线程查询某个key的缓存数据时，如果该数据已经处于逻辑过期状态，无论该线程是否成功获取互斥锁，系统都会先返回这个逻辑上过期的数据。这样做的好处是即使在数据更新过程中，也能保证用户能立即得到响应，虽然数据可能是旧的。与此同时，如果某个线程成功获取了互斥锁，这意味着它获得了更新缓存数据的权限。这个线程会创建一个单独的工作线程来负责从数据库检索最新数据、更新缓存，并重置该key的逻辑过期时间。一旦这个过程完成，互斥锁便会被释放。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151847905.png" alt="img"></p><p><strong>优点</strong>：<strong>吞吐量高</strong>。在逻辑过期方案中，即使数据已过期，系统仍会返回过期数据给客户端，而不是等待锁释放后再去数据库拉取最新数据。</p><p><strong>缺点</strong>： **1）牺牲数据一致性。**由于在数据更新过程中，系统可能会返回过期数据，这在一定程度上牺牲了数据的一致性。</p><p>​      **2）实现复杂。**逻辑过期方案需要维护额外的字段来记录每个缓存项的逻辑过期状态，这增加了系统的复杂性。</p><p>​     **3）耗费更多的内存。**因为增加了一个字段来维护逻辑过期的时间，这必定会造成额外的空间占用。</p><p>这里，可能有些小可爱会有一个疑问：<strong>为什么不直接使用热点数据永不过期来代替逻辑过期呢？逻辑过期的数据不也是永不过期吗？折腾这么多又是加字段又是加锁的是为了什么？直接都不过期了不就不会缓存击穿了吗？</strong></p><p>​    实际上，尽管可以选择配置热点数据为永不过期以取代逻辑过期的方案，但逻辑过期的存在有其独特的必要性。逻辑过期允许我们在数据达到过期时间点时主动去刷新缓存中的数据，从而确保数据的更新和准确性。如果没有设置逻辑过期，我们将失去在查询时更新缓存数据的能力，这将导致数据的实时性和一致性难以得到保障。所以，对于不常变更的数据，可以安心设置为永不过期；而对于频繁更新的数据，采用逻辑过期是更为合适的策略。</p><p>​    <strong>那么，什么使用逻辑过期，什么时候使用互斥锁呢？</strong></p><p>根据上面我们总结的这两个方案的优缺点，不难得出当我们追求数据的强一致的时候，就使用互斥锁方案。当我们要求数据更高的吞吐量，并且对数据的一致性要求不高的时候，就使用逻辑过期的方案。</p><h5 id="三、缓存雪崩">三、<a href="https://so.csdn.net/so/search?q=%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9&amp;spm=1001.2101.3001.7020">缓存雪崩</a></h5><h6 id="1、什么是缓存雪崩？">1、什么是缓存雪崩？</h6><p>​    缓存雪崩是指<strong>由于缓存系统的整体失效，导致大量请求直接到达后端数据库，进而可能造成数据库崩溃和整个系统的崩溃</strong>。这种现象通常发生在缓存服务器重启或宕机时，或者是大规模的key同时失效导致的结果。</p><p>​    <strong>那么，我们该怎么记忆缓存雪崩呢？</strong></p><p>​    其实，记住缓存雪崩相比另外两个是比较容易的。雪崩这个词本身就可以生动地描绘了缓存雪崩发生的情境：发挥你的想象，redis就是个雪山，而redis上面的key好比山上一个一个的雪花。突然间，一个自称“天下第一帅”的拙野挥洒着他的帅气，高声发出震天的呐喊：我是天下第一帅！。这一声犹如惊雷贯耳，瞬间引发了山上的积雪大面积崩塌(大量key失效)或者这声吼叫的力量如此巨大，竟像是触发了一场地震，使得整个雪山轰然倒塌（redis服务器宕机）。</p><h6 id="2、问题分析-3">2、问题分析</h6><p>​    造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。</p><h6 id="3、解决方案-3">3、解决方案</h6><ul><li><strong>过期时间随机</strong></li></ul><p>​    在设置失效时间的时候加上一个随机值，比如1-5分钟随机。这样就可以避免了由于使用相同的过期时间导致在某一时刻大量key过期引发的缓存雪崩问题。</p><ul><li><strong>使用熔断机制</strong></li></ul><p>​    当系统流量达到预定的极限时，为避免对数据库造成过大压力，我们将自动显示“系统繁忙”提示。这样做可以确保至少有一部分用户能够顺畅地使用我们的服务。对于未能即时访问的用户，只要多刷新几次，也是可以获得正常访问的。</p><ul><li><strong>缓存预热</strong></li></ul><p>​    缓存预热是一种关键技术，它在系统启动前预先加载关键数据到缓存中，以减少系统上线时对后端数据库的冲击。由于新上线的系统缓存是空的，如果没有预热过程，大量并发请求将直接访问数据库，极有可能在系统上线初期导致服务崩溃。因此，通过在系统上线之前将高频率访问的数据从数据库加载到Redis等缓存系统中，可以确保用户请求首先由缓存服务处理，从而减轻数据库的压力。实施缓存预热通常涉及编写批处理任务，这些任务可以在系统启动期间执行，或者通过定时任务定期去执行。定期执行更能保证数据的实时性，但是，同样会耗费系统的部分性能，尤其是在数据量大的时候。所以，具体选择如何进行预热数据，还是需要综合考虑预热数据量的大小以及预热数据更新的是否频繁等因素。</p><ul><li><strong>redis集群</strong></li></ul><p>​    保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用主从+ 哨兵，Redis集群来避免单个Redis服务器宕机导致整个缓存直接失效。</p><ul><li><strong>多级缓存</strong></li></ul><p>​    通过实施多级缓存策略，我们可以优化系统的性能并降低因缓存失效导致的风险。在这种策略中，本地进程内的缓存充当第一级缓存，而Redis则作为第二级远程缓存。每一级缓存都设定有独立且差异化的超时时间，这样的设计确保了即使一级缓存的数据过期或被清除，仍能有二级或其他级别的缓存来提供数据支持。这种层级化的缓存机制为系统提供了额外的弹性层，当一层缓存遇到问题时，其他层级能够起到“安全网”的作用，从而可以有效避免雪崩现象。</p><ul><li><strong>互斥锁</strong></li></ul><p>​    这个和缓存击穿比较类似 ，都是通过互斥锁来控制读数据写缓存的线程数量，这样就避免大量请求同时击中数据库。同样，这样虽然可以避免大量key同时失效导致的缓存雪崩问题。但是，同样性能也会因为加锁的原因受到影响。如果，系统对吞吐量要求不高的情况下，这种方式其实还是不错的。因为它即解决了缓存击穿的问题，也解决了缓存雪崩的问题。可谓一举两得。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 6.0.12 配置文件详解</title>
      <link href="/posts/68e33178.html"/>
      <url>/posts/68e33178.html</url>
      
        <content type="html"><![CDATA[<h3 id="1、NETWORK-网络配置详解">1、NETWORK 网络配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ NETWORK ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定redis只能接受来自此IP绑定的网卡的请求，注意此默认值默认外网是不可访问的，想要外网访问redis服务，需注释掉</span></span><br><span class="line"><span class="built_in">bind</span> 127.0.0.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否开启保护模式。如果没有指定bind和密码，redis只会本地进行访问，拒绝外部访问。* protected-mode yes</span></span><br><span class="line">protected-mode <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#默认端口，建议生产环境不要使用默认端口避免被恶意扫描到</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment">#TCP连接中已完成队列(完成三次握手之后)的长度,默认是511,此值必须不大于Linux系统定义的tcp内核参数somaxconn值,默认参数</span></span><br><span class="line"><span class="comment">#值是128，该内核参数默认值一般是128（定义了系统中每一个端口最大的监听队列的长度），对于负载很大的服务程序来说大大的不够。#一般会将它修改为2048或者更大。somaxconn修改方法：</span></span><br><span class="line"><span class="comment">#在/etc/sysctl.conf中添加：net.core.somaxconn = 2048</span></span><br><span class="line"><span class="comment">#然后在终端中执行：sysctl -p</span></span><br><span class="line"></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置客户端连接时的超时时间，单位为秒。当客户端在这段时间内没有发出任何指令，服务端会断开连接。为0则服务端不会主动断开连接。</span></span><br><span class="line"><span class="built_in">timeout</span> 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#单位是秒，表示将周期性的使用SO_KEEPALIVE检测客户端是否还处于健康状态，避免服务器一直阻塞，官方给出的建议值是300s，如果#设置为0，则不会周期性的检测。</span></span><br><span class="line">tcp-keepalive 300</span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829</span><br></pre></td></tr></table></figure><h3 id="2、GENERAL-普通配置详解">2、GENERAL 普通配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ GENERAL ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置为yes表示指定Redis以守护进程的方式启动（后台启动）。默认值为 no</span></span><br><span class="line">daemonize <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#不进行监督树的交互</span></span><br><span class="line">supervised no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置PID文件路径，当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/redis/run/redis_6379.pid 文件里面</span></span><br><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义日志级别。默认使用notice，有4种级别·：</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#1、debug（记录大量日志信息，适用于开发、测试阶段）</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#2、verbose（较多日志信息）</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#3、notice（适量日志信息，使用于生产环境），默认</span></span><br><span class="line">　　　　　　　　　　<span class="comment">#4、warning（仅有部分重要、关键信息才会被记录）</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置日志文件地址</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据库的数量，序号从0开始</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否总是显示logo</span></span><br><span class="line">always-show-logo <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122232425262728293031323334</span><br></pre></td></tr></table></figure><h3 id="3、SNAPSHOTTING-快照配置详解">3、SNAPSHOTTING <a href="https://so.csdn.net/so/search?q=%E5%BF%AB%E7%85%A7&amp;spm=1001.2101.3001.7020">快照</a>配置详解</h3><p>Redis作为一款<a href="https://so.csdn.net/so/search?q=%E5%86%85%E5%AD%98&amp;spm=1001.2101.3001.7020">内存</a>数据库，被广泛使用于缓存，分布式锁等场景，假如断电或者因其他因素导致Reids服务宕机，在重启之后数据将会丢失，因此需要数据的持久化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ SNAPSHOTTING ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#save 设置redis进行数据库镜像的频率</span></span><br><span class="line"><span class="comment"># 900秒（15分钟）内至少1个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 900 1</span><br><span class="line"><span class="comment"># 300秒（5分钟）内至少10个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 300 10</span><br><span class="line"><span class="comment"># 60秒（1分钟）内至少10000个key值改变（则进行数据库保存--持久化）</span></span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在开启了 RDB 快照后，如果最近的一次 RDB 快照在后台生成失败的话，Redis 默认会拒绝所有的写请求。这样以一种强硬的方式让用#户知道数据不能正确的持久化到磁盘，否则就会没人注意到灾难的发生。如果后台保存进程重新启动工作了，redis 也将自动的允许写操#作。如果你已经为你的 Redis 实例和持久化配置了合适的监控手段，你可能不希望 redis 这样做，就改成 no 好了。</span></span><br><span class="line">stop-writes-on-bgsave-error <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在生成 rdb（关系数据库）文件的时候使用 LZF 压缩算法 ，yes：压缩，但是需要一些cpu的消耗。</span></span><br><span class="line"><span class="comment">#no：不压缩，需要更多的磁盘空间</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#从 5.0 版本开始 RDB 文件的末尾会默认放置一个 CRC64 的校验码。</span></span><br><span class="line"><span class="comment">#是否校验rdb文件，这会让文件的格式更加容易检验验证，代价是生成和加载 RDB 文件的性能会损失 10% 左右。你可以把该配置关闭以#求更佳的性能。</span></span><br><span class="line"><span class="comment">#没有开启校验码配置的 RDB 文件会将校验码设置为 0，加载该文件的程序就会跳过校验过程。</span></span><br><span class="line">rdbchecksum <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 rdb 文件的名称。默认值为 dump.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#rdb文件是否删除同步锁</span></span><br><span class="line">rdb-del-sync-files no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置快照文件的存放路径，这个配置项一定是个目录，而不能是文件名。使用上面的 dbfilename 作为保存的文件名。</span></span><br><span class="line"><span class="built_in">dir</span> ./</span><br><span class="line"></span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738</span><br></pre></td></tr></table></figure><h3 id="4、REPLICATION-主从复制配置详解">4、REPLICATION 主从复制配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt; <span class="comment">#</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>主从复制。使用 replicaof 来让一个 Redis 实例复制另一个 Redis 实例，关于 Redis 复制需要了解的一些事情：</p><p>1）Redis 复制时异步进行的，但是可以通过配置让 Redis 主节点拒绝写请求：配置会给定一个值，主节点至少需要和大于该值的从节点个数成功连接。</p><p>2）如果 Redis 从节点和主节点意外断连了很少的一段时间，从节点可以向主节点进行<strong>增量复制</strong>。你可以根据你的需要配置复制的备份日志文件大小（在下一部分可以看到相关的配置）</p><p>3）复制会自动进行且不需要人为介入（intervention）。在网络划分后复制会自动与主节点重连且同步数据。</p><p><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/112a5aea128ebbf66058994882ab4239.png" alt="img"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ REPLICATION ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果主节点配置了密码（使用了 &quot;requirepass&quot; 配置项），从节点需要进行密码认证才能进行复制同步的过程，否则主节点会直接拒</span></span><br><span class="line"><span class="comment">#绝从节点的复制请求。</span></span><br><span class="line">masterauth &lt;master-password&gt; <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当复制过程与主节点失去连接，或者当复制正在进行时，复制可以有两种行为模式：</span></span><br><span class="line"><span class="comment">#1）如果 replica-serve-stale-data 设置为 &#x27;yes&#x27;（默认设置），从节点仍可以处理客户端请求，但该从节点的数据很可能和主</span></span><br><span class="line"><span class="comment">#节点不同步，从节点的数据也可能是空数据集，如果这是与主节点进行的第一次同步。</span></span><br><span class="line"><span class="comment">#2）如果 replica-serve-stale-data 设置成 &#x27;no&#x27;，从节点会对除了 INFO，replicaOF，AUTH，PING，SHUTDOWN，#REPLCONF，ROLE，CONFIG，SUBSCRIBE，UNSUBSCRIBE，PSUBSCRIBE，PUNSUBSCRIBE，PUBLISH，PUBSUB，COMMAND， #POST，HOST： and LATENCY 这些命令之外的请求均返回 &quot;SYNC with master in process&quot;。</span></span><br><span class="line">replica-serve-stale-data <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置Redis的Slave实例是否接受写操作，即Slave是否为只读Redis。默认值为yes。</span></span><br><span class="line">replica-read-only <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主从数据复制是否使用无硬盘复制功能。默认值为no。</span></span><br><span class="line"><span class="comment">#新建立连接和重连的副本不会根据数据情况进行恢复传输，只会进行全量复制。主节点会传输在从节点之间传输 RDB 文件。传输行为有两种方式：</span></span><br><span class="line"><span class="comment">#1）硬盘备份：Redis 主节点创建一个子进程来向硬盘写 RDB 文件。之后由父进程持续的文件传给副本。在生成 RDB 文件时，多个副本会进行入队并在当前子进程完成 RDB 文件时立即为副本进行 RDB 传输。</span></span><br><span class="line"><span class="comment">#2）不使用硬盘：Redis 主节点建立一个进程直接向副本的网络套接字写 RDB 文件，不涉及到硬盘。一旦传输开始，新来的副本传输请求会入队且只在当前的传输断开后才建立新的传输连接。</span></span><br><span class="line">repl-diskless-sync no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果 diskless sync 是开启的话，就需要配置一个延迟的秒数，这样可以服务更多通过 socket 传输 RDB 文件的副本。延迟配置的单位是秒，默认是 5 秒。不想要该延迟的话可以配置为 0 秒，传输就会立即开始。</span></span><br><span class="line">repl-diskless-sync-delay 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否使用无磁盘加载，有三项选择：</span></span><br><span class="line"><span class="comment">#disabled：不使用无磁盘加载，先将rdb文件存储到磁盘</span></span><br><span class="line"><span class="comment">#on-empty-db：只有在完全安全的情况下才使用无磁盘加载</span></span><br><span class="line"><span class="comment">#swapdb：解析时在RAM中保留当前db内容的副本，直接从套接字获取数据。</span></span><br><span class="line">repl-diskless-load disabled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#副本会根据配置好的时间间隔（interval）向主节点发送 PING 命令。可以通过 repl_ping_replica_period 配置修改时间间隔。默认为 10 秒。</span></span><br><span class="line">repl-ping-replica-period 10 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的配置会将副本进行超时处理，为了：</span></span><br><span class="line"><span class="comment">#1）在副本的角度，在同步过程中批量进行 I/O 传输。</span></span><br><span class="line"><span class="comment">#2）从副本s的角度，主节点超时了。</span></span><br><span class="line"><span class="comment">#3）从主节点的角度，副本超时了。</span></span><br><span class="line"><span class="comment">#需要重视的一点是确保该选项的配置比 repl-ping-replica-period 配置的值更高，否则每次主从之间的网络比较拥挤时就容易被判定为超时。</span></span><br><span class="line">repl-timeout 60 <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#同步过后是否在副本套接字上关闭 TCP_NODELAY</span></span><br><span class="line"><span class="comment">#如果你选择了 &#x27;yes&#x27; ，Redis 会使用很小的 TCP 包，占用很低的带宽来想副本发送数据。但是这么做到达副本的数据会有一些延迟，#使用默认的配置值且是 Linux 内核该延迟最多可能 40 毫秒。</span></span><br><span class="line"><span class="comment">#如果你选择 &#x27;no&#x27;，副本的数据延迟会更低但是占用的带宽会更多一些。</span></span><br><span class="line"><span class="comment">#我们默认会为了低延迟进行优化，但是在比较拥挤网络情况下或者是主节点和副本之间的网络情况比较复杂，比如中间有很多路由跳转的情况下，把选项设置为 &#x27;yes&#x27; 应该会比较适合。</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#配置副本的缓冲区（backlog）大小。该缓冲区用来在副本断开连接后暂存副本数据。</span></span><br><span class="line"><span class="comment">#这样做的因为但副本重新连接后，不一定要重新进行全量复制，很多时候增量复制同步（仅同步断连期间副本可能丢失的数据）完全足够了。配置的缓冲区越大，副本可以承受的断连时间可以更长。</span></span><br><span class="line">repl-backlog-size 1mb <span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主节点如果一段时间没有副本连接，上面提到的缓冲区会被释放。可以通过配置一个指定的时间来释放缓冲区</span></span><br><span class="line"><span class="comment">#配置为 0 意味着不释放缓冲区。</span></span><br><span class="line">repl-backlog-ttl 3600 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当主节点无法提供服务后，Redis Sentinel（哨兵）会使用到优先级进行选举副本，晋升为主节点。</span></span><br><span class="line"><span class="comment">#值越低，代表该副本晋升成为主节点的优先级越高，比如说有三个副本，优先级的值分别为 10，100，25，Redis 哨兵会选择最低的那个，即优先级配置为10的那个。</span></span><br><span class="line"><span class="comment">#有一个特殊的配置值：&#x27;0&#x27;，意味着该副本不可能充当主节点的角色，故优先级配置为 0 的副本永远不会被 Redis 哨兵选择晋升。</span></span><br><span class="line">replica-priority 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#主节点可以根据目前连接的延迟小于 M 秒的副本数量，主redis就停止接受外来的写请求。</span></span><br><span class="line"><span class="comment">#数量 N 的副本需要是 &quot;online&quot; 的状态。默认的 min-replicas-to-write 被设置为 0（功能关闭）</span></span><br><span class="line"><span class="comment">#延迟的秒数（The lag（落后） in seconds） M ，计算方式是根据上一次副本发送 ping 命令到主节点的时间计算。通常每秒都会发送 ping 命令。</span></span><br><span class="line"><span class="comment">#比如要求至少有三个延迟小等于 10 秒的副本，主redis就停止接受外来的写请求，你可以这么配置：</span></span><br><span class="line">min-replicas-to-write 3 <span class="comment">#</span></span><br><span class="line">min-replicas-max-lag 10 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面的两个配置选项用来让副本上报特定的 IP 和 端口 集合给它连接的主节点，之后主节点使用 &quot;INFO&quot; 或者 &quot;ROLE&quot; 命令都可以输出这些上报的值。</span></span><br><span class="line"><span class="comment">#如果你只想上报 ip 或 端口其中一个，就没有必要两个都使用。</span></span><br><span class="line">replica-announce-ip 5.5.5.5 <span class="comment"># </span></span><br><span class="line">replica-announce-port 1234 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485</span><br></pre></td></tr></table></figure><h3 id="5、KEYS-TRACKING-键的追踪配置详解">5、KEYS TRACKING 键的追踪配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ KEYS TRACKING ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#在使用了客户端缓存的时候,这里配置要追踪的key的数量，如果配置为0，则表示要追踪的key的数量不受限制</span></span><br><span class="line">tracking-table-max-keys 1000000 <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">123456</span><br></pre></td></tr></table></figure><h3 id="6、SECURITY-安全配置详解">6、SECURITY 安全配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ SECURITY ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ACL日志的最大长度，默认是128M。</span></span><br><span class="line">acllog-max-len 128</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#ACL外部配置文件所在位置</span></span><br><span class="line">aclfile /etc/redis/users.acl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#当前redis服务的访问密码，默认是不需要密码</span></span><br><span class="line"><span class="comment">#警告：因为 Redis 的响应速率很快，所以恶意攻击者可能在每秒中发送 150k 数据量的密码尝试解密。这意味着你设置的密码强度要足够大，否则很容易被破解。</span></span><br><span class="line">requirepass foobared <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#命令的重命名。</span></span><br><span class="line"><span class="comment">#可以在共享的环境中重命名那些比较危险的命令。比如把 CONFIG 命令重命名成一个不好猜的名字，这样内部的功能还可以使用，且可以避免大部分的客户端使用。</span></span><br><span class="line"><span class="comment">#例如：rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment">#甚至可以将命名重命名成一个空串，使其失效。</span></span><br><span class="line">rename-command CONFIG <span class="string">&quot;&quot;</span> <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><h3 id="7、CLIENTS-客户端配置详解">7、CLIENTS 客户端配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ CLIENTS ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置可以同时连接客户端的最大数量。默认该项设置为 10000 个客户端</span></span><br><span class="line"><span class="comment">#一旦达到该限制数 Redis 会拒绝所有的新连接并返回错误信息 &#x27;max number of clients reached&#x27;。</span></span><br><span class="line">maxclients 10000 <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">1234567</span><br></pre></td></tr></table></figure><h3 id="8、MEMEORY-MANAGEMENT-内存管理配置详解">8、MEMEORY MANAGEMENT 内存管理配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ MEMEORY MANAGEMENT ============================</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定Redis最大内存限制。达到内存限制时，Redis将尝试删除已到期或即将到期的Key。</span></span><br><span class="line">maxmemory &lt;bytes&gt; <span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#内存使用达到限制后， Redis移除key的策略，默认是noeviction，</span></span><br><span class="line"><span class="comment">#maxmemory-policy 六种策略：</span></span><br><span class="line"><span class="comment">#1、volatile-lru：只对设置了过期时间的key进行LRU（默认值） </span></span><br><span class="line"><span class="comment">#2、allkeys-lru ： 删除lru算法的key   </span></span><br><span class="line"><span class="comment">#3、volatile-random：随机删除即将过期key   </span></span><br><span class="line"><span class="comment">#4、allkeys-random：随机删除   </span></span><br><span class="line"><span class="comment">#5、volatile-ttl ： 删除即将过期的   </span></span><br><span class="line"><span class="comment">#6、noeviction ： 永不过期，返回错误</span></span><br><span class="line"><span class="comment">#如果根据淘汰策略，Redis 不能移除键值对，Redis 会拒绝那些申请更大内存的命令，比如 SET，LPUSH 等等，但是仍可以处理读请求，比如 GET 等。</span></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line"></span><br><span class="line">1234567891011121314151617</span><br></pre></td></tr></table></figure><h3 id="9、APPEND-ONLY-aof模式配置详解">9、APPEND ONLY aof模式配置详解</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#============================ APPEND ONLY MODE ============================</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#是否启用aof持久化方式 。即是否在每次更新操作后进行日志记录，默认配置是no</span></span><br><span class="line"><span class="comment">#如果不开启，可能会在断电时导致部分数据丢失。</span></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#aof持久化文件名，默认为appendonly.aof</span></span><br><span class="line">appendfilename “appendonly.aof”</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#aof持久化文件刷新的频率。有三种：</span></span><br><span class="line"><span class="comment">#1.no 依靠OS进行刷新，redis不主动刷新AOF，这样最快，但安全性就差。</span></span><br><span class="line"><span class="comment">#2.always 每提交一个修改命令都调用fsync刷新到AOF文件，非常非常慢，但也非常安全。</span></span><br><span class="line"><span class="comment">#3.everysec 每秒钟都调用fsync刷新到AOF文件，很快，但可能会丢失一秒以内的数据。</span></span><br><span class="line">appendfsync always <span class="comment"># </span></span><br><span class="line">appendfsync everysec</span><br><span class="line">appendfsync no <span class="comment"># </span></span><br><span class="line"></span><br><span class="line">12345678910111213141516171819</span><br></pre></td></tr></table></figure><p>参考文章：<a href="https://cloud.tencent.com/developer/news/709703">https://cloud.tencent.com/developer/news/709703</a></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> config </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis HyperLogLog 基数统计和 Bitmap位图场景详解</title>
      <link href="/posts/13680a08.html"/>
      <url>/posts/13680a08.html</url>
      
        <content type="html"><![CDATA[<h1>Redis HyperLogLog 基数统计和 Bitmap位图场景详解</h1><h3 id="1、HyperLogLog-基数统计">1、HyperLogLog 基数统计</h3><blockquote><p>什么是基数?</p></blockquote><p>比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p><blockquote><p>Redis HyperLogLog</p></blockquote><p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。</p><p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p><p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p><blockquote><p>常用命令：</p></blockquote><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td>[PFADD key element [element …]添加指定元素到 HyperLogLog 中。</td></tr><tr><td>2</td><td>[PFCOUNT key [key …] 返回给定 HyperLogLog 的基数估算值。</td></tr><tr><td>3</td><td>[PFMERGE destkey sourcekey [sourcekey …] 将多个 HyperLogLog 合并为一个 HyperLogLog</td></tr></tbody></table><p><strong>使用实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加指定元素到 HyperLogLog 中</span></span><br><span class="line">127.0.0.1:6379&gt; pfadd key1 a b c d e f g h</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment">#返回给定 HyperLogLog 的基数估算值</span></span><br><span class="line">127.0.0.1:6379&gt; pfcount key1</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line">127.0.0.1:6379&gt; pfadd key2 e f g h x w y x z</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount key2</span><br><span class="line">(<span class="built_in">integer</span>) 8</span><br><span class="line"><span class="comment">#将多个 HyperLogLog 合并为一个 HyperLogLog</span></span><br><span class="line">127.0.0.1:6379&gt; pfmerge key3 key1 key2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount key3</span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">123456789101112131415</span><br></pre></td></tr></table></figure><h3 id="2、Bitmap位图场景详解">2、Bitmap位图场景详解</h3><p>bitmap就是通过最小的单位bit来进行0或者1的设置，表示某个元素对应的值或者状态。一个bit的值，或者是0，或者是1；也就是说一个bit能存储的最多信息是2。</p><p>Redis从2.2.0版本开始新增了<code>setbit</code>,<code>getbit</code>,<code>bitcount</code>等几个bitmap相关命令。虽然是新命令，但是并没有新增新的数据类型，因为<code>setbit</code>等命令只不过是在<code>set</code>上的扩展。</p><p><strong>语法详解：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setbit key offset value</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>对key所存储的字符串值，设置或清除指定偏移量上的位（bit），如果不存在，就设置；如果已存在，就清除原有的，设置新的。</p><p>返回值为该位在setbit之前的值，value只能取0或1，offset(偏移量)从0开始，即使原位图只能10位，offset可以取1000</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">getbit key offset</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>对key所存储的字符串值，获取指定偏移量上的位（bit）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bitcount key [start end]</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>获取位图指定范围中位值为1的个数，如果不指定start与end，则取所有</p><blockquote><p>使用场景1：统计一周打卡次数</p></blockquote><p>0-6为周一到周末，1表示已打卡，0表示未打卡</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#========================记录一周内的打卡情况========================</span></span><br><span class="line">127.0.0.1:6379&gt; setbit sign 0 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 4 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 5 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit sign 6 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#========================查看具体某一天的打卡情况========================</span></span><br><span class="line">127.0.0.1:6379&gt; getbit sign 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#========================统计一周内打卡次数========================</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount sign</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line"></span><br><span class="line">12345678910111213141516171819202122</span><br></pre></td></tr></table></figure><blockquote><p>使用场景2：统计活跃用户</p></blockquote><p>使用时间作为Key，然后用户ID为offset，如果当日活跃过就设置为1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#记录2021年08月12日用户的状态</span></span><br><span class="line">127.0.0.1:6379&gt; setbit 20210812 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit 20210812 2 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit 20210812 3 0</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#查看指定用户在2021年08月12日是否活跃</span></span><br><span class="line">127.0.0.1:6379&gt; getbit 20210812 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line"><span class="comment">#查看在2021年08月12日活跃的用户数</span></span><br><span class="line">127.0.0.1:6379&gt; bitcount 20210812</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"></span><br><span class="line">1234567891011121314</span><br></pre></td></tr></table></figure><p><strong>使用bitmap是一个节约空间效率又高的一种方法</strong></p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> HyperLogLog </tag>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Geospatial地理位置的使用</title>
      <link href="/posts/f844b42a.html"/>
      <url>/posts/f844b42a.html</url>
      
        <content type="html"><![CDATA[<h1>Redis Geospatial地理位置</h1><p>Redis GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。</p><p>Redis GEO 操作方法有：</p><ul><li><strong>geoadd：添加地理位置的坐标。</strong></li><li><strong>geopos：获取地理位置的坐标。</strong></li><li><strong>geodist：计算两个位置之间的距离。</strong></li><li><strong>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</strong></li><li><strong>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合。</strong></li><li><strong>geohash：返回一个或多个位置对象的 geohash 值。</strong></li></ul><blockquote><p><strong>geoadd：添加地理位置的坐标。</strong></p></blockquote><p>geoadd 用于存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。南北两级无法添加。</p><p>平时，我们一般会直接下载城市数据，然后通过java程序导入。</p><p>经度范围是0-180°，纬度范围是0-90°。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">116.40 39.90</span> beijing</span><br><span class="line"> (integer) <span class="number">1</span></span><br><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; geoadd china:city <span class="number">106.50 29.53</span> chongqing <span class="number">121.47 31.23</span> shanghai</span><br><span class="line"> (integer) <span class="number">2</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>geopos：获取地理位置的坐标</strong></p></blockquote><p>geopos 用于从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geopos china:city beijing shanghai</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;31.22999903975783553&quot;</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geopos china:city nanchang</span><br><span class="line"> <span class="attribute">1</span>) (nil)</span><br><span class="line"><span class="attribute">1234567</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>geodist：计算两个位置之间的距离</strong></p></blockquote><p>geodist 用于返回两个给定位置之间的距离，直线距离</p><p>最后一个距离单位参数说明：</p><ul><li>m ：米，默认单位。</li><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing   <span class="comment">#北京和重庆之间的距离  默认单位m</span></span><br><span class="line"> <span class="string">&quot;1464070.8051&quot;</span>  <span class="comment">#默认单位m</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing km</span><br><span class="line"> <span class="string">&quot;1464.0708&quot;</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing ft</span><br><span class="line"> <span class="string">&quot;4803381.9063&quot;</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>chongqing mi</span><br><span class="line"> <span class="string">&quot;909.7337&quot;</span></span><br><span class="line"> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; geodist china:city <span class="keyword">beijing </span>nanchang  <span class="comment">#，不存在的返回 nil</span></span><br><span class="line"> (nil)</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合</strong></p><p><strong>georadiusbymember：根据储存在位置集合里面的某个地点获取指定范围内的地理位置集合</strong></p></blockquote><ul><li><p>georadius 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p></li><li><p>georadiusbymember 和 GEORADIUS 命令一样， 都可以找出位于指定范围内的元素， 但是 georadiusbymember 的中心点是由给定的位置元素决定的， 而不是使用经度和纬度来决定中心点。</p></li><li><p>参数说明：</p></li><li><ul><li>m ：米，默认单位。</li><li>km ：千米。</li><li>mi ：英里。</li><li>ft ：英尺。</li><li>WITHDIST: 在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。</li><li>WITHCOORD: 将位置元素的经度和维度也一并返回。</li><li>WITHHASH: 以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li><li>COUNT 限定返回的记录数。</li><li>ASC: 查找结果根据距离从近到远排序。</li><li>DESC: 查找结果根据从远到近排序，默认。</li></ul></li></ul><p><strong>georadius 实例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#================返回以 119 35 中心，半径1000km内所有城市================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km</span><br><span class="line"> <span class="attribute">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> <span class="comment">#================返回以 119 35 中心，半径1000km内所有城市，并将位置元素与中心之间的距离也一并返回================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km withdist</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;591.3126&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;478.2625&quot;</span></span><br><span class="line"> <span class="comment">#================返回以 119 35 中心，半径1000km内所有城市，将位置元素的经度和维度也一并返回================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km withcoord</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;31.22999903975783553&quot;</span></span><br><span class="line"> <span class="comment">#返回以 119 35 中心，半径1000km内所有城市，将位置元素与中心之间的距离一并返回，将位置元素的经度和维度也一并返回    </span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km withcoord withdist</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;591.3126&quot;</span></span><br><span class="line">    <span class="attribute">3</span>) <span class="number">1</span>) <span class="string">&quot;116.39999896287918091&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;478.2625&quot;</span></span><br><span class="line">    <span class="attribute">3</span>) <span class="number">1</span>) <span class="string">&quot;121.47000163793563843&quot;</span></span><br><span class="line">       <span class="attribute">2</span>) <span class="string">&quot;31.22999903975783553&quot;</span></span><br><span class="line"> <span class="comment">#================================限定返回的记录数为1================================      </span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km  count <span class="number">1</span></span><br><span class="line"> <span class="attribute">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> <span class="comment">#================================查找结果根据距离从近到远排序================================</span></span><br><span class="line"> <span class="attribute">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">6379</span>&gt; GEORADIUS china:city <span class="number">119</span> <span class="number">35</span> <span class="number">1000</span> km  withdist asc</span><br><span class="line"> <span class="attribute">1</span>) <span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;478.2625&quot;</span></span><br><span class="line"> <span class="attribute">2</span>) <span class="number">1</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="attribute">2</span>) <span class="string">&quot;591.3126&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="attribute">1234567891011121314151617181920212223242526272829303132333435363738</span></span><br></pre></td></tr></table></figure><p><strong>georadiusbymember实例：</strong></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.583333</span> <span class="number">37.316667</span> <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line"> (<span class="built_in">integer</span>) <span class="number">1</span></span><br><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">&quot;Palermo&quot;</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">&quot;Catania&quot;</span></span><br><span class="line"> (<span class="built_in">integer</span>) <span class="number">2</span></span><br><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEORADIUSBYMEMBER Sicily Agrigento <span class="number">100</span> km</span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line"> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; GEORADIUSBYMEMBER Sicily Agrigento <span class="number">100</span> km withdist</span><br><span class="line"> <span class="number">1</span>) <span class="number">1</span>) <span class="string">&quot;Agrigento&quot;</span></span><br><span class="line">    <span class="number">2</span>) <span class="string">&quot;0.0000&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="number">1</span>) <span class="string">&quot;Palermo&quot;</span></span><br><span class="line">    <span class="number">2</span>) <span class="string">&quot;90.9778&quot;</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure><blockquote><p>geohash：返回一个或多个位置对象的 geohash 值。</p></blockquote><ul><li>Redis GEO 使用 geohash 来保存地理位置的坐标，</li><li>将二维经纬度转化为一维字符串，如果两个字符串越接近，则两个位置越接近。</li><li>geohash 用于获取一个或多个位置元素的 geohash 值。</li></ul><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> &quot;Palermo&quot; <span class="number">15.087269</span> <span class="number">37.502669</span> &quot;Catania&quot;</span><br><span class="line"> (integer) <span class="number">2</span></span><br><span class="line"> <span class="number">127.0.0.1</span>:<span class="number">6379</span>&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line"> <span class="number">1</span>) &quot;sqc8b49rny0&quot;</span><br><span class="line"> <span class="number">2</span>) &quot;sqdtr74hyu0&quot;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><blockquote><p>geo底层实现原理其实就是zset，我们可以通过zset命令来操作geo</p></blockquote><p><strong>尝试用zset的查询指令，查询添加的GEO信息：</strong></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; geoadd chin<span class="variable">a:city</span> <span class="number">116.40</span> <span class="number">39.90</span> beijing</span><br><span class="line"> (integer) <span class="number">1</span></span><br><span class="line"> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt;  geoadd chin<span class="variable">a:city</span> <span class="number">106.50</span> <span class="number">29.53</span> chongqing <span class="number">121.47</span> <span class="number">31.23</span> shanghai</span><br><span class="line"> (integer) <span class="number">2</span></span><br><span class="line"> <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">6379</span>&gt; zrange chin<span class="variable">a:city</span> <span class="number">0</span> -<span class="number">1</span> withscores</span><br><span class="line"> <span class="number">1</span>) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line"> <span class="number">2</span>) <span class="string">&quot;4026042091628984&quot;</span></span><br><span class="line"> <span class="number">3</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"> <span class="number">4</span>) <span class="string">&quot;4054803462927619&quot;</span></span><br><span class="line"> <span class="number">5</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line"> <span class="number">6</span>) <span class="string">&quot;4069885360207904&quot;</span></span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure><p>可以查到 “chongqing&quot;的位置信息为&quot;4026042091628984”， “shanghai&quot;的位置信息为&quot;4054803462927619”， “beijing&quot;的位置信息为&quot;4069885360207904”。</p><p>4026042091628984为对经纬度进行编码后的值。使用4026042091628984做为score 能够快速实现对经纬度的索引。</p><p><strong>至此能够推断出Redis GEO 添加经、纬度位置信息的指令的过程是：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="attribute">ZADD</span> china:city <span class="number">4026042091628984</span> chongqing</span><br><span class="line"> <span class="attribute">ZADD</span> china:city <span class="number">4054803462927619</span> shanghai</span><br><span class="line"> <span class="attribute">ZADD</span> china:city <span class="number">4069885360207904</span> beijing</span><br><span class="line"><span class="attribute">123</span></span><br></pre></td></tr></table></figure><p><strong>对数据进行删除：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1:6379</span>&gt; zrem china:city chongqing</span><br><span class="line">(integer) <span class="number">1</span></span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt; zrange china:city <span class="number">0</span> -<span class="number">1</span></span><br><span class="line"><span class="number">1</span>) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line"><span class="number">2</span>) <span class="string">&quot;beijing&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Geospatial </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Key 基本命令及 String 类型详解</title>
      <link href="/posts/ae6bd4af.html"/>
      <url>/posts/ae6bd4af.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-四-——Redis-Key-基本命令及-String-类型详解">Redis(四)——Redis Key 基本命令及 String 类型详解</h2><h3 id="1、Redis-Key基本命令">1、Redis Key基本命令</h3><p>Redis Key（键）命令用于管理 redis 的键。</p><p><strong>语法</strong></p><p>Redis 键命令的基本语法如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">redis</span> <span class="number">127.0.0.1:6379</span>&gt; COMMAND KEY_NAME</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>Redis Key 使用案例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name wanli  </span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> <span class="built_in">pwd</span> 123</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">2) <span class="string">&quot;pwd&quot;</span></span><br><span class="line"><span class="comment">#-----------------------判断是否存在某个key-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; exists name   <span class="comment">#判断是否存在某个key，</span></span><br><span class="line">(<span class="built_in">integer</span>) 1   <span class="comment">#存在为1，</span></span><br><span class="line">127.0.0.1:6379&gt; exists name1</span><br><span class="line">(<span class="built_in">integer</span>) 0   <span class="comment">#不存在为0</span></span><br><span class="line"><span class="comment">#-----------------------把指定key移动到指定数据库-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; move name 1  <span class="comment">#把名为name的key移动到1号数据库</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;pwd&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; select 1    <span class="comment">#切换到1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *   <span class="comment">#key移动成功</span></span><br><span class="line">1) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379[1]&gt; flushdb  <span class="comment">#清除1号数据库</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379[1]&gt; keys *  </span><br><span class="line">(empty array)</span><br><span class="line"><span class="comment">#-----------------------指定key的过期时间-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; expire <span class="built_in">pwd</span> 15  <span class="comment">#指定名为pwd的key 15s后过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">pwd</span>  <span class="comment">#查看还有多少时间过期</span></span><br><span class="line">(<span class="built_in">integer</span>) 11</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">pwd</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; ttl <span class="built_in">pwd</span></span><br><span class="line">(<span class="built_in">integer</span>) -2        <span class="comment">#key已经过期了</span></span><br><span class="line">127.0.0.1:6379&gt; get <span class="built_in">pwd</span>   </span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">(empty array)   </span><br><span class="line"><span class="comment">#-----------------------查看key的类型-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> <span class="built_in">pwd</span></span><br><span class="line">string</span><br><span class="line">1234567891011121314151617181920212223242526272829303132333435363738394041</span><br></pre></td></tr></table></figure><p>更多常用的Redis Key命令请参照下表：更多命令请参考：<a href="https://redis.io/commands">https://redis.io/commands</a></p><table><thead><tr><th>序号</th><th>命令及描述</th></tr></thead><tbody><tr><td>1</td><td>DEL key 该命令用于在 key 存在时删除 key。</td></tr><tr><td>2</td><td>DUMP key 序列化给定 key ，并返回被序列化的值。</td></tr><tr><td>3</td><td>EXISTS key 检查给定 key 是否存在。</td></tr><tr><td>4</td><td>EXPIRE key seconds 为给定 key 设置过期时间，以秒计。</td></tr><tr><td>5</td><td>EXPIREAT key timestamp EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳(unix timestamp)。</td></tr><tr><td>6</td><td>PEXPIRE key milliseconds 设置 key 的过期时间以毫秒计。</td></tr><tr><td>7</td><td>PEXPIREAT key milliseconds-timestamp 设置 key 过期时间的时间戳(unix timestamp) 以毫秒计</td></tr><tr><td>8</td><td>KEYS pattern 查找所有符合给定模式( pattern)的 key 。</td></tr><tr><td>9</td><td>MOVE key db 将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td>10</td><td>PERSIST key 移除 key 的过期时间，key 将持久保持。</td></tr><tr><td>11</td><td>PTTL key 以毫秒为单位返回 key 的剩余的过期时间。</td></tr><tr><td>12</td><td>TTL key 以秒为单位，返回给定 key 的剩余生存时间(TTL, time to live)。</td></tr><tr><td>13</td><td>RANDOMKEY 从当前数据库中随机返回一个 key 。</td></tr><tr><td>14</td><td>RENAME key newkey 修改 key 的名称</td></tr><tr><td>15</td><td>RENAMENX key newkey 仅当 newkey 不存在时，将 key 改名为 newkey 。</td></tr><tr><td>16</td><td>SCAN cursor MATCH pattern] [COUNT count 迭代数据库中的数据库键。</td></tr><tr><td>17</td><td>TYPE key 返回 key 所储存的值的类型。</td></tr></tbody></table><p>参考自菜鸟教程：<a href="https://www.runoob.com/redis/redis-keys.html">https://www.runoob.com/redis/redis-keys.html</a></p><h3 id="2、Redis-字符串-String-类型">2、Redis <a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020">字符串</a>(String)类型</h3><p>Redis 字符串数据类型的相关命令用于管理 redis 字符串值，基本语法如下：</p><p><strong>语法：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">redis</span> <span class="number">127.0.0.1:6379</span>&gt; COMMAND KEY_NAME</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>使用实例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-----------------------key-value的存取-----------------------</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> key1 wanli</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;wanli&quot;</span></span><br><span class="line"><span class="comment">#---------------------- 将指定的 value 追加到该 key 原来值（value）的末尾-------------</span></span><br><span class="line">127.0.0.1:6379&gt; append key1 hello</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;wanlihello&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append key1 <span class="string">&quot;hi&quot;</span></span><br><span class="line">(<span class="built_in">integer</span>) 12</span><br><span class="line">127.0.0.1:6379&gt; get key1</span><br><span class="line"><span class="string">&quot;wanlihellohi&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; append key3 taoxian  <span class="comment">#如果指定的key不存在，就会创建该指定key，并赋于value</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NoSQL数据库四大分类</title>
      <link href="/posts/d43317f5.html"/>
      <url>/posts/d43317f5.html</url>
      
        <content type="html"><![CDATA[<h1>NoSQL数据库四大分类</h1><p>NoSQL数据库是一类不使用传统的关系型数据库管理系统（RDBMS）模式的数据库。它们通常用于处理大量数据，并具有高度的可扩展性和灵活性。NoSQL数据库可以根据其数据模型分为四大类：键值存储数据库、列存储数据库、文档存储数据库和图数据库。以下是每一类的简要概述和代表性数据库。</p><h3 id="1-键值存储数据库-Key-Value-Stores">1. 键值存储数据库 (Key-Value Stores)</h3><h4 id="概述">概述</h4><p>键值存储数据库使用键值对来存储数据，每个键都是唯一的，并且与一个值相关联。它们适用于简单的数据模型，提供了快速的读写性能和高度的可扩展性。</p><h4 id="代表性数据库">代表性数据库</h4><ul><li><strong>Redis:</strong> Redis 是一个内存中数据结构存储，可以用作数据库、缓存和消息代理。它支持多种数据结构，如字符串、哈希、列表、集合、有序集合等。</li><li><strong>Riak:</strong> Riak 是一个分布式键值存储数据库，具有高可用性、故障容忍和数据持久性特性。</li></ul><h3 id="2-列存储数据库-Column-Family-Stores">2. 列存储数据库 (Column-Family Stores)</h3><h4 id="概述-2">概述</h4><p>列存储数据库将数据按列族（Column Family）存储，而不是按行存储。每个列族可以看作是一个键值对集合。它们适用于分析和处理大量数据，因为它们在处理某些类型的查询时非常高效。</p><h4 id="代表性数据库-2">代表性数据库</h4><ul><li><strong>Apache HBase:</strong> HBase 是一个基于Hadoop的开源分布式数据库，可以处理非常大的表，适用于需要实时读取和写入访问大数据的应用程序。</li><li><strong>Cassandra:</strong> Cassandra 是一个分布式数据库管理系统，设计用于处理大量数据的跨多个商品服务器的分布式数据存储。</li></ul><h3 id="3-文档存储数据库-Document-Stores">3. 文档存储数据库 (Document Stores)</h3><h4 id="概述-3">概述</h4><p>文档存储数据库使用文档（通常是JSON、BSON或XML格式）来存储数据。每个文档都包含数据项和其元数据，可以嵌套复杂的数据结构。它们适用于需要灵活数据模型的应用程序。</p><h4 id="代表性数据库-3">代表性数据库</h4><ul><li><strong>MongoDB:</strong> MongoDB 是一个基于文档的数据库，提供高性能、高可用性和自动扩展。它使用灵活的JSON-like文档模式。</li><li><strong>CouchDB:</strong> CouchDB 是一个面向文档的数据库，采用JSON来存储数据，JavaScript来查询，利用MapReduce来进行索引和查询。</li></ul><h3 id="4-图数据库-Graph-Databases">4. 图数据库 (Graph Databases)</h3><h4 id="概述-4">概述</h4><p>图数据库使用图结构来存储数据，包括节点、边和属性。它们擅长处理复杂的关系和关联数据，适用于社交网络、推荐系统等应用。</p><h4 id="代表性数据库-4">代表性数据库</h4><ul><li><strong>Neo4j:</strong> Neo4j 是一个高性能的图数据库，使用图结构来存储数据。它适用于需要高效查询图状数据的应用。</li><li><strong>OrientDB:</strong> OrientDB 是一个多模型数据库，支持图、文档、键值、对象等多种模型。它可以存储大量数据，同时提供高性能的图查询能力。</li></ul><h3 id="总结">总结</h3><p>NoSQL数据库通过不同的数据模型提供了对特定应用场景的高效支持。键值存储数据库适用于简单的查找操作；列存储数据库适用于大规模数据分析；文档存储数据库适用于需要灵活数据结构的应用；图数据库则适用于处理复杂关系的数据。选择合适的NoSQL数据库取决于具体的应用需求和数据特点。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>音视频&amp;流媒体的原理以及基础入门知识</title>
      <link href="/posts/bf51a49e.html"/>
      <url>/posts/bf51a49e.html</url>
      
        <content type="html"><![CDATA[<h1>音视频&amp;流媒体的原理以及基础入门知识</h1><h2 id="流媒体背景">流媒体背景</h2><p>当下，音视频、流媒体已经无处不在，直播已经火了几年，在后续的时间里面，人们聊天已经不仅仅满足与文字、而是更多的在于“类面对面”交流，能够实时感知对方的表情、动作。为此，有必要跟紧时代潮流，好好梳理梳理流媒体这门功课。</p><p>流媒体是什么？流媒体就是指采用流式传输技术在网络上连续实时播放的媒体格式，如音频、视频或多媒体文件。流媒体技术也称流式媒体技术。那么音视频就是流媒体的核心。</p><h2 id="音视频常见术语定义规范">音视频常见术语定义规范</h2><h2 id="音视频组成">音视频组成</h2><p>一个完整的视频文件，包括音频、视频和基础元信息，我们常见的视频文件如mp4、mov、flv、avi、rmvb等视频文件，就是一个容器的封装，里面包含了音频和视频两部分，并且都是通过一些特定的编码算法，进行编码压缩过后的。</p><p>H264、Xvid等就是视频编码格式，MP3、AAC等就是音频编码格式。例如：将一个Xvid视频编码文件和一个MP3音频编码文件按AVI封装标准封装以后，就得到一个AVI后缀的视频文件。</p><p>因此，视频转换需要设置的本质就是</p><ul><li>设置需要的视频编码</li><li>设置需要的音频编码</li><li>选择需要的容器封装</li></ul><p>一个完整的视频转换设置都至少包括了上面3个步骤。</p><h2 id="编码格式">编码格式</h2><p><strong>音频编码格式</strong></p><p>音频编码格式有如下</p><ul><li>AAC</li><li>AMR</li><li>PCM</li><li>ogg(ogg vorbis音频)</li><li>AC3(DVD 专用音频编码)</li><li>DTS(DVD 专用音频编码)</li><li>APE(monkey’s 音频)</li><li>AU(sun 格式)</li><li>WMA</li></ul><p>音频编码方案之间音质比较（AAC，MP3，WMA等）结果： AAC+ &gt; MP3PRO &gt; AAC&gt; RealAudio &gt; WMA &gt; MP3</p><p>目前最常见的音频格式有 Mp3、AC-3、ACC，MP3最广泛的支持最多，AC-3是杜比公司的技术，ACC是MPEG-4中的音频标准，ACC是目前比较先进和具有优势的技术。对应入门，知道有这几种最常见的音频格式足以。</p><p><strong>视频编码格式</strong></p><p>视频编码标准有两大系统： MPEG 和ITU-T，国际上制定视频编解码技术的组织有两个，一个是“国际电联（ITU-T）”，它制定的标准有H.261、H.263、H.263+、H.264等，另一个是“国际标准化组织（ISO）”它制定的标准有MPEG-1、MPEG-2、MPEG-4等。</p><p>常见编码格式有：</p><ul><li>Xvid(MPEG4)</li><li>H264 （目前最常用编码格式）</li><li>H263</li><li>MPEG1，MPEG2</li><li>AC-1</li><li>RM，RMVB</li><li>H.265（目前用的不够多）</li></ul><p>目前最常见的视频编码方式的大致性能排序基本是： MPEG-1/-2 &lt; WMV/7/8 &lt; RM/RMVB &lt; Xvid/Divx &lt; AVC/H.264（由低到高，可能不完全准确）。</p><p>在H.265出来之前，H264是压缩率最高的视频压缩格式，其优势有:</p><ul><li>低码率（Low Bit Rate）：和MPEG2和MPEG4 ASP等压缩技术相比，在同等图像质量下，采用H.264技术压缩后的数据量只有MPEG2的1/8，MPEG4的1/3。</li><li>高质量的图象 ：H.264能提供连续、流畅的高质量图象（DVD质量）。</li><li>容错能力强 ：H.264提供了解决在不稳定网络环境下容易发生的丢包等错误的必要工具。</li><li>网络适应性强 ：H.264提供了网络抽象层（Network Abstraction Layer），使得H.264的文件能容易地在不同网络上传输（例如互联网，CDMA，GPRS，WCDMA，CDMA2000等）。</li></ul><p>H.264最大的优势是具有很高的数据压缩比率，在同等图像质量的条件下，H.264的压缩比是MPEG-2的2倍以上，是MPEG-4的1.5～2倍。举个例子，原始文件的大小如果为88GB，采用MPEG-2压缩标准压缩后变成3.5GB，压缩比为25∶1，而采用H.264压缩标准压缩后变为879MB，从88GB到879MB，H.264的压缩比达到惊人的102∶1。低码率（Low Bit Rate）对H.264的高的压缩比起到了重要的作用，和MPEG-2和MPEG-4 ASP等压缩技术相比，H.264压缩技术将大大节省用户的下载时间和数据流量收费。尤其值得一提的是，H.264在具有高压缩比的同时还拥有高质量流畅的图像，正因为如此，经过H.264压缩的视频数据，在网络传输过程中所需要的带宽更少，也更加经济。</p><p>目前这些常见的视频编码格式实际上都属于有损压缩，包括H264和H265，也是有损编码，有损编码才能在质量得以保证的前提下得到更高的压缩率和更小体积</p><h2 id="存储封装格式">存储封装格式</h2><p>目前市面常见的存储封装格式有如下：</p><ul><li>AVI (.avi)</li><li>ASF（.asf)</li><li>WMV (.wmv)</li><li>QuickTime ( .mov)</li><li>MPEG (.mpg / .mpeg)</li><li>MP4 (.mp4)</li><li>m2ts （.m2ts / .mts )</li><li>Matroska （.mkv / .mks / .mka )</li><li>RM ( .rm / .rmvb)</li><li>TS/PS</li></ul><p>AVI : 可用MPEG-2, DIVX, XVID, WMV3, WMV4, AC-1, H.264</p><p>WMV : 可用WMV3, WMV4, AC-1</p><p>RM/RMVB : 可用RV40, RV50, RV60, RM8, RM9, RM10</p><p>MOV : 可用MPEG-2, MPEG4-ASP(XVID), H.264</p><p>MKV : 所有</p><h2 id="视频码率、帧率、分辨率">视频码率、帧率、分辨率</h2><p><strong>码率</strong></p><p>码流(Data Rate)是指视频文件在单位时间内使用的数据流量，也叫码率或码流率，通俗一点的理解就是取样率,是视频编码中画面质量控制中最重要的部分，一般我们用的单位是kb/s或者Mb/s。一般来说同样分辨率下，视频文件的码流越大，压缩比就越小，画面质量就越高。码流越大，说明单位时间内采样率越大，数据流，精度就越高，处理出来的文件就越接近原始文件，图像质量越好，画质越清晰，要求播放设备的解码能力也越高。</p><p>当然，码率越大，文件体积也越大，其计算公式是文件体积=时间X码率/8。例如，网络上常见的一部90分钟1Mbps码率的720P RMVB文件，其体积就=5400秒×1Mbps/8=675MB。</p><p>通常来说，一个视频文件包括了画面（视频）及声音（音频），例如一个RMVB的视频文件，里面包含了视频信息和音频信息，音频及视频都有各自不同的采样方式和比特率，也就是说，同一个视频文件音频和视频的比特率并不是一样的。而我们所说的一个视频文件码流率大小，一般是指视频文件中音频及视频信息码流率的总和。</p><p><strong>帧率</strong></p><p>帧率也称为FPS(Frames Per Second)- - - 帧/秒。是指每秒钟刷新的图片的帧数，也可以理解为图形处理器每秒钟能够刷新几次。越高的帧速率可以得到更流畅、更逼真的动画。每秒钟帧数(FPS)越多，所显示的动作就会越流畅。</p><p>关于帧率有如下几个基础数据：</p><ul><li>帧率越高，cpu消耗就高</li><li>秀场视频直播，一般帧率20fps</li><li>普通视频直播，一般帧率15fps</li></ul><p><strong>分辨率</strong></p><p>视频分辨率是指视频成像产品所成图像的大小或尺寸。常见的视像分辨率有352×288，176×144，640×480，1024×768。在成像的两组数字中，前者为图片长度，后者为图片的宽度，两者相乘得出的是图片的像素，长宽比一般为4：3.</p><p>480P : 640 x 480 个像素点</p><p>720P : 1280 x 720 个像素点</p><p>1080P : 1920 x 1080 个像素点</p><p>然后还需要关注每个像素点的存储格式，每个像素点占用的字节大小。</p><h2 id="图像存储格式yuv">图像存储格式yuv</h2><p><strong>一幅彩色图像的基本要素是什么？</strong></p><p>1、宽：一行有多少个像素点。</p><p>2、高：一列有多少个像素点，一帧有多少行</p><p>3、YUV格式还是RGB格式？</p><p>4、一行多少个字节？？</p><p>5、图像大小是多少？</p><p>6、图像的分辨率多少？</p><p>说白了，一幅图像包括的基本东西就是二进制数据，其容量大小实质即为二进制数据的多少。一幅1920x1080像素的YUV422的图像，大小是1920X1080X2=4147200（十进制），也就是3.95M大小。这个大小跟多少个像素点和数据的存储格式有关。</p><h2 id="YUV与像素的关系：">YUV与像素的关系：</h2><p>YUV格式，与我们熟知的RGB类似，YUV也是一种颜色编码方法，主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。</p><p>YUV格式有两大类：planar和packed。对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。对于packed的YUV格式，每个像素点的Y,U,V是连续交替存储的。</p><p>YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。</p><p>YUV是利用一个亮度（Y）、两个色差(U,V)来代替传统的RGB三原色来压缩图像。传统的RGB三原色使用红绿蓝三原色表示一个像素，每种原色占用一个字节（8bit），因此一个像素用RGB表示则需要8 * 3=24bit。</p><p>如果使用YUV表示这个像素，假设YUV的采样率为：4：2：0，即每一个像素对于亮度Y的采样频率为1，对于色差U和V，则是每相邻的两个像素各取一个U和V。对于单个的像素来说，色差U和V的采样频率为亮度的一半。如有三个相邻的像素，如果用RGB三原色表示，则共需要占用：8 * 3 * 3 = 72bits；如果采用YUV（4：2：0）表示，则只需要占用：8 * 3（Y）+ 8* 3 * 0.5（U）+ 8 * 3 * 0.5（V）= 36bits。只需原来一半的空间，就可以表示原来的图像，数据率压缩了一倍，而图像的效果基本没发生变化。</p><p>那么，具体yuv格式所占用的字节数要怎么算呢 ？</p><h2 id="YUV图像格式的内存大小">YUV图像格式的内存大小</h2><ul><li>4:4:4 表示色度值(UV)没有减少采样。即Y,U,V各占一个字节，加上Alpha通道一个字节，总共占4字节.这个格式其实就是24bpp的RGB格式了。</li><li>4:2:2 表示UV分量采样减半,比如第一个像素采样Y,U,第二个像素采样Y,V,依次类推,这样每个点占用2个字节.二个像素组成一个宏像素.</li><li>需要占用的内存：w * h * 2</li><li>4:2:0 这种采样并不意味着只有Y，Cb而没有Cr分量，这里的0说的U，V分量隔行才采样一次。比如第一行采样 4:2:0 ,第二行采样 4:0:2 ,依次类推…在这种采样方式下，每一个像素占用16bits或10bits空间.</li><li>内存则是：yyyyyyyyuuvv</li><li>需要占用的内存：w * h * 3 / 2</li><li>4:1:1 可以参考4:2:2分量，是进一步压缩，每隔四个点才采一次U和V分量。一般是第1点采Y,U,第2点采Y,第3点采YV,第4点采Y,依次类推。</li></ul><h2 id="帧率、码率与分辨率之间关系">帧率、码率与分辨率之间关系</h2><p>码率和帧率没有半毛钱关系</p><p>码率关系着带宽、文件体积</p><p>帧率关系着画面流畅度和cpu消耗</p><p>分辨率关系着图像尺寸和清晰度</p><p><strong>一个视频文件的大小为5.86M,播放时长为3分7秒</strong></p><ul><li>1，该文件对应的码率就是</li><li>5.86 * 1024 * 1024 * 8 / (3 * 60 + 7) = 262872.95657754bps</li><li>2，10M独享带宽能支撑的同时在线人数</li><li>10 * 1024 * 1024 / 262872.95657754 = 39.889078498294</li><li>3， 支撑1000人同时在线的系统最少需要的带宽数为</li><li>262872 * 1000 / (1024 * 1024) = 250.69427490234M</li></ul><p><strong>10min，流量消耗41587KB</strong></p><p>41587/10*60 = 69KB/s = 69 * 8 Kb/s = 532Kb/s</p><p>那么得到码率就是 532Kb/s</p><p><strong>输出文件大小公式</strong></p><p>一个音频编码率为128Kbps，视频编码率为800Kbps的文件，其总编码率为928Kbps，意思是经过编码后的数据每秒钟需要用928K比特来表示。</p><p>文件大小公式：</p><p>（音频编码率（KBit为单位）/8 + 视频编码率（KBit为单位）/8）× 影片总长度（秒为单位）= 文件大小（MB为单位）</p><p><strong>一帧图像大小</strong></p><p>一帧图像原始大小 = 宽像素 * 长像素 ，当然要考虑数据格式，因为数据格式不一样，大小写也不相同，一般数据采用rgb、yuv格式，如rgb32、yuv420、yuv422等。最常用的应当属于yuv420。 因此，计算公式为：</p><p>文件的字节数 = 图像分辨率 * 图像量化位数/8</p><p>图像分辨率 = X方向的像素数 * Y方向的像素数</p><p>图像量化数 = 二进制颜色位数</p><ul><li>RGB24每帧的大小是</li></ul><p>size＝width×heigth×3 Bit</p><ul><li>RGB32每帧的大小是</li></ul><p>size＝width×heigth×4</p><ul><li>YUV420每帧的大小是</li></ul><p>size＝width×heigth×1.5 Bit</p><p>举例说明，对于一个1024*768的图像实际的YUV422数据流大小就为：1024 *768 * 2 = 1572864bit</p><h2 id="音频采样率、位数">音频采样率、位数</h2><p>1、声道数：声道数是音频传输的重要指标，现在主要有单声道和双声道之分。双声道又称为立体声，在硬件中要占两条线路，音质、音色好， 但立体声数字化后所占空间比单声道多一倍。</p><p>2、量化位数： 量化位是对模拟音频信号的幅度轴进行数字化，它决定了模拟信号数字化以后的动态范围。由于计算机按字节运算，一般的量化位数为 8位和16位。量化位越高，信号的动态范围越大，数字化后的音频信号就越可能接近原始信号，但所需要的存储空间也越大。</p><p>3、采样率：也称为采样速度或者采样频率，定义了每秒从连续信号中提取并组成离散信号的采样个数，它用赫兹（Hz）来表示。采样率是指将模拟信号转换成数字信号时的采样频率，也就是单位时间内采样多少点。一个采样点数据有多少个比特。比特率是指每秒传送的比特(bit)数。单位为 bps(Bit Per Second)，比特率越高，传送的数据越大，音质越好.</p><p>采样率的选择应该遵循奈奎斯特(Harry Nyquist)采样理论( 如果对某一模拟信号进行采样，则采样后可还原的最高信号频率只有采样频率的一半，或者说只要采样频率高于输入信号最高频率的两倍，就能从采样信号系列重构原始信号 )。根据该采样理论， CD激光唱盘采样频率为 44kHz，可记录的最高音频为 22kHz，这样的音质与原始声音相差无几，也就是我们常说的超级高保真音质。通信系统中数字电话的采用频率通常为 8kHz，与原 4k带宽声音一致的。</p><p>比特率(音频) = 采样率 x 采用位数 x 声道数.</p><p>以电话为例，每秒3000次取样，每个取样是7比特，那么电话的比特率是21000。 而CD是每秒 44100次取样，两个声道，每个取样是13位PCM编码，所以CD的比特率是44100213=1146600，也就是说CD每秒的数据量大约是 144KB，而一张CD的容量是74分等于4440秒，就是639360KB＝640MB。</p><h2 id="I帧、P帧、B帧、IDR帧">I帧、P帧、B帧、IDR帧</h2><p><strong>I帧:帧内编码帧</strong></p><p>I帧特点:</p><ol><li>它是一个全帧压缩编码帧。它将全帧图像信息进行JPEG压缩编码及传输;</li><li>解码时仅用I帧的数据就可重构完整图像;</li><li>I帧描述了图像背景和运动主体的详情;</li><li>I帧不需要参考其他画面而生成;</li><li>I帧是P帧和B帧的参考帧(其质量直接影响到同组中以后各帧的质量);</li><li>I帧是帧组GOP的基础帧(第一帧),在一组中只有一个I帧;</li><li>I帧不需要考虑运动矢量;</li><li>I帧所占数据的信息量比较大。</li></ol><p><strong>P帧:前向预测编码帧</strong></p><p>P帧的预测与重构:P帧是以I帧为参考帧,在I帧中找出P帧“某点”的预测值和运动矢量,取预测差值和运动矢量一起传送。在接收端根据运动矢量从I帧中找出P帧“某点”的预测值并与差值相加以得到P帧“某点”样值,从而可得到完整的P帧。又称predictive-frame，通过充分将低于图像序列中前面已编码帧的时间冗余信息来压缩传输数据量的编码图像，也叫预测帧</p><p>P帧特点:</p><ol><li>P帧是I帧后面相隔1~2帧的编码帧;</li><li>P帧采用运动补偿的方法传送它与前面的I或P帧的差值及运动矢量(预测误差);</li><li>解码时必须将I帧中的预测值与预测误差求和后才能重构完整的P帧图像;</li><li>P帧属于前向预测的帧间编码。它只参考前面最靠近它的I帧或P帧;</li><li>P帧可以是其后面P帧的参考帧,也可以是其前后的B帧的参考帧;</li><li>由于P帧是参考帧,它可能造成解码错误的扩散;</li><li>由于是差值传送,P帧的压缩比较高。</li></ol><p><strong>B帧:双向预测内插编码帧。</strong></p><p>B帧的预测与重构:B帧以前面的I或P帧和后面的P帧为参考帧,“找出”B帧“某点”的预测值和两个运动矢量,并取预测差值和运动矢量传送。接收端根据运动矢量在两个参考帧中“找出(算出)”预测值并与差值求和,得到B帧“某点”样值,从而可得到完整的B帧。 又称bi-directional interpolated prediction frame，既考虑与源图像序列前面已编码帧，也顾及源图像序列后面已编码帧之间的时间冗余信息来压缩传输数据量的编码图像，也叫双向预测帧</p><p>B帧特点:</p><ol><li>B帧是由前面的I或P帧和后面的P帧来进行预测的;</li><li>B帧传送的是它与前面的I或P帧和后面的P帧之间的预测误差及运动矢量;</li><li>B帧是双向预测编码帧;</li><li>B帧压缩比最高,因为它只反映丙参考帧间运动主体的变化情况,预测比较准确;</li><li>B帧不是参考帧,不会造成解码错误的扩散。</li></ol><p><strong>IDR 帧</strong></p><p>IDR（Instantaneous Decoding Refresh）–即时解码刷新。</p><p>I和IDR帧都是使用帧内预测的。它们都是同一个东西而已,在编码和解码中为了方便，要首个I帧和其他I帧区别开，所以才把第一个首个I帧叫IDR，这样就方便控制编码和解码流程。IDR帧的作用是立刻刷新,使错误不致传播,从IDR帧开始,重新算一个新的序列开始编码。而I帧不具有随机访问的能力，这个功能是由IDR承担。IDR会导致DPB（DecodedPictureBuffer参考帧列表——这是关键所在）清空，而I不会。IDR图像一定是I图像，但I图像不一定是IDR图像。一个序列中可以有很多的I图像，I图像之后的图像可以引用I图像之间的图像做运动参考。一个序列中可以有很多的I图像，I图像之后的图象可以引用I图像之间的图像做运动参考。</p><p>对于IDR帧来说，在IDR帧之后的所有帧都不能引用任何IDR帧之前的帧的内容，与此相反，对于普通的I-帧来说，位于其之后的B-和P-帧可以引用位于普通I-帧之前的I-帧。从随机存取的视频流中，播放器永远可以从一个IDR帧播放，因为在它之后没有任何帧引用之前的帧。但是，不能在一个没有IDR帧的视频中从任意点开始播放，因为后面的帧总是会引用前面的帧。</p><p><strong>小结</strong></p><p>I帧表示关键帧，你可以理解为这一帧画面的完整保留；解码时只需要本帧数据就可以完成（因为包含完整画面）.</p><p>P帧表示的是这一帧跟之前的一个关键帧（或P帧）的差别，解码时需要用之前缓存的画面叠加上本帧定义的差别，生成最终画面。（也就是差别帧，P帧没有完整画面数据，只有与前一帧的画面差别的数据）.</p><p>B帧是双向差别帧，也就是B帧记录的是本帧与前后帧的差别，换言之，要解码B帧，不仅要取得之前的缓存画面，还要解码之后的画面，通过前后画面的与本帧数据的叠加取得最终的画面。B帧压缩率高，但是解码时CPU会比较累~。</p><p>PTS：Presentation Time Stamp。PTS主要用于度量解码后的视频帧什么时候被显示出来</p><p>DTS：Decode Time Stamp。DTS主要是标识读入内存中的bit流在什么时候开始送入解码器中进行解码。</p><p>DTS主要用于视频的解码,在解码阶段使用.PTS主要用于视频的同步和输出.在display的时候使用.在没有B frame的情况下.DTS和PTS的输出顺序是一样的.</p><h2 id="GOP">GOP</h2><p>两个I frame之间形成一个GOP，在x264中同时可以通过参数来设定bf的大小，即：I 和p或者两个P之间B的数量。如果有B frame 存在的情况下一个GOP的最后一个frame一定是P.</p><p>一般平均来说，I的压缩率是7（跟JPG差不多），P是20，B可以达到50，可见使用B帧能节省大量空间，节省出来的空间可以用来保存多一些I帧，这样在相同码率下，可以提供更好的画质。在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p><p>如果一个GOP里面丢了I帧，那么后面的P帧、B帧也将会无用武之地，因此必须丢掉，但是一般策略会保证I帧不丢（如通过tcp协议保证） ，如果采用UDP，那么也会有更多的策略来保证I帧正确传输。</p><p><strong>编解码</strong></p><p><strong>硬编解码</strong></p><p>通过硬件实现编解码，减轻CPU计算的负担，如GPU等</p><p><strong>软编解码</strong></p><p>如 H264、H265、MPEG-4等编解码算法，更消耗CPU</p><p><strong>数据优化</strong></p><p>数据优化和编解码算法息息相关，一般而言</p><p>视频帧大小</p><ul><li>一般I 帧的压缩率是7，P 帧是20，B 帧可以达到50 (数据不精确)</li><li>P帧大概是3~4KB (480P, 1200k码率, baseline profile)</li></ul><p>音频帧大小</p><ul><li>(采样频率（Hz）* 采样位数（bit）* 声道数)/ 8</li><li>48000hz大概经过AAC压缩后，应该是12KB/s左右</li></ul><h2 id="流媒体传输协议">流媒体传输协议</h2><p>常用的流媒体协议主要有 HTTP 渐进下载和基于 RTSP/RTP 的实时流媒体协议，这二种基本是完全不同的东西</p><p>CDN直播中常用的流媒体协议包括RTMP，HLS，HTTP FLV</p><h2 id="RTP，RTCP">RTP，RTCP</h2><p>实时传输协议（Real-time Transport Protocol），RTP协议常用于流媒体系统（配合RTCP协议），视频会议和一键通系统（配合H.323或SIP），使它成为IP电话产业的技术基础。RTP协议和RTP控制协议RTCP一起使用，而且它是建立在UDP协议上的。</p><p>实时传输控制协议（Real-time Transport Control Protocol或RTP Control Protocol或简写RTCP）是实时传输协议的一个姐妹协议。RTCP为RTP媒体流提供信道外控制。RTCP本身并不传输数据，但和RTP一起协作将多媒体数据打包和发送。RTCP定期在流多媒体会话参加者之间传输控制数据。RTCP的主要功能是为RTP所提供的服务质量提供反馈。</p><p>RTSP+RTP经常用于IPTV领域。因为其采用UDP传输视音频，支持组播，效率较高。但其缺点是网络不好的情况下可能会丢包，影响视频观看质量。</p><p><strong>小结</strong></p><p><strong>RTMP</strong></p><p>RTMP(Real Time Messaging Protocol)实时消息传送协议是Adobe Systems公司为Flash播放器和服务器之间音频、视频和数据传输 开发的开放协议。</p><p>它有三种变种：</p><ul><li>工作在TCP之上的明文协议，使用端口1935；</li><li>RTMPT封装在HTTP请求之中，可穿越防火墙；</li><li>RTMPS类似RTMPT，但使用的是HTTPS连接；</li></ul><p>总结： RTMP协议基于TCP来实现，每个时刻的数据，收到后立刻转发，一般延迟在1-3s左右</p><p><strong>HLS</strong></p><p>HTTP Live Streaming（HLS）是苹果公司(Apple Inc.)实现的基于HTTP的流媒体传输协议，可实现流媒体的直播和点播。HLS点播，基本上就是常见的分段HTTP点播，不同在于，它的分段非常小。基本原理就是将视频或流切分成小片（TS）， 并建立索引（M3U8）.</p><p>相对于常见的流媒体直播协议，例如RTMP协议、RTSP协议、MMS协议等，HLS直播最大的不同在于，直播客户端获取到的，并不是一个完整的数据流。HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断的下载并播放这些小文件，因为服务器端总是会将最新的直播数据生成新的小文件，这样客户端只要不停的按顺序播放从服务器获取到的文件，就实现了直播。由此可见，基本上可以认为，HLS是以点播的技术方式来实现直播。由于数据通过HTTP协议传输，所以完全不用考虑防火墙或者代理的问题，而且分段文件的时长很短，客户端可以很快的选择和切换码率，以适应不同带宽条件下的播放。不过HLS的这种技术特点，决定了它的延迟一般总是会高于普通的流媒体直播协议。</p><p>总结： HLS协议基于HTTP短连接来实现，集合一段时间数据，生成ts切片文件，然后更新m3u8(HTTP Live Streaming直播的索引文件)，一般延迟会大于10s</p><p><strong>HTTP-FLV</strong></p><p>HTTP-FLV基于HTTP长连接，通RTMP一样，每个时刻的数据，收到后立刻转发，只不过使用的是HTTP协议，一般延迟在1-3s</p><p><strong>CDN</strong></p><p>CDN架构设计比较复杂。不同的CDN厂商，也在对其架构进行不断的优化，所以架构不能统一而论。这里只是对一些基本的架构进行简单的剖析。</p><p>CDN主要包含：源站、缓存服务器、智能DNS、客户端等几个主要组成部分。</p><p>源站：是指发布内容的原始站点。添加、删除和更改网站的文件，都是在源站上进行的；另外缓存服务器所抓取的对象也全部来自于源站。对于直播来说，源站为主播客户端。</p><p>缓存服务器：是直接提供给用户访问的站点资源，由一台或数台服务器组成；当用户发起访问时，他的访问请求被智能DNS定位到离他较近的缓存服务器。如果用户所请求的内容刚好在缓存里面，则直接把内容返还给用户；如果访问所需的内容没有被缓存，则缓存服务器向邻近的缓存服务器或直接向源站抓取内容，然后再返还给用户。</p><p>智能DNS：是整个CDN技术的核心，它主要根据用户的来源，以及当前缓存服务器的负载情况等，将其访问请求指向离用户比较近且负载较小的缓存服务器。通过智能DNS解析，让用户访问同服务商下、负载较小的服务器，可以消除网络访问慢的问题，达到加速作用。</p><p>客户端：即发起访问的普通用户。对于直播来说，就是观众客户端。</p><p><strong>弱网优化</strong></p><p>弱网优化的策略包括如下：</p><ul><li>播放器Buffer</li><li>丢帧策略 (优先丢P帧，其次I帧，最后音频)</li><li>自适应码率算法</li><li>双向链路优化</li><li>音频FEC冗余算法(20%丢包率）</li></ul><p><strong>丢帧</strong></p><p>在弱网情况下，为了达到更好的体验，可能会采取丢帧的策略，但是丢帧，怎么丢呢？丢音频帧还是视频帧呢 ？ 因为视频帧比较大，并且视频帧前后是有关联的；音频帧很小，关键是音频帧是连续采样的，丢了音频帧，那声音就会明显出现瑕疵。为此，一般的丢帧策略是丢视频帧</p><p><strong>自适应码率</strong></p><p>在弱网情况下，另外一种靠谱的策略是自适应码率算法，通过设置码率降级为多个档次，这样，当网络不好的情况下，通过降低码率进行预测，如果码率降低后，还不够buffer缓冲，那么继续降低一个档次，是一个循环探测的过程，如果再次降级一个档次后，发现buffer缓冲足够了，那么说明当前网络能够适应这个码率，因此就会采取当前码率。同理，升档也是一样的。但是这个属于厂商的核心算法，</p><p><strong>实时聊天的挑战</strong></p><p>简单估算一下大概的网络延时。众所周知，光在真空中的速度约为300,000km/s，而在其他介质中光 速会大大降低，所以在普通光纤中，工程上一般认为传输速度是200,000km/s。从现实上来说，可以参考如下：</p><p>实时聊天的挑战主要在于以下几点:</p><ul><li>实时性: 600ms以内</li><li>网络的不对称性</li><li>距离</li></ul><h2 id="视频文件格式">视频文件格式</h2><p>首先让我们了解一下什么是视频文件格式？</p><p>1.容器和编解码器是任何视频文件的两个组成部分。 视频格式是存储音频，视频，字幕和任何其他源数据的容器。 编解码器对诸如音频和视频之类的多媒体数据进行编码和解码。</p><p>2.创建视频时，视频编解码器对视频进行编码和压缩，而音频编解码器对声音也是如此。 之后，编码的视频和音频将同步并存储在媒体容器（文件格式）中。</p><p>下面我分别介绍一下8种常见的视频文件格式，编解码器和容器</p><p><strong>1. MP4</strong></p><p>MPEG-4 Part 14或MP4是2001年推出的最早的数字视频文件格式之一。大多数数字平台和设备都支持MP4。 MP4格式可以存储音频文件，视频文件，静止图像和文本。 此外，MP4提供高质量的视频，同时保持相对较小的文件大小。</p><p><strong>2. MOV</strong></p><p>MOV是苹果设计的一种流行的视频文件格式。 它旨在支持QuickTime播放器。 MOV文件包含视频，音频，字幕，时间码和其他媒体类型。 它适用于Mac和Windows的不同版本的QuickTimePlayer。 由于它是一种非常高质量的视频格式，因此MOV文件在计算机上会占用更多的存储空间。</p><p><strong>3. WMV</strong></p><p>WMV视频格式由Microsoft设计，并广泛用于Windows媒体播放器中。 WMV格式可提供比MP4更好的压缩小文件。 这这个优势使它在在线视频流中很受欢迎。 尽管它与苹果设备不兼容，但用户可以为iPhone或Mac下载Windows Media Player。</p><p><strong>4. FLV</strong></p><p>FLV是Adobe Flash Player使用的文件格式。 它支持所有视频平台和浏览器，并且使用相当广泛，是用途最广泛的视频格式之一。 FLV格式是YouTube等在线视频流媒体平台的理想选择。 它们的文件大小相对较小，因此易于下载。 唯一的缺点是它与许多移动设备（如iPhone）不兼容。</p><p><strong>5. AVI</strong></p><p>AVI文件格式是Microsoft于1992年引入的，如今仍被广泛使用。 AVI视频格式使用的压缩比其他视频格式（例如MPEG或MOV）少。 这将导致非常大的文件大小，每分钟视频大约2-3 GB。 对于存储空间有限的用户来说可能是个问题。 您也可以创建AVI视频文件而无需任何压缩，这使文件无损。 无论您打开或保存文件多少次，无损文件都不会随着时间的流逝失去其质量。 此外，这省去了在视频播放器中使用编解码器。</p><p><strong>6. AVCHD（高级视频编码）</strong></p><p>AVCHD是用于高清视频播放和数字录制的格式。 这种视频格式是由Panasonic和Sony设计的，用于专业高清视频录制。 通过利用H.264 / MPEG-4视频压缩技术，AVCHD还使您仅使用少量数据就可以存储数小时的高质量视频。 此外，AVCHD 2.0格式的最新版本支持三维视频存储。</p><p><strong>7. WebM</strong></p><p>WebM由Google于2010年首次引入，是一种开放源代码视频格式，是在考虑互联网当前和未来状态的基础上开发的。 WebM适用于HTML5。 WebM的视频编解码器只需很少的计算机功能即可压缩和解压缩文件。 此设计的目的是使几乎所有设备（例如平板电脑，台式机，智能手机或智能电视等设备）上的在线视频流式传输成为可能。</p><p><strong>8. MKV</strong></p><p>MKV文件格式在单个文件中合并了音频，视频和字幕。 MKV格式是为了将来的使用而开发的，这意味着视频文件将始终保持更新。 MKV容器几乎支持任何视频和音频格式，从而使该格式具有高度自适应性，与易用性。</p><h2 id="常见问题和解决方案">常见问题和解决方案</h2><ul><li>出现花屏、绿屏问题</li></ul><p>采集问题、编解码问题、声网传输丢帧问题</p><ul><li>声画不同步</li></ul><p>采集问题，或者公有云SDK问题</p><ul><li>画面有时候有点糊</li></ul><p>弱网，码率的自适应</p><ul><li>有声音没有画面</li></ul><p>弱网，触发了丢帧策略</p><ul><li>画面播放有时候卡顿</li></ul><p>CPU消耗过高导致卡顿，比如AR模块</p><p>弱网</p><ul><li>网络连接不上</li></ul><p>弱网</p><p>或者代码有Bug，或者公有云SDK有Bug</p><ul><li>出现马赛克现象？</li></ul><p>是否类似花屏 ？</p><ul><li>TODO</li></ul><p>其他常见指标 和 问题解决方案</p><h2 id="相关链接">相关链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/232291020">音视频&amp;流媒体的原理以及基础入门知识 - 知乎 (zhihu.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> streaming media </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何优雅的将MultipartFile和File互转</title>
      <link href="/posts/f8448a72.html"/>
      <url>/posts/f8448a72.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>首先来区别一下MultipartFile和File:</p><ul><li>MultipartFile是 Spring 框架的一部分，File是 Java 标准库的一部分。</li><li>MultipartFile主要用于接收上传的文件，File主要用于操作系统文件。</li></ul><h2 id="MultipartFile转换为File">MultipartFile转换为File</h2><h3 id="使用-transferTo">使用 transferTo</h3><p>这是一种最简单的方法，使用MultipartFile自带的transferTo 方法将MultipartFile转换为File，这里通过上传表单文件，将MultipartFile转换为File格式，然后输出到特定的路径，具体写法如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151132476.png" alt="image-20240615113226175"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;C:\\desktop\\file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="comment">// Check if the file is empty</span></span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;文件为空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Ensure the upload directory exists</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR);</span><br><span class="line">            <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">                uploadDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the file to the specified directory</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR + File.separator + file.getOriginalFilename());</span><br><span class="line">            file.transferTo(targetFile);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-FileOutputStream">使用 FileOutputStream</h3><p>这是最常用的一种方法，使用 FileOutputStream 可以将字节写入文件。具体写法如下。</p><p><img src="C:/Users/long1/AppData/Roaming/Typora/typora-user-images/image-20240615113255746.png" alt="image-20240615113255746"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;C:\\desktop\\file&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span> MultipartFile file)</span> &#123;</span><br><span class="line">        <span class="comment">// Check if the file is empty</span></span><br><span class="line">        <span class="keyword">if</span> (file.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;文件为空&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Ensure the upload directory exists</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">uploadDir</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR);</span><br><span class="line">            <span class="keyword">if</span> (!uploadDir.exists()) &#123;</span><br><span class="line">                uploadDir.mkdirs();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save the file to the specified directory</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">targetFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(UPLOAD_DIR + File.separator + file.getOriginalFilename());</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">FileOutPutStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(targetFile)) &#123;</span><br><span class="line">                fos.write(file.getBytes());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传成功&quot;</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;上传失败&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用Java-NIO">使用Java NIO</h3><p>Java NIO 提供了文件复制的方法。具体写法如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151134781.png" alt="image-20240615113416663"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FileController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">string</span> <span class="variable">UPLOAD_DIR</span> <span class="operator">=</span> <span class="string">&quot;C:\\desktop\lfile&quot;</span>;</span><br><span class="line">    <span class="meta">@PostMapping(&quot;/upload&quot; )</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">uploadFile</span><span class="params">(<span class="meta">@RequestParam(&quot;file&quot;)</span>MultipartFile file)</span>&#123;</span><br><span class="line">        <span class="comment">// Check if the file is empty</span></span><br><span class="line">        <span class="keyword">if</span>(file.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span>“文件为空<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                Path uploadPath = Paths.get(UPLOAD DIR);</span></span><br><span class="line"><span class="string">            try &#123;</span></span><br><span class="line"><span class="string">                // Ensure the upload directory exists</span></span><br><span class="line"><span class="string">                File uploadDir = new File(UPLOAD DIR);</span></span><br><span class="line"><span class="string">                if(!uploadDir.exists())&#123;</span></span><br><span class="line"><span class="string">                    uploadDir.mkdirs();</span></span><br><span class="line"><span class="string">                    // Save the file to the specified directory using Java NIO</span></span><br><span class="line"><span class="string">                    Path targetPath = uploadPath.resolve(file.getOriginalFilename());</span></span><br><span class="line"><span class="string">                    Files.copy(file.getInputstream(), targetPath, standardCopyOptiOn.REPLACE EXISTING);</span></span><br><span class="line"><span class="string">                    return“上传成功&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(I0Exception e)&#123;</span><br><span class="line">                    e.printstackTrace();</span><br><span class="line">                    <span class="keyword">return</span>“上传失败<span class="string">&quot;;</span></span><br><span class="line"><span class="string">                &#125;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br></pre></td></tr></table></figure><h3 id="File装换为MultipartFile">File装换为MultipartFile</h3><p>从File转换为MultipartFile 通常在测试或模拟场景中使用，生产环境一般不这么用，这里只介绍一种最常用的方法。</p><h3 id="使用-MockMultipartFile">使用 MockMultipartFile</h3><p>在转换之前先确保引入了spring-test 依赖（以Maven举例）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>version<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过获得File文件的名称、mime类型以及内容将其转换为MultipartFile格式。具体写法如下。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151135870.png" alt="image-20240615113555637"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiToFileUtil</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Multipartfile <span class="title function_">convertMockMultipartfile</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IoException&#123;</span><br><span class="line">      <span class="comment">//根据提供的文件路径创建Path对象</span></span><br><span class="line">      Path path= Paths.get(filePath);</span><br><span class="line">      <span class="comment">//获取文件的名字</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> path.getFileName().tostring();</span><br><span class="line">      <span class="comment">//使用 Java NI0的Files 类探测文件的 MIME 类型</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">contentType</span> <span class="operator">=</span>Files.probeContentType(path);</span><br><span class="line">      <span class="comment">//读取文件内容为字节数组</span></span><br><span class="line">      bytel] content = Files.readAllBytes(path);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MockMultipartFile</span>(name, name, contentType, content);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MultipartFile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化-宕机了如何避免数据丢失</title>
      <link href="/posts/e6419cec.html"/>
      <url>/posts/e6419cec.html</url>
      
        <content type="html"><![CDATA[<h1>Redis持久化-宕机了如何避免数据丢失</h1><p>Reids实现高可用主要依靠以下几个方面的保障：</p><ul><li><code>数据持久化</code></li><li>主从复制</li><li>自动故障恢复</li><li>集群化</li></ul><p>Redis是一个内存数据库，它的数据都保存在内存中，如果实例宕机，那么数据则全部丢失。如何保证数据的完整性和安全性也是提高服务高可用的重要机制之一。</p><p>持久化机制是保证高可用的基础。因为Redis的主从复制和自动故障恢复，都需要依赖Redis持久化相关的东西。同时，Redis的数据持久化也可以用来做数据备份，用来保障数据的安全性。</p><p>Redis提供了完善的持久化机制，可以把内存中的数据持久化到磁盘上，方便我们进行备份数据和快速恢复数据。</p><p>目前，Redis 的持久化主要有两大机制，即 <strong>AOF（<code>Append Only File</code>）日志和 RDB（<code>Redis DataBase</code>） 快照</strong>。</p><h2 id="AOF">AOF</h2><h3 id="日志是如何实现的">日志是如何实现的</h3><p>说到日志，我们比较熟悉的是数据库的写前日志（Write Ahead Log, WAL），在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。不过，AOF 日志正好相反，它是写后日志，” 写后” 的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志。</p><p>AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p><p>我们以 Redis 收到 “set testkey testvalue” 命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3” 表示当前命令有三个部分，每部分都是由 “$+ 数字” 开头，后面紧跟着具体的命令、键或值。这里，“数字” 表示这部分中的命令、键或值一共有多少字节。例如，$3 set 表示这部分有 3 个字节，也就是 set 命令。</p><h3 id="写后日志的优势与风险">写后日志的优势与风险</h3><p><strong>为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。</strong></p><p>如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。</p><p>所以，Redis 使用写后日志这一方式的一大好处是，<strong>可以避免出现记录错误命令的情况</strong>。</p><p>除此之外，写后日志一个好处：它是在命令执行后才记录日志，<strong>不会阻塞当前的写操作</strong>。</p><h4 id="AOF-也有两个潜在的风险：">AOF 也有两个潜在的风险：</h4><ul><li><p>风险一：如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</p><ul><li><p>如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复。</p></li><li><p>如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</p></li></ul></li><li><p>风险二：AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。</p><ul><li>AOF 日志也是在主线程中执行 (写回策略为 always 时)，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li></ul></li></ul><p>这两个风险都是和 <strong>AOF 写回磁盘</strong>的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p><h3 id="日志的写回策略">日志的写回策略</h3><p>AOF 机制一共有三种写回策略，也就是 AOF 配置项<code>appendfsync</code>的三个可选值。</p><ul><li><code>Always 同步写回</code>：每个写命令执行完，立马同步地将日志写回磁盘；</li><li><code>Everysec 每秒写回</code>：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li><code>No 操作系统控制的写回</code>：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。<br>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。</li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151055633.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><p>我们就可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。</p><p>想要获得高性能，就选择 No 策略；<br>想要得到高可靠性保证，就选择 Always 策略；<br>允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择 Everysec 策略。</p><h3 id="日志的重写">日志的重写</h3><h4 id="重写的作用">重写的作用</h4><p>AOF 是以文件的形式在记录接收到的所有写命令。<strong>随着接收的写命令越来越多，AOF 文件会越来越大</strong>。这也就意味着，我们一定要小心 AOF 文件过大带来的性能问题，主要在于以下三个方面：</p><ul><li>一是，文件系统本身对文件大小有限制，无法保存过大的文件；</li><li>二是，如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li><li>三是，如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</li></ul><p>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，<strong>读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入</strong>。重写机制具有 “多变一” 功能。所谓的 “多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151056923.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><h4 id="重写的过程">重写的过程</h4><p>AOF 日志由主线程写回不同，重写过程是由<strong>后台子进程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程</strong>，导致数据库性能下降。</p><p>我把重写的过程总结为 “<strong>一个拷贝，两处日志</strong>”。</p><p>“一个拷贝” 就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>第一处日志，指的是因为主线程未阻塞，仍然可以处理新来的操作，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p><p>第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。</p><p>此时，我们就可以用新的 AOF 文件替代旧文件了。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151057241.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><p>总结来说，每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，<strong>因为 Redis 采用子进程进行日志重写，所以，这个过程并不会阻塞主线程</strong>。</p><p>正因为记录的是操作命令，而不是实际的数据，所以，用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。这当然不是理想的结果。那么，还有没有既可以保证可靠性，还能在宕机时实现快速恢复的其他方法呢？</p><h2 id="RDB">RDB</h2><p>对 Redis 来说，它实现类似照片记录效果的方式，把某一时刻的状态以文件的形式写到磁盘上，也就是快照（RDB 文件）。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。</p><p>和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，我们可以直接把 RDB 文件读入内存，很快地完成恢复。</p><h3 id="快照的原理">快照的原理</h3><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave。</p><ul><li><code>save</code>：在主线程中执行，会导致阻塞；</li><li><code>bgsave</code>：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是 Redis RDB 文件生成的默认配置。</li></ul><p>我们可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。<br>在执行快照的同时，Redis 就会借助操作系统提供的写时复制技术（Copy-On-Write, COW），正常处理写操作。bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。</p><p>如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本（键值对 C’）。然后，主线程在这个数据副本上进行修改。同时，bgsave 子进程可以继续把原来的数据（键值对 C）写入 RDB 文件。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151059013.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><p>这样既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p><h2 id="混合-AOF-RDB">混合 AOF/RDB</h2><p>虽然 bgsave 执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。</p><p>一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环（所以，在 Redis 中如果有一个 bgsave 在运行，就不会再启动第二个 bgsave 子进程）。</p><p>另一方面，bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，<strong>fork 这个创建过程本身会阻塞主线程</strong>，而且主线程的内存越大，阻塞时间越长。</p><p>Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，<strong>内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作</strong>。这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151100983.png!large" alt="宕机了，Redis 如何避免数据丢失？"></p><h2 id="总结">总结</h2><p>最后，关于 AOF 和 RDB 的选择问题，这里有三点建议：</p><ul><li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li><li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li><li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li></ul><h2 id="相关链接">相关链接</h2><ul><li><a href="https://learnku.com/articles/86491">宕机了，Redis 如何避免数据丢失？ | 程序员论坛 (learnku.com)</a></li><li><a href="https://blog.csdn.net/shangyuanlang/article/details/81297970">Redis数据&quot;丢失&quot;讨论及规避和解决的几点总结_redis是不是完全可靠,有没有数据丢失的时候,举例-CSDN博客</a></li><li><a href="https://cloud.tencent.com/developer/article/1730906">Redis 怎么防止数据丢失？面试必问！-腾讯云开发者社区-腾讯云 (tencent.com)</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Data Loss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis怎么预防数据丢失问题</title>
      <link href="/posts/2b4fa0b2.html"/>
      <url>/posts/2b4fa0b2.html</url>
      
        <content type="html"><![CDATA[<h1>Redis怎么预防数据丢失问题</h1><p>在使用Redis时，数据丢失可能会因为多种原因发生。以下是常见的导致数据丢失的问题及其对应的解决方案：</p><h2 id="1-内存溢出导致的数据丢失">1. 内存溢出导致的数据丢失</h2><p><strong>问题</strong>：</p><ul><li>Redis是基于内存的数据库，数据全部存储在内存中。当数据量超过内存容量时，可能会导致内存溢出，系统崩溃，数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>内存限制</p><p>：设置Redis的内存使用限制，防止内存溢出。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shell</span></span><br><span class="line">复制代码</span><br><span class="line">maxmemory &lt;<span class="keyword">bytes</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>内存淘汰策略</p><p>：配置适当的内存淘汰策略，在内存使用达到限制时删除旧数据。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell</span><br><span class="line">复制代码</span><br><span class="line">maxmemory-<span class="keyword">policy</span> noeviction  <span class="comment"># 或者 allkeys-lru, volatile-lru 等策略</span></span><br></pre></td></tr></table></figure></li><li><p><strong>水平扩展</strong>：使用Redis Cluster，通过分片技术将数据分布在多个节点上，减少单节点的内存压力。</p></li></ul><h2 id="2-持久化故障">2. 持久化故障</h2><p><strong>问题</strong>：</p><ul><li>RDB或AOF文件损坏、保存不及时或者配置不当可能导致数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>定期持久化</p><p>配置RDB和AOF的持久化策略，确保数据定期保存到磁盘中。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">shell</span>复制代码# RDB配置</span><br><span class="line"><span class="attribute">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF配置</span></span><br><span class="line"><span class="attribute">appendonly</span> yes</span><br><span class="line"><span class="attribute">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="attribute">appendfsync</span> everysec  # 每秒同步一次</span><br></pre></td></tr></table></figure></li><li><p>混合持久化</p><p>启用RDB和AOF混合持久化，结合两者的优点，提高数据安全性。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shell</span></span><br><span class="line">复制代码</span><br><span class="line">aof-<span class="keyword">use</span>-rdb-preamble yes</span><br></pre></td></tr></table></figure></li><li><p><strong>定期备份</strong>：定期备份RDB和AOF文件，防止文件损坏时的数据丢失。</p></li></ul><h2 id="3-主从复制延迟或故障">3. 主从复制延迟或故障</h2><p><strong>问题</strong>：</p><ul><li>主从复制过程中，如果从节点未能及时同步主节点数据，或者主从节点切换不及时，可能导致数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>优化复制延迟</p><p>：确保网络和硬件环境的稳定性，优化复制延迟。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span></span><br><span class="line"><span class="keyword"></span>复制代码</span><br><span class="line">repl-<span class="keyword">backlog-size </span>&lt;<span class="keyword">bytes&gt; </span> <span class="comment"># 增加复制积压缓冲区大小</span></span><br></pre></td></tr></table></figure></li><li><p>配置哨兵机制</p><p>：使用哨兵机制监控主从节点状态，自动进行主从切换，确保高可用性。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">shell复制代码sentinel<span class="built_in"> monitor </span>mymaster &lt;master-ip&gt; &lt;master-port&gt; 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br><span class="line">sentinel failover-timeout mymaster 180000</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure></li></ul><h2 id="4-磁盘故障">4. 磁盘故障</h2><p><strong>问题</strong>：</p><ul><li>磁盘损坏或磁盘I/O异常会导致持久化文件（RDB、AOF）丢失或损坏。</li></ul><p><strong>解决方案</strong>：</p><ul><li><strong>使用可靠的硬件</strong>：选择高可靠性的磁盘设备。</li><li><strong>RAID阵列</strong>：使用RAID阵列提升磁盘的可靠性和性能。</li><li><strong>定期备份</strong>：将持久化文件定期备份到其他存储设备或云存储上。</li></ul><h2 id="5-人为错误">5. 人为错误</h2><p><strong>问题</strong>：</p><ul><li>错误的命令操作（如FLUSHALL、FLUSHDB）或误操作可能导致数据丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>权限控制</p><p>：通过设置密码和用户权限，限制高风险命令的执行。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span></span><br><span class="line">复制代码</span><br><span class="line">requirepass <span class="symbol">&lt;password&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>多级确认</strong>：对于高风险操作，设置多级确认机制，防止误操作。</p></li></ul><h2 id="6-意外重启或崩溃">6. 意外重启或崩溃</h2><p><strong>问题</strong>：</p><ul><li>Redis实例意外重启或崩溃，未及时持久化的数据可能会丢失。</li></ul><p><strong>解决方案</strong>：</p><ul><li><p>设置持久化策略</p><p>：确保持久化配置合理，尽量减少数据丢失的时间窗口。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">shell</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash">复制代码</span></span><br><span class="line">appendfsync always  <span class="comment"># 每次写操作都进行同步</span></span><br></pre></td></tr></table></figure></li><li><p><strong>快速重启</strong>：优化Redis的启动和恢复流程，尽量减少重启后的数据恢复时间。</p></li></ul><h2 id="总结">总结</h2><p>为防止Redis数据丢失，需采取综合措施，包括合理配置持久化策略、优化主从复制、定期备份数据、使用可靠的硬件和存储设备、加强权限控制及误操作防护等。这些措施可以显著提升Redis系统的可靠性和数据安全性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Data Loss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashedWheelTimer算法（定时任务）</title>
      <link href="/posts/33980cf3.html"/>
      <url>/posts/33980cf3.html</url>
      
        <content type="html"><![CDATA[<h1>HashedWheelTimer算法理解</h1><h2 id="序">序</h2><p>George Varghese 和 Tony Lauck 1996 年的论文：<a href="https://link.segmentfault.com/?enc=8Wp%2F27rHZt4fLrTAPAiB8w%3D%3D.2h2jPX7bqrabxLNbRoJq31JEIatYam7wPTcg866E1DwI7YOdmiuelp7MaTfZ8A8w9yk8w9RrXneF%2FVcvGjH9iA%3D%3D">Hashed and Hierarchical Timing Wheels: data structures to efficiently implement a timer facility</a>提出了一种定时轮的方式来管理和维护大量的Timer调度算法.Linux 内核中的定时器采用的就是这个方案。而Redisson的实现中会调用<code>scheduleExpirationRenewal</code>方法创建一个定时任务来刷新锁的过期时间，防止任务执行完毕前锁就过期释放了，其中使用的定时任务就是<code>Netty</code>提供的<code>HashedWheelTimer</code>。</p><h2 id="定时任务的本质">定时任务的本质</h2><p>一个Timer本质上是这样的一个数据结构：deadline越近的任务拥有越高优先级，提供以下3中基本操作：</p><ol><li><code>schedule</code>新增</li><li><code>cancel</code>删除</li><li><code>expire</code>执行到期的任务</li><li><code>updateDeadline</code>更行到期时间（可选）</li></ol><p><code>expire</code>通常有两种工作方式：</p><ol><li><p>轮询</p><p>每隔一个时间片就去查找哪些任务已经到期</p></li><li><p>睡眠/唤醒</p><ol><li>不停地查找deadline最近的任务，如到期则执行；否则sleep直到其到期</li><li>在sleep期间，如果有任务被<code>cancel</code>或<code>schedule</code>，则deadline最近的任务有可能改变，线程会被唤醒并重新进行1的逻辑</li></ol></li></ol><p>具体实现的数据结构可以有很多选择：（假设任务持有自己在总体任务集合中对应的节点，<code>cancel</code>时不需要查找的过程）</p><ol><li>有序链表<ul><li><code>schedule</code>：O(n)</li><li><code>cancel</code>：O(1) //双向链表的节点删除</li><li><code>expire</code>：O(1) //不停地查看第一个就可以了</li></ul></li><li>堆heap<ul><li><code>schedule</code>：O(log2N) //调整heap</li><li><code>cancel</code>：O(log2N) //调整heap</li><li><code>expire</code>：O(1)</li></ul></li></ol><h2 id="原理">原理</h2><p>一个Hash Wheel Timer是一个环形结构，可以想象成时钟，分为很多格子，一个格子代表一段时间（越短Timer精度越高），并用一个List保存在该格子上到期的所有任务，同时一个指针随着时间流逝一格一格转动，并执行对应List中所有到期的任务。任务通过取模决定应该放入哪个格子。</p><p>环形结构可以根据超时时间的 hash 值(这个 hash 值实际上就是ticks &amp; mask)将 task 分布到不同的槽位中, 当 tick 到那个槽位时, 只需要遍历那个槽位的 task 即可知道哪些任务会超时(而使用线性结构, 你每次 tick 都需要遍历所有 task), 所以, 我们任务量大的时候, 相应的增加 wheel 的 ticksPerWheel 值, 可以减少 tick 时遍历任务的个数.</p><h3 id="结构图">结构图</h3><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406151008709.webp" alt="img"></p><p>以上图为例，假设一个格子是1秒，则整个wheel能表示的时间段为8s，假如当前指针指向2，此时需要调度一个3s后执行的任务，显然应该加入到(2+3=5)的方格中，指针再走3次就可以执行了；如果任务要在10s后执行，应该等指针走完一个round零2格再执行，因此应放入4，同时将round（1）保存到任务中。检查到期任务时应当只执行round为0的，格子上其他任务的round应减1。</p><h3 id="效率">效率</h3><ul><li>添加任务：O(1)</li><li>删除/取消任务：O(1)</li><li>过期/执行任务：最差情况为O(n)-&gt;也就是当HashMap里面的元素全部hash冲突，退化为一条链表的情况。平均O(1)</li></ul><p>槽位越多，每个槽位上的链表就越短，这里需要权衡时间与空间。</p><h2 id="netty3-10的实现">netty3.10的实现</h2><h3 id="相关参数">相关参数</h3><ul><li>tickDuration: 每 tick 一次的时间间隔, 每 tick 一次就会到达下一个槽位</li><li>ticksPerWheel: 轮中的 slot 数，hash算法计算目标槽位</li></ul><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new timer with the default thread factory</span></span><br><span class="line"><span class="comment"> * (&#123;<span class="doctag">@link</span> Executors#defaultThreadFactory()&#125;).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tickDuration   the duration between tick</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit           the time unit of the &#123;<span class="doctag">@code</span> tickDuration&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ticksPerWheel  the size of the wheel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashedWheelTimer</span><span class="params">(<span class="keyword">long</span> tickDuration, TimeUnit unit, <span class="keyword">int</span> ticksPerWheel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Executors.defaultThreadFactory(), tickDuration, unit, ticksPerWheel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashedWheelBucket定义">HashedWheelBucket定义</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bucket that stores HashedWheelTimeouts. These are stored in a linked-list like datastructure to allow easy</span></span><br><span class="line"><span class="comment">     * removal of HashedWheelTimeouts in the middle. Also the HashedWheelTimeout act as nodes themself and so no</span></span><br><span class="line"><span class="comment">     * extra object creation is needed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">class</span> <span class="title">HashedWheelBucket</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Used for the linked-list datastructure</span></span><br><span class="line">        <span class="keyword">private</span> HashedWheelTimeout head;</span><br><span class="line">        <span class="keyword">private</span> HashedWheelTimeout tail;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Add &#123;@link HashedWheelTimeout&#125; to this bucket.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeout</span>(<span class="params">HashedWheelTimeout timeout</span>)</span> &#123;</span><br><span class="line">            assert timeout.bucket == <span class="literal">null</span>;</span><br><span class="line">            timeout.bucket = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                head = tail = timeout;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = timeout;</span><br><span class="line">                timeout.prev = tail;</span><br><span class="line">                tail = timeout;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Expire all &#123;@link HashedWheelTimeout&#125;s for the given &#123;@code deadline&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expireTimeouts</span>(<span class="params"><span class="built_in">long</span> deadline</span>)</span> &#123;</span><br><span class="line">            HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// process all timeouts</span></span><br><span class="line">            <span class="keyword">while</span> (timeout != <span class="literal">null</span>) &#123;</span><br><span class="line">                boolean <span class="keyword">remove</span> = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                        timeout.expire();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(String.format(</span><br><span class="line">                                <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">remove</span> = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">remove</span> = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    timeout.remainingRounds --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// store reference to next as we may null out timeout.next in the remove block.</span></span><br><span class="line">                HashedWheelTimeout next = timeout.next;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">remove</span>) &#123;</span><br><span class="line">                    <span class="keyword">remove</span>(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">                timeout = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span>(<span class="params">HashedWheelTimeout timeout</span>)</span> &#123;</span><br><span class="line">            HashedWheelTimeout next = timeout.next;</span><br><span class="line">            <span class="comment">// remove timeout that was either processed or cancelled by updating the linked-list</span></span><br><span class="line">            <span class="keyword">if</span> (timeout.prev != <span class="literal">null</span>) &#123;</span><br><span class="line">                timeout.prev.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (timeout.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                timeout.next.prev = timeout.prev;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timeout == head) &#123;</span><br><span class="line">                <span class="comment">// if timeout is also the tail we need to adjust the entry too</span></span><br><span class="line">                <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                    tail = <span class="literal">null</span>;</span><br><span class="line">                    head = <span class="literal">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    head = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout == tail) &#123;</span><br><span class="line">                <span class="comment">// if the timeout is the tail modify the tail to be the prev node.</span></span><br><span class="line">                tail = timeout.prev;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// null out prev, next and bucket to allow for GC.</span></span><br><span class="line">            timeout.prev = <span class="literal">null</span>;</span><br><span class="line">            timeout.next = <span class="literal">null</span>;</span><br><span class="line">            timeout.bucket = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Clear this bucket and return all not expired / cancelled &#123;@link Timeout&#125;s.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearTimeouts</span>(<span class="params">Set&lt;Timeout&gt; <span class="keyword">set</span></span>)</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                HashedWheelTimeout timeout = pollTimeout();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (timeout.isExpired() || timeout.isCancelled()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">set</span>.<span class="keyword">add</span>(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> HashedWheelTimeout <span class="title">pollTimeout</span>()</span> &#123;</span><br><span class="line">            HashedWheelTimeout head = <span class="keyword">this</span>.head;</span><br><span class="line">            <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            HashedWheelTimeout next = head.next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = <span class="keyword">this</span>.head =  <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.head = next;</span><br><span class="line">                next.prev = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// null out prev and next to allow for GC.</span></span><br><span class="line">            head.next = <span class="literal">null</span>;</span><br><span class="line">            head.prev = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>HashedWheelTimeout</li></ul><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> HashedWheelTimeout <span class="keyword">implements</span> Timeout &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_INIT = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_IN_BUCKET = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_CANCELLED = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ST_EXPIRED = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;HashedWheelTimeout&gt; STATE_UPDATER =</span><br><span class="line">                AtomicIntegerFieldUpdater.newUpdater(HashedWheelTimeout.<span class="keyword">class</span>, <span class="string">&quot;state&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> HashedWheelTimer timer;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> TimerTask <span class="keyword">task</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> deadline;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&#123;<span class="string">&quot;unused&quot;</span>, <span class="string">&quot;FieldMayBeFinal&quot;</span>, <span class="string">&quot;RedundantFieldInitialization&quot;</span> &#125;)</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = ST_INIT;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// remainingRounds will be calculated and set by Worker.transferTimeoutsToBuckets() before the</span></span><br><span class="line">        <span class="comment">// HashedWheelTimeout will be added to the correct HashedWheelBucket.</span></span><br><span class="line">        <span class="keyword">long</span> remainingRounds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This will be used to chain timeouts in HashedWheelTimerBucket via a double-linked-list.</span></span><br><span class="line">        <span class="comment">// As only the workerThread will act on it there is no need for synchronization / volatile.</span></span><br><span class="line">        HashedWheelTimeout <span class="keyword">next</span>;</span><br><span class="line">        HashedWheelTimeout prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The bucket to which the timeout was added</span></span><br><span class="line">        HashedWheelBucket bucket;</span><br><span class="line"></span><br><span class="line">        HashedWheelTimeout(HashedWheelTimer timer, TimerTask <span class="keyword">task</span>, <span class="keyword">long</span> deadline) &#123;</span><br><span class="line">            <span class="keyword">this</span>.timer = timer;</span><br><span class="line">            <span class="keyword">this</span>.<span class="keyword">task</span> = <span class="keyword">task</span>;</span><br><span class="line">            <span class="keyword">this</span>.deadline = deadline;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Timer getTimer() &#123;</span><br><span class="line">            <span class="keyword">return</span> timer;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> TimerTask getTask() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">task</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> cancel() &#123;</span><br><span class="line">            <span class="keyword">int</span> state = state();</span><br><span class="line">            <span class="keyword">if</span> (state &gt;= ST_CANCELLED) &#123;</span><br><span class="line">                <span class="comment">// fail fast if the task was cancelled or expired before.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (state != ST_IN_BUCKET &amp;&amp; compareAndSetState(ST_INIT, ST_CANCELLED)) &#123;</span><br><span class="line">                <span class="comment">// Was cancelled before the HashedWheelTimeout was added to its HashedWheelBucket.</span></span><br><span class="line">                <span class="comment">// In this case we can just return here as it will be discarded by the WorkerThread when handling</span></span><br><span class="line">                <span class="comment">// the adding of HashedWheelTimeout to the HashedWheelBuckets.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// only update the state it will be removed from HashedWheelBucket on next tick.</span></span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_IN_BUCKET, ST_CANCELLED)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Add the HashedWheelTimeout back to the timeouts queue so it will be picked up on the next tick</span></span><br><span class="line">            <span class="comment">// and remove this HashedTimeTask from the HashedWheelBucket. After this is done it is ready to get</span></span><br><span class="line">            <span class="comment">// GC&#x27;ed once the user has no reference to it anymore.</span></span><br><span class="line">            timer.timeouts.add(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> remove() &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bucket.remove(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> compareAndSetState(<span class="keyword">int</span> expected, <span class="keyword">int</span> state) &#123;</span><br><span class="line">            <span class="keyword">return</span> STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, expected, state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> state() &#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isCancelled() &#123;</span><br><span class="line">            <span class="keyword">return</span> state == ST_CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isExpired() &#123;</span><br><span class="line">            <span class="keyword">return</span> state &gt; ST_IN_BUCKET;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> HashedWheelTimeout value() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> expire() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_IN_BUCKET, ST_EXPIRED)) &#123;</span><br><span class="line">                assert state() != ST_INIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">task</span>.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;An exception was thrown by &quot;</span> + TimerTask.<span class="keyword">class</span>.getSimpleName() + <span class="string">&#x27;.&#x27;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> currentTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">long</span> remaining = deadline - currentTime + timer.startTime;</span><br><span class="line"></span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">192</span>);</span><br><span class="line">            buf.<span class="keyword">append</span>(getClass().getSimpleName());</span><br><span class="line">            buf.<span class="keyword">append</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line"></span><br><span class="line">            buf.<span class="keyword">append</span>(<span class="string">&quot;deadline: &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (remaining &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(remaining);</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot; ns later&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (remaining &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(-remaining);</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot; ns ago&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot;now&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isCancelled()) &#123;</span><br><span class="line">                buf.<span class="keyword">append</span>(<span class="string">&quot;, cancelled&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            buf.<span class="keyword">append</span>(<span class="string">&quot;, task: &quot;</span>);</span><br><span class="line">            buf.<span class="keyword">append</span>(getTask());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> buf.<span class="keyword">append</span>(<span class="string">&#x27;)&#x27;</span>).toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashedWheelBucket创建">HashedWheelBucket创建</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HashedWheelBucket[] <span class="title">createWheel</span>(<span class="params"><span class="built_in">int</span> ticksPerWheel</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;ticksPerWheel must be greater than 0: &quot;</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ticksPerWheel &gt; <span class="number">1073741824</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">&quot;ticksPerWheel may not be greater than 2^30: &quot;</span> + ticksPerWheel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ticksPerWheel = normalizeTicksPerWheel(ticksPerWheel);</span><br><span class="line">        HashedWheelBucket[] wheel = <span class="keyword">new</span> HashedWheelBucket[ticksPerWheel];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; wheel.length; i ++) &#123;</span><br><span class="line">            wheel[i] = <span class="keyword">new</span> HashedWheelBucket();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wheel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">normalizeTicksPerWheel</span>(<span class="params"><span class="built_in">int</span> ticksPerWheel</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">int</span> normalizedTicksPerWheel = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (normalizedTicksPerWheel &lt; ticksPerWheel) &#123;</span><br><span class="line">            normalizedTicksPerWheel &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> normalizedTicksPerWheel;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="timeouts队列">timeouts队列</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> final Queue&lt;HashedWheelTimeout&gt; timeouts = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;HashedWheelTimeout&gt;<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">public Timeout <span class="keyword">new</span><span class="constructor">Timeout(TimerTask <span class="params">task</span>, <span class="params">long</span> <span class="params">delay</span>, TimeUnit <span class="params">unit</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (task<span class="operator"> == </span>null) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">NullPointerException(<span class="string">&quot;task&quot;</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">unit</span><span class="operator"> == </span>null) &#123;</span><br><span class="line">            throw <span class="keyword">new</span> <span class="constructor">NullPointerException(<span class="string">&quot;unit&quot;</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start<span class="literal">()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the timeout to the timeout queue which will be processed on the next tick.</span></span><br><span class="line">        <span class="comment">// During processing all the queued HashedWheelTimeouts will be added to the correct HashedWheelBucket.</span></span><br><span class="line">        long deadline = <span class="module-access"><span class="module"><span class="identifier">System</span>.</span></span>nano<span class="constructor">Time()</span> + <span class="built_in">unit</span>.<span class="keyword">to</span><span class="constructor">Nanos(<span class="params">delay</span>)</span> - startTime;</span><br><span class="line">        HashedWheelTimeout timeout = <span class="keyword">new</span> <span class="constructor">HashedWheelTimeout(<span class="params">this</span>, <span class="params">task</span>, <span class="params">deadline</span>)</span>;</span><br><span class="line">        timeouts.add(timeout);</span><br><span class="line">        return timeout;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Worker">Worker</h3><p>HashedWheelTimer的核心，主要处理tick的转动、过期任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Timeout&gt; unprocessedTimeouts = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Timeout&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> tick;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// Initialize the startTime.</span></span><br><span class="line">            startTime = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// We use 0 as an indicator for the uninitialized value here, so make sure it&#x27;s not 0 when initialized.</span></span><br><span class="line">                startTime = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Notify the other threads waiting for the initialization at start().</span></span><br><span class="line">            startTimeInitialized.countDown();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> waitForNextTick();</span><br><span class="line">                <span class="keyword">if</span> (deadline &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    transferTimeoutsToBuckets();</span><br><span class="line">                    <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span></span><br><span class="line">                            wheel[(<span class="type">int</span>) (tick &amp; mask)];</span><br><span class="line">                    bucket.expireTimeouts(deadline);</span><br><span class="line">                    tick++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_STARTED);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Fill the unprocessedTimeouts so we can return them from stop() method.</span></span><br><span class="line">            <span class="keyword">for</span> (HashedWheelBucket bucket: wheel) &#123;</span><br><span class="line">                bucket.clearTimeouts(unprocessedTimeouts);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                unprocessedTimeouts.add(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">transferTimeoutsToBuckets</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// transfer only max. 100000 timeouts per tick to prevent a thread to stale the workerThread when it just</span></span><br><span class="line">            <span class="comment">// adds new timeouts in a loop.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                <span class="type">HashedWheelTimeout</span> <span class="variable">timeout</span> <span class="operator">=</span> timeouts.poll();</span><br><span class="line">                <span class="keyword">if</span> (timeout == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// all processed</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (timeout.state() == HashedWheelTimeout.ST_CANCELLED</span><br><span class="line">                        || !timeout.compareAndSetState(HashedWheelTimeout.ST_INIT, HashedWheelTimeout.ST_IN_BUCKET)) &#123;</span><br><span class="line">                    <span class="comment">// Was cancelled in the meantime. So just remove it and continue with next HashedWheelTimeout</span></span><br><span class="line">                    <span class="comment">// in the queue</span></span><br><span class="line">                    timeout.remove();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">long</span> <span class="variable">calculated</span> <span class="operator">=</span> timeout.deadline / tickDuration;</span><br><span class="line">                <span class="type">long</span> <span class="variable">remainingRounds</span> <span class="operator">=</span> (calculated - tick) / wheel.length;</span><br><span class="line">                timeout.remainingRounds = remainingRounds;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">stopIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line">                <span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[stopIndex];</span><br><span class="line">                bucket.addTimeout(timeout);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * calculate goal nanoTime from startTime and current tick number,</span></span><br><span class="line"><span class="comment">         * then wait until that goal has been reached.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> Long.MIN_VALUE if received a shutdown request,</span></span><br><span class="line"><span class="comment">         * current time otherwise (with Long.MIN_VALUE changed by +1)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">waitForNextTick</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> tickDuration * (tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.nanoTime() - startTime;</span><br><span class="line">                <span class="type">long</span> <span class="variable">sleepTimeMs</span> <span class="operator">=</span> (deadline - currentTime + <span class="number">999999</span>) / <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (sleepTimeMs &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentTime == Long.MIN_VALUE) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -Long.MAX_VALUE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> currentTime;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check if we run on windows, as if thats the case we will need</span></span><br><span class="line">                <span class="comment">// to round the sleepTime as workaround for a bug that only affect</span></span><br><span class="line">                <span class="comment">// the JVM if it runs on windows.</span></span><br><span class="line">                <span class="comment">//</span></span><br><span class="line">                <span class="comment">// See https://github.com/netty/netty/issues/356</span></span><br><span class="line">                <span class="keyword">if</span> (DetectionUtil.isWindows()) &#123;</span><br><span class="line">                    sleepTimeMs = sleepTimeMs / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(sleepTimeMs);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (WORKER_STATE_UPDATER.get(HashedWheelTimer.<span class="built_in">this</span>) == WORKER_STATE_SHUTDOWN) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Long.MIN_VALUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Set&lt;Timeout&gt; <span class="title function_">unprocessedTimeouts</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.unmodifiableSet(unprocessedTimeouts);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>定位槽位</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HashedWheelBucket[] wheel = createWheel(ticksPerWheel);</span><br><span class="line">mask = wheel.<span class="built_in">length</span> - <span class="number">1</span>;</span><br><span class="line">HashedWheelBucket bucket = wheel[(<span class="type">int</span>) (tick &amp; mask)];</span><br></pre></td></tr></table></figure><p>比如有16个槽，则mask为15，假设当前tick=30，则槽位=14</p><ul><li>更新该槽位任务的remainingRounds<br>每走一个tick都要更新该tick对应的槽位下面的任务的remainingRounds或者执行到期的任务</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">bucket.<span class="built_in">expireTimeouts</span>(deadline);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">void</span> <span class="title">expireTimeouts</span><span class="params">(<span class="type">long</span> deadline)</span> </span>&#123;</span><br><span class="line">            HashedWheelTimeout timeout = head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// process all timeouts</span></span><br><span class="line">            <span class="keyword">while</span> (timeout != null) &#123;</span><br><span class="line">                <span class="type">boolean</span> remove = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeout.remainingRounds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (timeout.deadline &lt;= deadline) &#123;</span><br><span class="line">                        timeout.<span class="built_in">expire</span>();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// The timeout was placed into a wrong slot. This should never happen.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">IllegalStateException</span>(<span class="type">String</span>.format(</span><br><span class="line">                                <span class="string">&quot;timeout.deadline (%d) &gt; deadline (%d)&quot;</span>, timeout.deadline, deadline));</span><br><span class="line">                    &#125;</span><br><span class="line">                    remove = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout.<span class="built_in">isCancelled</span>()) &#123;</span><br><span class="line">                    remove = <span class="literal">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    timeout.remainingRounds --;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// store reference to next as we may null out timeout.next in the remove block.</span></span><br><span class="line">                HashedWheelTimeout next = timeout.next;</span><br><span class="line">                <span class="keyword">if</span> (remove) &#123;</span><br><span class="line">                    <span class="built_in">remove</span>(timeout);</span><br><span class="line">                &#125;</span><br><span class="line">                timeout = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行到期任务</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">expire</span>()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(ST_IN_BUCKET, ST_EXPIRED)) &#123;</span><br><span class="line">                <span class="function">assert <span class="title">state</span>() !</span>= ST_INIT;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                task.run(<span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">&quot;An exception was thrown by &quot;</span> + TimerTask.<span class="keyword">class</span>.getSimpleName() + <span class="string">&#x27;.&#x27;</span>, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里是同步执行，会阻塞整个timer的，需要异步。</p></blockquote><ul><li>transfer<br>每走一个tick的时候，要把task从queue中取出来，放到槽位。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">calculated</span> <span class="operator">=</span> timeout.deadline / tickDuration;</span><br><span class="line"><span class="type">long</span> <span class="variable">remainingRounds</span> <span class="operator">=</span> (calculated - tick) / wheel.length;</span><br><span class="line">timeout.remainingRounds = remainingRounds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="variable">ticks</span> <span class="operator">=</span> Math.max(calculated, tick); <span class="comment">// Ensure we don&#x27;t schedule for past.</span></span><br><span class="line"><span class="type">int</span> <span class="variable">stopIndex</span> <span class="operator">=</span> (<span class="type">int</span>) (ticks &amp; mask);</span><br><span class="line"></span><br><span class="line"><span class="type">HashedWheelBucket</span> <span class="variable">bucket</span> <span class="operator">=</span> wheel[stopIndex];</span><br><span class="line">bucket.addTimeout(timeout);</span><br></pre></td></tr></table></figure><h2 id="使用实例">使用实例</h2><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ﻿tickDuration: 每 tick 一次的时间间隔, 每 tick 一次就会到达下一个槽位</span></span><br><span class="line"><span class="comment">     * ticksPerWheel: 轮中的 slot 数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    @Test</span><br><span class="line">    public <span class="literal">void</span> testHashedWheelTimer() throws InterruptedException &#123;</span><br><span class="line">        HashedWheelTimer hashedWheelTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="number">1000</span>/**tickDuration**<span class="regexp">/, TimeUnit.MILLISECONDS, 16 /</span>**ticksPerWheel**/);</span><br><span class="line">        System.out.println(LocalTime.now()+<span class="string">&quot; submitted&quot;</span>);</span><br><span class="line">        Timeout timeout = hashedWheelTimer.newTimeout<span class="function"><span class="params">((t) -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> Thread()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                @Override</span></span></span><br><span class="line"><span class="params"><span class="function">                public <span class="literal">void</span> run() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; executed&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(hashedWheelTimer);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        TimeUnit.SECONDS.sleep(<span class="number">100</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        e.printStackTrace();</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; FINISH&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;.start();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">5</span>, TimeUnit.SECONDS)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">hashedWheelTimer</span>.<span class="title">newTimeout</span><span class="params">((t) -&gt; &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">new</span> Thread()&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                @Override</span></span></span><br><span class="line"><span class="params"><span class="function">                public <span class="literal">void</span> run() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; TASK2 executed&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(hashedWheelTimer);</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">try</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                        e.printStackTrace();</span></span></span><br><span class="line"><span class="params"><span class="function">                    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                    System.out.println(<span class="keyword">new</span> <span class="built_in">Date</span>() + <span class="string">&quot; TASK2 FINISH&quot;</span>);</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;.start();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;, <span class="number">15</span>, TimeUnit.SECONDS)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">TimeUnit</span>.<span class="title">SECONDS</span>.<span class="title">sleep</span><span class="params">(<span class="number">500</span>)</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><p>总体来说，<code>HashedWheelTimer</code>使用的是一个比较朴素的算法，要点有两个：</p><ol><li>添加定时任务<ol><li>如果worker线程没有执行则启动worker线程。</li><li>将定时任务task包装成<code>HashedWheelTimeout</code>，然后添加到<code>Queue&lt;HashedWheelTimeout&gt; timeouts</code>队列中</li></ol></li><li>worker线程的执行<ol><li>调用<code>waitForNextTick</code>方法等待直到下一个tick</li><li>调用<code>processCancelledTasks</code>方法处理被取消的任务。从<code>Queue&lt;HashedWheelTimeout&gt; cancelledTimeouts</code>队列（调用<code>cancel</code>方法取消任务时会将任务添加到该队列中）中取出被取消的任务，然后将其从格子的任务列表中移除。</li><li>计算当前tick所在的格子(<code>bucket</code>)</li><li>调用<code>transferTimeoutsToBuckets</code>方法将<code>timeouts</code>队列中新建的任务转移到所在格子的链表中</li><li>调用<code>HashedWheelBucket.expireTimeouts</code>方法执行到期的任务</li></ol></li></ol><p>这里有几个值的注意的数据结构：</p><ol><li>任务并不是直接放在格子中的，而是维护了一个双向链表，这种数据结构非常便于插入和移除。</li><li>新添加的任务并不直接放入格子，而是先放入一个队列中，这是为了避免多线程插入任务的冲突。在每个tick运行任务之前由worker线程自动对任务进行归集和分类，插入到对应的槽位里面。</li></ol><h2 id="相关链接">相关链接</h2><ul><li><p><a href="https://segmentfault.com/a/1190000010987765">java - HashedWheelTimer算法详解 - code-craft - SegmentFault 思否</a></p></li><li><p><a href="https://www.jianshu.com/p/311121f63d2f">定时任务之HashedWheelTimer - 简书 (jianshu.com)</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=Pq6wjH2PESfGLwNHQQelfw%3D%3D.m8IC%2FP5vjKLcBahNq9RhvVyOJAPO3bphJnUquigqpnrPKJOO7AUNoajKxlafdiq8OkJRRa%2FMx2ZmhaqprqvdKg%3D%3D">netty源码解读之时间轮算法实现-HashedWheelTimer</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=fD0IP2%2FHJvizRlOA8TgiJg%3D%3D.so9cbh%2F7kM2Z1iHwihShg%2BpYWIHL4gphfBCooz7J3ZJv2fwsI1viBVTMul4JsSIqo6vhdBikwfnAy%2BES1oM%2FMw%3D%3D">Timing Wheel 定时轮算法</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=W8Y7X0ev5Zw33j1bsTaB%2Fg%3D%3D.rxWVnie7pUbekY7su9DAjuOqYWNdOLRMfXyt01la5xCIfoefR05CROMvsFwUMUu1">细说延时任务的处理</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=Ol10zvO6HwKiW2y52%2Fa2Hg%3D%3D.Mgne%2BR4AAEkxvM1%2F0ikzDGnZzFHspdSzTs0B3ovIMOr%2FZS5q9UJCGNA9pN7EPMZ3">ifesdjeen-hashed-wheel-timer</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=iKGLRLH4LaJ%2BibMO9Ubs%2Bw%3D%3D.vVuY4FUZFOrNe92Hg8DFm5ohhFX1ncASKc0L8sRqwc9RZtzvCb%2BJ2sVukNp3jD8Z8jw0vGlMyJyjkuXeKlWNX7puOfjhaLIVk4nSjcd1X1c%3D">TimingWheels.ppt</a></p></li><li><p><a href="https://link.segmentfault.com/?enc=0%2F%2BPCfysbe4AB5Dof9DO7g%3D%3D.6pgxgj9%2B6uw34IrMmMUSMQklE07sZvt%2F3ZitJmMBNWiHKQUESeaMj5F8uY7Xjy6xgc0nhMkWU8yQIlWi6kdj%2FN4TU%2BY09n3QjiZtJZ2224H%2BTe3oogiKQG%2FFa%2BwB1MM49PFrZZmFQP8UE64azYsbsnbppQRDUSfFE7DxmOPUp3WchD%2BdgN4c8EevZI5%2BA3%2FD">定时器（Timer）的实现</a></p></li></ul><h2 id="QA">QA</h2><ul><li>Dubbo在2.7x中也实现了HashedWheelTimer，为什么不直接使用netty的实现</li></ul><p>​Dubbo在2.7.x版本中实现了自己的<code>HashedWheelTimer</code>，而没有直接使用Netty的实现，主要是为了满足特定的定制化需求，减少对外部依赖的管理，优化性能，确保控制权和可维护性，以及保证在不同环境中的一致性和兼容性。这使得Dubbo能够更好地适应其分布式服务框架的要求。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> Redisson </tag>
            
            <tag> WatchDog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redisson-看门狗（WatchDog）</title>
      <link href="/posts/6f94974c.html"/>
      <url>/posts/6f94974c.html</url>
      
        <content type="html"><![CDATA[<h1>Redisson-看门狗（WatchDog）</h1><h2 id="前言">前言</h2><p>说起 Redisson，比较耳熟能详的就是这个看门狗（Watchdog）机制。</p><p>本文就一起看看加锁成功之后的看门狗（Watchdog）是如何实现的？</p><h2 id="加锁成功">加锁成功</h2><p>在前一篇文章中介绍了可重入锁加锁的逻辑，其中 <code>RedissonLock#tryAcquireAsync</code> 方法是进行异步加锁的逻辑。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956499.png" alt="img"></p><p>回顾一下这个方法的入参：</p><ol><li>waitTime：-1；</li><li>leaseTime：-1，加锁时未指定锁时间，则为 -1，如果指定，则是指定的时间；</li><li>unit：null；</li><li>threadId：当前线程 id。</li></ol><p>其中的 <code>tryLockInnerAsync</code> 在之前已经介绍过了。</p><p>当加锁成功时，会返回 null，加锁失败，会返回当前锁的剩余时间。</p><p>所以这块会进入到红框标记的部分。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956354.png" alt="img"></p><p>leaseTime 为加锁时间，默认不指定，所以会进入到 <code>scheduleExpirationRenewal</code> 方法，也就是今天的主题：看门狗。</p><p>至此可以得出一个结论：</p><p><strong>Redisson 看门狗（Watchdog）在指定加锁时间时，是不会对锁时间自动续租的。</strong></p><h2 id="看门狗">看门狗</h2><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956795.png" alt="img"></p><p>看门狗的一部分重点逻辑就在 <code>renewExpiration</code> 方法这里：</p><ol><li>延迟调度，延迟时间为：<code>internalLockLeaseTime / 3</code>，就是 10s 左右后会调度这个 TimerTask；</li><li>异步续租：逻辑都在 renewExpirationAsync 里面；</li><li>递归调用：当续租成功之后，重新调用 <code>renewExpiration</code> 自己，从而达到持续续租的目的；</li><li>当然也不能一直无限续租，所以中间有一些判断逻辑，就是用来中断续租的。</li></ol><h3 id="续租逻辑">续租逻辑</h3><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956618.png" alt="img"></p><p>这块也是一个 lua 脚本，就是将之前的 redis key 直接重新设置时间。</p><p>这样一通续租下来，就是<strong>在过了 10s 左右将锁的时间重新设置为 30s</strong>。</p><h2 id="总结">总结</h2><p>至此，看门狗介绍完毕，简要总结一下内容。</p><ol><li>只有在未指定锁超时时间时才会使用看门狗；</li><li>看门狗默认续租时间是 10s 左右，<code>internalLockLeaseTime / 3</code>；</li><li>可以通过 Config 统一设置看门狗的时间，设置 <code>lockWatchdogTimeout</code> 参数即可。</li></ol><p>最后，同样使用一张图，进行下总结：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150956440.png" alt="img"></p><h2 id="相关链接">相关链接</h2><ul><li><a href="https://segmentfault.com/a/1190000040283488">java - Redisson 分布式锁源码 02：看门狗 - 小航的技术笔记 - SegmentFault 思否</a></li><li><a href="https://blog.csdn.net/Lin_xiaofeng/article/details/126054407">java使用看门狗原理实现监听业务_java 看门狗-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redisson </tag>
            
            <tag> WatchDog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github API 调用 (v3）</title>
      <link href="/posts/87a20176.html"/>
      <url>/posts/87a20176.html</url>
      
        <content type="html"><![CDATA[<h1>Github API 调用 (v3）</h1><blockquote><p>对于常用Github的用户来说，经常有一些自动化的需求。比如我的需求是定时备份Github的issues和comments到本地。以下为Github的API的使用参考。<br><a href="https://docs.github.com/en/rest?apiVersion=2022-11-28">v3版API的文档链接</a><br><a href="https://docs.github.com/en/rest/quickstart?apiVersion=2022-11-28">V3版API的官方文档</a></p></blockquote><h2 id="基本访问路径-Root-Endpoints">基本访问路径 (Root Endpoints)</h2><p>一开始读文档的时候，照着它的事例直接在命令行里<code>curl</code>，或者在InSomnia或Postman软件里访问，都完美显示200状态。可是一旦把链接里改写成自己的用户名就各种显示404无页面。还以为是授权问题，然后在页头HEADER中按照各种方式试了username和token密钥，都没用还是404。结果发现，原来不是方法的问题，纯粹是链接地址没写对！<br><code>实际上只是读取的话，完全不用任何授权</code>，可以在命令行、Insomnia、网页等各种情况下直接输入链接访问任何人的所有公开信息。<br>然后对照<a href="https://link.segmentfault.com/?enc=0zhtwwh2hv9Fre9w5p3o1Q%3D%3D.mN2W8LfkWH7ijOCHxIQsOo%2Bdc6IEFRCfeseruhYZwg8%3D">官方路径列表Root Endpoints</a>得到的链接，好像怎么访问都不对。反而在Stackoverflow中看到的一个链接，顺藤摸瓜自己发现了各种正确的访问路径，总结如下：</p><ul><li>首先！访问的链接最后不能有<code>/</code>。如<code>https://api.github.com/users/solomonxie</code>是可以访问到我个人信息的，但是<code>https://api.github.com/users/solomonxie/</code>就不行了，唯一不同是多了一个<code>/</code>.</li><li>其次！不同于一般URL访问，GIthub的API访问链接是<code>区分大小写</code>的！</li><li>个人主要信息。 <code>https://api.github.com/users/用户名</code>,得到数据如下图：</li></ul><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951956.webp" alt="image"></p><ul><li>个人所有repo。<code>https://api.github.com/users/用户名/repos</code>。会得到一个repo的JSON格式列表。</li><li>repo详细信息。<code>https://api.github.com/repos/用户名/仓库名</code>。repo的路径就开始和个人信息不同了。</li><li>获取某个repo的内容列表。<code>https://api.github.com/repos/solomonxie/gists/contents</code>，注意这只会返回根目录的内容。</li><li>获取repo中子目录的内容列表。<code>https://api.github.com/repos/solomonxie/gists/contents/目录名</code>。一定要注意这里一定要完全遵循原文件名的大小写，否则无法获得信息。如果是更深层的内容，则在链接列按照顺序逐级写上目录名称。</li><li>获取repo中某文件信息（不包括内容）。<code>https://api.github.com/repos/solomonxie/gists/contents/文件路径</code>。文件路径是文件的完整路径，区分大小写。只会返回文件基本信息。</li><li>获取某文件的原始内容（Raw）。1. 通过上面的文件信息中提取<code>download_url</code>这条链接，就能获取它的原始内容了。2. 或者直接访问：<code>https://raw.githubusercontent.com/用户名/仓库名/分支名/文件路径</code></li><li>repo中所有的commits列表。<code>https://api.github.com/repos/用户名/仓库名/commits</code>。</li><li>某一条commit详情。<code>https://api.github.com/repos/用户名/仓库名/commits/某一条commit的SHA</code></li><li>issues列表。<code>https://api.github.com/repos/用户名/仓库名/issues</code>。</li><li>某条issue详情。<code>https://api.github.com/repos/用户名/仓库名/issues/序号</code>。issues都是以1,2,3这样的序列排号的。</li><li>某issue中的comments列表。<code>https://api.github.com/repos/用户名/仓库名/issues/序号/comments</code>。</li><li>某comment详情。<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论详情的ID</code>。其中评论ID是从issues列表中获得的。</li></ul><h2 id="查询参数-Parameters">查询参数 (Parameters)</h2><p>如果在上面基本链接中加入查询条件，那么返回的数据就是filtered，过滤了的。比如要求只返回正在开放的issues，或者让列表数据分页显示。常用如下：</p><ul><li>分页功能。格式是<code>?page=页数&amp;per_page=每页包含数量</code>。</li></ul><p>如<code>https://api.github.com/users/solomonxie/repos?page=2&amp;per_page=3</code></p><ul><li>issues状态。格式是<code>?state=状态</code>。</li></ul><p>如<code>https://api.github.com/repos/solomonxie/solomonxie.github.io/issues?state=closed</code></p><h2 id="权限认证-Authentication">权限认证 Authentication</h2><blockquote><p>首先需要知道都是，到此为止之前所有都查询都是不需要任何权限的，给个地址就返回数据，全公开。<br>但是创建文件、更新、删除等就是必须用自己的账号&quot;登录&quot;才能实现的。所以为了下面的增删改做准备，需要先看一下权限问题。<br>官网虽然写的很简答，不过如果不熟悉API的话还是不能马上就理解。</p></blockquote><p>常用的认证方法有三种，<code>Basic authentication</code>, <code>OAuth2 token</code>, <code>OAuth2 key/secret</code><br>三种方法效果一样，但是各有其特点和方便之处。选哪种就要看自己哪种方便了。</p><h3 id="认证方法一：Basic-authentication">认证方法一：Basic authentication</h3><p>这种最简单，如果是用curl的话，就：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u <span class="string">&quot;用户名:密码&quot;</span> https:<span class="regexp">//</span>api.github.com</span><br></pre></td></tr></table></figure><p>如果是用Insomnia等api调试工具的话，直接在Auth选项栏里选Basic Auth，然后填上用户名密码即可。</p><h3 id="认证方法二：OAuth2-token">认证方法二：OAuth2 token</h3><h4 id="关于token">关于token</h4><blockquote><p>这种token方式，说实话如果不是操作过API或深度了解REST的话，是很难理解的东西。<br>说白了就是<code>第二个密码</code>，你既不用到处泄露自己的用户名密码，又可以专门给这个&quot;第二密码&quot;设置不同需要的权限，如有的只可读有的还可以写等。而且这个“第二密码”是既包括用户名又包括密码功能的，全站只此一个绝对不会和别人重复。初次之外，你还可以设置很多个token，也就是第三、第四、第五…密码。很方便。</p></blockquote><h4 id="设置token方法">设置token方法</h4><p>就位于github个人账号设置-&gt;开发者设置-&gt;个人token里。创建一个新token时，可以选择具体的权限，创建成功时一定要复制到本地哪里保存，只会让你看见一次，如果忘记的话就需要重新生成（其实丢了也不算麻烦）。<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951868.webp" alt="image"></p><p>另外！注意：</p><blockquote><p>token字符串不能存储在github的repo中，经过测试，一旦提交的文件中包含这个token字符串，那么github就会自动删除这个token -_-! 我用了很久才明白过来，创建的Personal Access Token总是自动消失，还以为是有时限的。</p></blockquote><h4 id="用token通过权限认证">用token通过权限认证</h4><p>有两种传送方法，哪种都可以：</p><ol><li>作为url中的参数明文传输：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https:<span class="regexp">//</span>api.github.com/?access_token=OAUTH-TOKEN</span><br></pre></td></tr></table></figure><ol><li>作为header中的参数传输：</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: token OAUTH-TOKEN&quot;</span> https:<span class="regexp">//</span>api.github.com</span><br></pre></td></tr></table></figure><p>如果不是用curl而是Insomnia测试的话，和上面basic auth是大同小异的，很容易操作就不复述了。<br>到此为止，权限认证就算搞清了，而且也实际验证过有效了。强烈建议用insomnia工具操作，有GUI界面方便理解，成功后再转为curl或python等程序语言。</p><h3 id="认证方法三：OAuth2-key-secret">认证方法三：OAuth2 key/secret</h3><p>这个是除了Personal Access Token之外的另一种好用的方法，即创建自己的OAuth app，然后得到一对<code>client_id</code>和<code>client_secret</code>。如下：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951962.webp" alt="image"><br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951836.webp" alt="image"><br>得到这两个值之后，直接在访问任何api的url连接后面显性加上这两个参数即可完成认证，如：<br><code>https://api.github.com/users/yourusername?client_id=YOUR-CLIENT-ID&amp;client_secret=YOUR-CLIENT-SECRET</code><br>但是：</p><blockquote><p>目前这种认证方式<strong>不支持</strong>查询以外的操作，也就是只能GET获取某些api信息，不能执行request里的任何PUT/PATCH/DELETE操作。</p></blockquote><h2 id="创建新文件-Create-content">创建新文件 Create content</h2><blockquote><p><a href="https://link.segmentfault.com/?enc=6J0ZNCI1z5xe8NW0ErjLjw%3D%3D.28GtMY3g6Q%2FzMAdzblEqwFBpjbAqGy1%2B%2Fkbds9sgl2Wp%2BOHXBsUKovo2FVE1jJeFGqhybfNXXoOvzZDiEePWDg%3D%3D">Contents操作 官方文档</a></p></blockquote><ul><li>传输方法：<code>PUT</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/contents/文件路径</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;commit from INSOMNIA&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;bXkgbmV3IGZpbGUgY29udGVudHM=&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JSON填写如下图：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951985.webp" alt="image"></p><ul><li>注意：1.必须添加权限验证（上面有写） 2. 数据传送格式选择JSON 3. 文件内容必须是把文件整体转为Base64字符串再存到JSON变量中 4. 文件路径中如果有不存在的文件夹，则会自动创建</li></ul><p>起初不管怎么尝试都一直报同样都错误，400 Invalid JSON，如下图：<br>[图片上传失败…(image-884e71-1527903120996)]</p><p>最后发现原来是犯了很小很小都错误才导致如此：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951217.webp" alt="image"><br>原来，我的token看似是正常的，唯独错误的是，多了一个空行！也就是说，标明都是invalid JSON，结果没注意竟然是invalid Token!</p><p>增加文件成功后返回的消息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951613.webp" alt="image"></p><h2 id="更新文件-Update-content">更新文件 Update content</h2><blockquote><p>主要这几点： 1. 传送方式用<code>PUT</code> 和创建文件一样 2. 需要权限验证，3. 传输内容数据用JSON 4. 需要指定该文件的SHA码 4. 路径和访问content时一样 5. 文件内容必须是把文件整体转为Base64字符串再存到JSON变量中</p></blockquote><ul><li>传输方法：<code>PUT</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/contents/文件路径</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;update from INSOMNIA&quot;</span>,</span><br><span class="line">  <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Y3JlYXRlIGZpbGUgZnJvbSBJTlNPTU5JQQoKSXQncyB1cGRhdGVkISEhCgpJdCdzIHVwZGF0ZWQgYWdhaW4hIQ==&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sha&quot;</span>: <span class="string">&quot;57642f5283c98f6ffa75d65e2bf49d05042b4a6d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：必须指定该文件的<code>SHA码</code>，相当于文件的ID。</li></ul><h2 id="SHA虽然是对文件的唯一识别码，相当于ID，但是它是会随着文件内容变化而变化的！所以必须每次都重新获取才行。"><code>SHA</code>虽然是对文件的唯一识别码，相当于ID，但是它是会随着文件内容变化而变化的！所以必须每次都重新获取才行。</h2><p>至于获取方式，验证后发现，目前最靠谱的是用前面的<code>get content</code>获取到该文件的信息，然后里面找到<code>sha</code>。</p><p>对上传时的JSON格式另有要求，如果没有按照要求把必填项输入，则会出现422错误信息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951316.webp" alt="image"></p><p>或者如果用错了SHA，会出现409错误消息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150951758.webp" alt="image"></p><p>如果正确传送，就会显示200完成更新：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150950271.webp" alt="image"></p><h2 id="删除文件-Delete-content">删除文件 Delete content</h2><ul><li>传输方法：<code>DELETE</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/contents/文件路径</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;message&quot;</span>: <span class="string">&quot;delete a file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;sha&quot;</span>: <span class="string">&quot;46d2b1f2ef54669a974165d0b37979e9adba1ab2&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除成功后，会返回200消息：<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150950692.webp" alt="image"></p><h2 id="增删改issues">增删改issues</h2><blockquote><p>如果做过了上面文件的增删改，这里大同小异，不同的访问路径和JSON的格式而已。唯一不同的是，issues是不用把内容转为Base64码的。</p></blockquote><p>参考链接：<a href="https://link.segmentfault.com/?enc=cubTHVRW%2B%2B3zhF0MSvjjEA%3D%3D.XT5VmuuWDDx%2FjO0NHyEGX0FVrxlM1wwXX1C7rRYN5RJYE7spyL2bsP1V5my3qBJw7fiukuRfawjZtv3YseOq3A%3D%3D">github官方文档</a></p><h3 id="增加一条issue">增加一条issue</h3><ul><li>传输方法：<code>POST</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Creating issue from API&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Posting a issue from Insomnia&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：issue的数据里面是可以加label，milestone和assignees的。但是必须注意milestone和assignees必须是已有的名次完全对应才行，否则无法完成创建。</li></ul><h3 id="更改某条issue">更改某条issue</h3><ul><li>传输方法：<code>PATCH</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Creating issue from API ---updated&quot;</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Posting a issue from Insomnia \n\n Updated from insomnia.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: <span class="string">&quot;open&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：如果JSON中加入空白的labels或assignees，如<code>&quot;labels&quot;: []</code>，作用就是清空所有的标签和相关人。</li></ul><h3 id="锁住某条issue">锁住某条issue</h3><p>不允许别人评论（自己可以）<br><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406150950039.webp" alt="image"></p><ul><li>传输方法：<code>PUT</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号/lock</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;locked&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;active_lock_reason&quot;</span>: <span class="string">&quot;too heated&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：active_lock_reason只能有4种值可选：<code>off-topic</code>, <code>too heated</code>, <code>resolved</code>, <code>spam</code>，否则报错。</li></ul><p>另外，成功锁住，会返回<code>204 No Content</code>信息。</p><h3 id="解锁某条issue">解锁某条issue</h3><ul><li>传输方法：<code>DELETE</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号/lock</code></li><li>无JSON传输</li></ul><h2 id="增删改comments">增删改comments</h2><blockquote><p>参考<a href="https://link.segmentfault.com/?enc=qYItiCFOCjgxsyvnFS0IeQ%3D%3D.W4f9KfCM2N1UB%2F562ZAgnz1tp%2FWdNWxdwlpWEb9gYTKz%2BSDlL9McsQzG%2FLu%2BB7e1zSo60TF%2FPnjkVSNHLpbvHC1QeNRP0Edny1FwyFpf6%2Fc%3D">官方文档</a></p></blockquote><h3 id="增加comment">增加comment</h3><ul><li>传输方法：<code>POST</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/序号/comments</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Create a comment from API&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更改comment">更改comment</h3><ul><li>传输方法：<code>PATCH</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID</code></li><li>JSON格式：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: <span class="string">&quot;Create a comment from API \n\n----Updated&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：地址中，issues后不用序号了，因为可以通过唯一的<code>评论ID</code>追查到。查看评论ID的方法，直接在上面查询链接中找。</li></ul><h3 id="删除comment">删除comment</h3><ul><li>传输方法：<code>DELETE</code></li><li>访问路径：<code>https://api.github.com/repos/用户名/仓库名/issues/comments/评论ID</code></li><li>无传输数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
            <tag> API </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows旋转屏幕后鼠标方向没变的解决实例</title>
      <link href="/posts/25658fff.html"/>
      <url>/posts/25658fff.html</url>
      
        <content type="html"><![CDATA[<h1>Windows旋转屏幕后鼠标方向没变的解决实例</h1><p>如果你在将Windows外接显示器更改显示方向后，出现鼠标并未旋转仍然保持原显示方向的情况时，可以尝试以下方式进行解决：</p><ol><li>尝试切换分辨率，切换后再修改回来确认是否可以修正</li><li>重启设备再次确认情况</li><li>打开NVIDIA Panel查看显示器状态是否正确并刷新设置</li></ol>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 屏幕方向改变 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript（JS）遍历对象</title>
      <link href="/posts/807271b8.html"/>
      <url>/posts/807271b8.html</url>
      
        <content type="html"><![CDATA[<p>在 JavaScript 中，对象是一种非常重要的数据结构，要访问和处理对象中的属性和方法，我们需要能够遍历对象。本文将介绍在 JavaScript 中遍历对象的几种常见方法。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202406110908690.png" alt="javascript js 中遍历对象 Object 的方法"></p><h2 id="JavaScript-中遍历对象的基本概念">JavaScript 中遍历对象的基本概念</h2><p>遍历对象就是访问对象中的每一个属性，对属性进行读取或操作。常见的遍历对象的场景包括:</p><ul><li>打印出对象的所有属性名和值</li><li>查找对象中是否存在某个属性</li><li>对对象的属性进行修改或删除遍历对象可以让我们更好地访问和利用对象中的数据。</li></ul><h2 id="JavaScript-中的对象遍历方法">JavaScript 中的对象遍历方法</h2><p>在 JavaScript 中，有几种常用的方法来遍历对象。下面将介绍这些方法，并提供详细的解释和示例代码。</p><h3 id="1-for…in-循环"><strong>1.for…in 循环</strong></h3><p><code>for...in</code> 循环可以用来遍历对象的可枚举属性，包括原型链上的属性。它将遍历对象的所有键，并允许你访问对应的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Alice&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Engineer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;person[key]&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-Object-keys-方法">2.<strong>Object.keys() 方法</strong></h3><p><code>Object.keys()</code> 方法返回一个包含对象自身可枚举属性名称的数组。你可以遍历这个数组来访问对象的属性和值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Designer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> keys = <span class="title class_">Object</span>.<span class="title function_">keys</span>(person);</span><br><span class="line">keys.<span class="title function_">forEach</span>(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;person[key]&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="3-Object-values-方法">3.<strong>Object.values() 方法</strong></h3><p><code>Object.values()</code> 方法返回一个包含对象自身可枚举属性值的数组。你可以遍历这个数组来访问对象的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Charlie&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">28</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Artist&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> values = <span class="title class_">Object</span>.<span class="title function_">values</span>(person);</span><br><span class="line">values.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="4-Object-entries-方法">4.<strong>Object.entries() 方法</strong></h3><p><code>Object.entries()</code> 方法返回一个包含对象自身可枚举属性键值对的数组。每个键值对都以数组形式表示，第一个元素是属性名，第二个元素是属性值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;David&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">22</span>,</span><br><span class="line">  <span class="attr">job</span>: <span class="string">&#x27;Writer&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> entries = <span class="title class_">Object</span>.<span class="title function_">entries</span>(person);</span><br><span class="line">entries.<span class="title function_">forEach</span>(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Echarts X轴标签过长显示不全的解决</title>
      <link href="/posts/227ef8c8.html"/>
      <url>/posts/227ef8c8.html</url>
      
        <content type="html"><![CDATA[<h1>Echarts X轴标签过长显示不全的解决</h1><p>Echarts 是国内图表组件占有率最高的第三方库，在使用中我们经常遇到 X 轴标签文字过长导致显示不全或 X 轴标签刻度间隔不够的问题。本文详细讲解 4 种标签超长显示问题的解决方案，轻松解决所有场景下的超长问题。</p><h2 id="方法一：Echarts-X-轴-标签倾斜摆放">方法一：Echarts X 轴 标签倾斜摆放</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">nameLocation</span>: <span class="string">&#x27;end&#x27;</span>, <span class="comment">// 名称显示在 X 坐标轴的位置</span></span><br><span class="line">    <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">      <span class="comment">//  X 坐标轴标签相关设置</span></span><br><span class="line">      <span class="attr">interval</span>: <span class="number">0</span>, <span class="comment">//使x轴文字显示全</span></span><br><span class="line">      <span class="attr">rotate</span>: <span class="string">&#x27;45&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h2 id="方法二：Echarts-X-轴-限制每行字数，换行显示">方法二：Echarts X 轴 限制每行字数，换行显示</h2><p>「换行显示标签」适合按字数断句的场景，X 轴每个标签都是前 N 个字一断是一个完整的词时，特别适合这种场景实用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xAxis</span>: &#123;</span><br><span class="line">  <span class="attr">data</span>: [</span><br><span class="line">  ...</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">nameLocation</span>: <span class="string">&#x27;end&#x27;</span>, <span class="comment">// 名称显示在 X 坐标轴的位置</span></span><br><span class="line">  <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">    <span class="attr">formatter</span>: <span class="keyword">function</span> (<span class="params">params</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> newParamsName = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 拼接后的新字符串</span></span><br><span class="line">      <span class="keyword">var</span> paramsNameNumber = params.<span class="property">length</span>; <span class="comment">// 实际标签数</span></span><br><span class="line">      <span class="keyword">var</span> provideNumber = <span class="number">3</span>; <span class="comment">// 每行显示的字数</span></span><br><span class="line">      <span class="keyword">var</span> rowNumber = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(paramsNameNumber / provideNumber); <span class="comment">// 如需换回，算出要显示的行数</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (paramsNameNumber &gt; provideNumber) &#123;</span><br><span class="line">        <span class="comment">/** 循环每一行,p表示行 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; rowNumber; i++) &#123;</span><br><span class="line">          <span class="keyword">var</span> tempStr = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 每次截取的字符串</span></span><br><span class="line">          <span class="keyword">var</span> start = i * provideNumber; <span class="comment">// 截取位置开始</span></span><br><span class="line">          <span class="keyword">var</span> end = start + provideNumber; <span class="comment">// 截取位置结束</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 最后一行的需要单独处理</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (i == rowNumber - <span class="number">1</span>) &#123;</span><br><span class="line">            tempStr = params.<span class="title function_">substring</span>(start, paramsNameNumber);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tempStr = params.<span class="title function_">substring</span>(start, end) + <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          newParamsName += tempStr;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newParamsName = params;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> newParamsName;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="方法三：Echarts-X-轴-垂直竖显文字">方法三：Echarts X 轴 垂直竖显文字</h2><p>「垂直显示标签」的情况，显得更正式一些。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">        ...</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">nameLocation</span>: <span class="string">&#x27;end&#x27;</span>, <span class="comment">// 名称显示在 X 坐标轴的位置</span></span><br><span class="line">    <span class="attr">axisLabel</span>: &#123;</span><br><span class="line">      <span class="attr">interval</span>: <span class="number">0</span>, <span class="comment">//使x轴文字显示全</span></span><br><span class="line">      <span class="attr">formatter</span>: <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>总的来说，本质就两种方法：</p><ol><li>文本倾斜显示</li><li>使用自定义的formatter</li></ol>]]></content>
      
      
      <categories>
          
          <category> front </category>
          
      </categories>
      
      
        <tags>
            
            <tag> echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows mklink</title>
      <link href="/posts/e23da863.html"/>
      <url>/posts/e23da863.html</url>
      
        <content type="html"><![CDATA[<h1>解决 mklink 使用中的各种坑（硬链接，软链接/符号链接，目录链接）</h1><blockquote><p><a href="https://blog.walterlv.com/post/problems-of-mklink.html">解决 mklink 使用中的各种坑（硬链接，软链接/符号链接，目录链接） - walterlv</a></p></blockquote><p>通过 mklink 命令可以创建文件或文件夹的链接，而这种链接跟快捷方式是不一样的。然而我们还可能会遇到其使用过程中的一些坑，本文将整理这些坑并提供解决方法。</p><hr><h2 id="背景介绍：mklink">背景介绍：mklink</h2><p><code>mklink</code> 可以像创建快捷方式一样建立文件或文件夹的链接，但不同于快捷方式的是，<code>mklink</code> 创建的链接绝大多数程序都不会认为那是一个链接，而是一个实实在在的文件或文件夹。</p><p>例如，为 <code>D:\OneDrive\Foo</code> 文件夹创建链接到 <code>D:\Foo</code>，那么 <code>D:\OneDrive\Foo</code> 中有一个 <code>.git</code> 文件时，绝大多数程序都会以为 <code>D:\Foo</code> 中也存在 <code>.git</code> 文件，而且文件内容一模一样。</p><p><code>mklink</code> 可以创建符号链接、硬链接和目录链接。在 <code>cmd</code> 中输入 <code>mklink</code> 即可看到以下这样的帮助信息。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> C:\Users\lvyi&gt;mklink 创建符号链接。 MKLINK<span class="meta"> [[/D] | [/H] | [/J]] Link Target         /D      创建目录符号链接。默认为文件                符号链接。        /H      创建硬链接而非符号链接。        /J      创建目录联接。        Link    指定新的符号链接名称。        Target  指定新链接引用的路径                (相对或绝对)。 </span></span><br></pre></td></tr></table></figure><p>具体的使用不是本文的重点，可以阅读本文末尾的参考资料了解，这里只给出他们之间的大体区别。</p><table><thead><tr><th>使用方式</th><th>适用于</th><th>快捷方式小箭头</th></tr></thead><tbody><tr><td>不带参数</td><td>文件</td><td>有</td></tr><tr><td>/D</td><td>文件夹</td><td>有</td></tr><tr><td>/J</td><td>文件夹</td><td>有</td></tr><tr><td>/H</td><td>文件</td><td>无</td></tr></tbody></table><p>上面的表格顺序，从上到下的行为从越来越像快捷方式到越来越像两个独立的文件夹。</p><h2 id="0x01-坑：PowerShell-中没有-mklink-命令">0x01 坑：PowerShell 中没有 mklink 命令</h2><p>是的，PowerShell 中就是中没有 mklink 命令。如果要在 powershell 中使用 mklink，那么得先敲 <code>cmd</code> 进入 <code>cmd</code> 之后再使用 <code>mklink</code> 命令。</p><p>如果你是一个重度强迫症患者，那么可以编写一个 powershell 的扩展函数来实现：<a href="https://learn-powershell.net/2013/07/16/creating-a-symbolic-link-using-powershell/">Creating a Symbolic Link using PowerShell - Learn Powershell - Achieve More</a>。</p><h2 id="0x02-坑：权限">0x02 坑：权限</h2><p>默认我们的用户账户是 <code>Administrators</code> 组的，会继承它的权限设定。正常情况下，我们使用 <code>mklink</code> 是可以成功执行的。但如果文件系统的设置比较奇怪或者重装过系统，那么可能出现没有权限的错误。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">2</span> C:\Users\lvyi&gt;mklink /D D:\Foo D:\OneDrive\Foo 你没有足够的权限执行此操作。 </span><br></pre></td></tr></table></figure><p>这时，使用管理员权限启动 <code>cmd</code> 是最简单的做法。不过也可以考虑在 <code>本地安全策略（secpol.msc）\本地策略\用户权利分配</code> 中添加当前用户。</p><hr><p><strong>参考链接</strong></p><ul><li><a href="https://www.sinosky.org/mklink-cmd-useful-tips.html">活用 MKLINK 命令保护、节省你的硬盘 - SinoSky</a></li><li><a href="http://blog.csdn.net/NotBack/article/details/73604292">关于mklink的/D /J 区别 - CSDN博客</a></li><li><a href="https://learn-powershell.net/2013/07/16/creating-a-symbolic-link-using-powershell/">Creating a Symbolic Link using PowerShell - Learn Powershell - Achieve More</a></li><li><a href="https://answers.microsoft.com/zh-hans/windows/forum/windows_10-files-winpc/win10/8df12869-96f4-4cd1-a914-355e908a6015">win10 无法运行mklink命令同步onedrive和电脑数据 - Microsoft Community</a></li><li><a href="http://blog.csdn.net/u011583025/article/details/52908508">Win10下执行mklink提示你没有足够权限执行此操作 - CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> mklink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于vercel搭建ChatGpt代理网站</title>
      <link href="/posts/59742fa1.html"/>
      <url>/posts/59742fa1.html</url>
      
        <content type="html"><![CDATA[<h1>基于vercel搭建ChatGpt代理网站</h1><blockquote><p>代理搭建基于开源项目：<a href="https://github.com/pengzhile/pandora">pengzhile/pandora: 潘多拉，一个让你呼吸顺畅的ChatGPT。Pandora, a ChatGPT that helps you breathe smoothly. (github.com)</a></p></blockquote><p>==基于代理访问ChatGpt等网站本质上是通过别人服务器进行流量转发，如担心隐私等问题请谨慎使用。本文仅提供搭建方法，不承担任何责任。==</p><hr><h2 id="平台选择">平台选择</h2><p>如果有现成的服务器可以直接使用服务器搭建(有国外服务器的话可以直接搭建中转服务，不用基于pandora)或者使用站点托管平台(vervel、render、replit等)。使用托管平台不用支付任何成本，本文使用vercel进行演示。</p><blockquote><p><code>vercel</code> 是一个站点托管平台，提供CDN加速，同类的平台有<code>Netlify</code> 和 <code>Github Pages</code>，相比之下，<code>vercel</code> 国内的访问速度更快，并且提供<code>Production</code>环境和<code>development</code>环境，对于项目开发非常的有用的，并且支持持续集成，一次<code>push</code>或者一次<code>PR</code>会自动化构建发布，发布在<code>development</code>环境，都会生成不一样的链接可供预览。</p></blockquote><hr><h2 id="开始之前">开始之前</h2><p>首先你得拥有一个github账号和vercel账号，请先完成账号的注册和登录。(GitHub和vercel在国内不一定能否正常访问，可能需要一些特殊手段 😉)</p><h2 id="开始搭建">开始搭建</h2><ol><li><p>新建项目</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211718905.png" alt="image-20230821171755382"></p></li><li><p>导入开源项目(fork)</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211720792.png" alt=""></p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211722483.png" alt="image-20230821172214330"></p></li><li><p>完成创建</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211725092.png" alt="image-20230821172530985"></p></li><li><p>搭建成功，查看</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211821683.png" alt="image-20230821172836633"></p></li></ol><blockquote><p>如果不想花费任何成本，那么到这里代理搭建已经成功了。如果你需要一个便于记忆的域名(如图中标注)，那么你需要额外购买域名并配置解析，</p></blockquote><h2 id="vercel关于自定义域名绑定">vercel关于自定义域名绑定</h2><ol><li><p>点击domains</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211731307.png" alt="image-20230821173132881"></p></li><li><p>域名解析</p><p>域名解析有很多教程，阿里云等云厂商也有对应的指导，请结合vercel官网的博文自行查阅和学习。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211739727.png" alt="image-20230821173921458"></p></li><li><p>域名绑定</p><p>输入解析好的域名，比如我使用了我的域名[yoshidacloud.top]解析了二级域名[chat.yoshidacloud.top]。</p></li></ol><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211733116.png" alt="image-20230821173301614"></p><p>整个ChatGpt的代理搭建教程到这里就结束 了，接下来你就可以使用国内网络使用chatgpt官方服务了🙌</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202308211743328.png" alt="image-20230821174327338"></p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> ChatGpt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>税务-定额发票查验</title>
      <link href="/posts/2bde57b6.html"/>
      <url>/posts/2bde57b6.html</url>
      
        <content type="html"><![CDATA[<h1>定额发票查验</h1><h2 id="四川">四川</h2><p><a href="https://etax.sichuan.chinatax.gov.cn/yhs-web/cxzx/index.html?code=1111&amp;id=846#/scfpcx/">https://etax.sichuan.chinatax.gov.cn/yhs-web/cxzx/index.html?code=1111&amp;id=846#/scfpcx/</a></p><h2 id="广东">广东</h2><p><a href="https://etax.guangdong.chinatax.gov.cn/xxmh/html/index_origin.html?gopage=true&amp;m1=gzcx&amp;m2=&amp;fromWhere=&amp;qxkzsx=0&amp;tabTitle=null&amp;cdId=dlqcd-1&amp;gnDm=gndm-dlqcd-1#none">国家税务总局广东省电子税务局 (chinatax.gov.cn)</a></p><h2 id="深圳">深圳</h2><p><a href="https://etax.shenzhen.chinatax.gov.cn/BsfwtWeb/apps/views/fp/fpcy/fp_fpcy.html">发票查验 - 国家税务总局深圳市税务局网上办税服务厅 (chinatax.gov.cn)</a></p><h2 id="陕西">陕西</h2><p>下载==[陕西税务app]==，服务-&gt;查询中心-&gt;发票流向中就可以查到了</p><h2 id="上海">上海</h2><p><a href="http://shanghai.chinatax.gov.cn/bsfw/">国家税务总局上海市税务局 (chinatax.gov.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 税务 </tag>
            
            <tag> 发票查验 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决win11更新后任务栏透明失效(Translucent TB/trayS)</title>
      <link href="/posts/e88e0438.html"/>
      <url>/posts/e88e0438.html</url>
      
        <content type="html"><![CDATA[<h1>解决win11更新后任务栏透明失效(Translucent TB/trayS)</h1><blockquote><p>Windows11不知哪个版本更新后导致Translucent TB的任务栏透明功能失效了，尝试过很多方法:</p><p>​修改注册表</p><p>​TaskbarTools</p><p>​Translucent TB</p><p>等等，最终还是选择了Start11，但是由于是破解版和与其他软件兼容性的原因，依然达不到以前的效果。</p></blockquote><p>==本文章参考了一下资料：==</p><ol><li><a href="https://www.yuque.com/jasonluke/kvg142/pxbqn2oadgpzepz3?singleDoc#">https://www.yuque.com/jasonluke/kvg142/pxbqn2oadgpzepz3?singleDoc#</a></li><li><a href="https://www.bilibili.com/read/cv22300526">解决win11更新后任务栏透明失效（Translucent TB/trayS） - 哔哩哔哩 (bilibili.com)</a></li></ol><h2 id="解决方法">解决方法</h2><p>使用工具<a href="https://github.com/thebookisclosed/ViVe/">ViVe</a>修改旧版本的工具栏:</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202305070916239.png" alt="image.png"></p><p><a href="https://github.com/thebookisclosed/ViVe/releases/">https://github.com/thebookisclosed/ViVe/releases/</a></p><h2 id="使用">使用</h2><ol><li>点击上面的链接去项目的发布页面下载:</li></ol><p>​<img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202305070924996.png" alt="image-20230507092433069"></p><ol start="2"><li><p>使用管理员模式打开终端</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202305070928946.png" alt="image-20230507092800812"></p></li><li><p>进入下载解压好的工具目录</p></li></ol><p>​<img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202305070930454.png" alt="image-20230507093034469"></p><ol start="4"><li><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\ViVeTool.exe /disable /id:26008830 /variant:2</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202305070933279.png" alt="image-20230507093337719"></p><ol start="5"><li>如下图成功后就可以重启正常使用任务栏透明工具了</li></ol><p>​<img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202305070935897.png" alt="image-20230507093537976"></p><h2 id="其他">其他</h2><ol><li>==An error occurred while setting feature configurations in the Runtime store (拒绝访问。)==</li></ol><p>出现这样的问题，原因是没有权限，需要以管理员运行终端。</p><ol start="2"><li>关闭win11 新任务栏 State</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\ViVeTool.exe /disable /id:26008830 /variant:2</span><br></pre></td></tr></table></figure><ol start="3"><li>开启win11 新任务栏 State</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\ViVeTool.exe /enable /id:26008830 /variant:2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 美化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/posts/91e798bc.html"/>
      <url>/posts/91e798bc.html</url>
      
        <content type="html"><![CDATA[<h1>Java内存模型</h1><blockquote><p><strong>Java内存模型规范（JSR-133）是围绕原子性、可见性和有序性展开的。</strong></p><p>Java内存模型（Java Memory Model，JMM）规定了Java程序中多线程并发访问变量时，变量值的<strong>可见性</strong>、<strong>原子性</strong>和<strong>有序性</strong>的保证规则。</p></blockquote><p>JMM定义了一套Java虚拟机规范，规定了Java虚拟机对于内存的读写操作、指令重排序和多线程同步的行为。JMM的设计目标是使Java程序在不同的Java虚拟机和操作系统平台上都能够有相同的行为。</p><p>具体来说，JMM规定了以下几个方面：</p><ol><li>所有的变量都存储在主内存中，每个线程都有自己的工作内存，线程的读写操作都必须通过主内存进行。</li><li>在每个线程的工作内存中，包含了该线程使用到的变量的副本拷贝。</li><li>所有的变量都是volatile、synchronized和final变量时，会保证线程读写变量的原子性和可见性。</li><li>对于非volatile和非final变量，线程对变量进行读写操作前，必须先从主内存读取变量值到工作内存，操作完成后再将工作内存的值写回主内存。</li><li>在Java内存模型中，指令重排序是允许的，但是JMM规定了一系列的happens-before规则来确保指令重排序不会导致程序的执行结果发生错误。</li></ol><p>Java内存模型的设计目标是提供一种高效、灵活和安全的多线程编程模型。同时，在实际开发中，开发者需要了解Java内存模型的规范，合理地使用volatile和synchronized关键字以及其他同步机制，保证多线程程序的正确执行。</p><h2 id="原子性、可见性、有序性">原子性、可见性、有序性</h2><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230984.webp" alt="img">原子性、可见性、有序性</p><p>如下图说明了Java线程、工作内存和主存之前的关系。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230662.webp" alt="img">Java多线程、工作内存和主内存关系</p><p>Java内存模型（JMM）定义了一套自己的主存到工作内存之间的交互协议，即一个变量如何从主存拷贝到工作内存，又如何从工作内存写入主存，该协议包含8种操作，并且要求JVM具体实现必须保证其中每一种操作都是原子的、不可再分的。 8种操作分别是：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230806.webp" alt="img">JMM8大原子操作</p><p>如下图描述了以上8个操作所在位置：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230842.webp" alt="img"></p><h2 id="什么是指令重排，为什么需要？">什么是指令重排，为什么需要？</h2><p>要搞懂指令重排，首先要知道一条指令在CPU内是如何执行的，如下图约5个步骤。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230690.webp" alt="img">CPU指令执行</p><p>为了加快指令并行速度，CPU硬件支持了流水线技术。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230327.webp" alt="img">CPU流水线</p><p>不同的指令步骤执行在不同的硬件局部，从而可以支持同时并发执行。</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230325.webp" alt="img">CPU流水线硬件布局</p><p>知道了CPU流水线之后，我们来看一个A=B+C的流水线执行过程例子：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230911.webp" alt="img">指令执行过程</p><p>如果按串行排列，则耗时4 * 5 = 20个时钟周期；使用CPU流水线并行技术后，可以只消耗9个时钟周期，节省了11个时钟周期的时间。所以流水线技术的引入，大大提高了CPU并行执行速度。 再看如下图的例子：</p><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230924.webp" alt="img">流水线执行过程</p><p>多条语句执行时，通过指令重排可以消除一些CPU中断，从而缩短执行时间，加快执行速度。</p><h2 id="重排序">重排序</h2><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262230313.webp" alt="img">执行令重排序</p><p>对于Java语言来说，为了提高新能，从源码到得到指令执行序列可能会经过编译器重排序和CPU重排序；CPU重排序又分为指令级重排和内存系统重排。</p><h2 id="编译器重排序">编译器重排序</h2><p>编译器重排序指的是在代码编译阶段进行指令重排，不改变程序执行结果的情况下，为了提升效率，编译器对指令进行乱序（Out-of-Order）的编译。</p><h2 id="CPU重排序">CPU重排序</h2><p>流水线（Pipeline）和乱序执行（Out-of-Order Execution）是现代CPU基本都具有的特性。</p><p>所谓“乱序”，仅仅是被称为“乱序”，实际上也遵循着一定规则：只要两个指令之间不存在“数据依赖”，就可以对这两个指令乱序。</p><p>CPU重排序包括两类：指令级重排序和内存系统重排序。</p><ul><li>指令级重排序 在不影响程序执行结果的情况下，CPU内核采用ILP（Instruction-Level Parallelism，指令级并行运算）技术来将多条指令重叠执行，主要是为了提升效率。如果指令之间不存在数据依赖性，CPU就可以改变语句的对应机器指令的执行顺序，叫作指令级重排序。</li><li>内存系统重排序 对于现代的CPU来说，在CPU内核和主存之间都具备一个高速缓存，高速缓存的作用主要是减少CPU内核和主存的交互（CPU内核的处理速度要快得多），在CPU内核进行读操作时，如果缓存没有的话就从主存取，而对于写操作都是先写在缓存中，最后再一次性写入主存。</li></ul><p>由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</p><h2 id="哪些指令不能重排：Happen-Before原则（先行发生）">哪些指令不能重排：Happen-Before原则（先行发生）</h2><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202304262229749.webp" alt="img">happen before8大原则</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>助手面接</title>
      <link href="/posts/b5c510da.html"/>
      <url>/posts/b5c510da.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">各位面试官、领导，您们好，非常感谢贵公司能给我这个面试的机会。</span><br><span class="line">   我是来自成都信息工程大学软件工程学院的龙维健，今年大三。</span><br><span class="line">   很荣幸能站在这里，今天我想要面试贵公司科研助理一职。</span><br><span class="line">   我之所以想要面试该职位是因为我喜欢助理这一职位并且具有相关的能力和经验。</span><br><span class="line">   首先，我在大学中一直担任纪律委员的职务，负责课程考勤、班级情况统计和协助团内组织策划和开展活动等工作，有较强的交流能力和组织协调能力；其次，有着两年的勤工俭学经历，主要协助教务科老师处理教务工作及党政办公室行政工作，能及时有效、仔细认真的处理老师安排的任务；然后，有着两段社会实践经验，知道团队协作的重要性，能与人进行有效的沟通，理性处理事情。最后，大学三年中，我多次带领和参加团队项目，具有较强的抗压能力，团队协作能力和处理事情的条理性，并且我在大一时选修了office工程以及专业需要能够使用WORD、POWER POINT、EXCEL等工具处理文件和数据。</span><br><span class="line">   我是一个乐观向上，热情务实；待人诚恳；工作认真负责，具有吃苦耐劳、艰苦奋斗的精神；适应能力强，具备良好的组织协调能力，注重团队合作精神和集体观念的人。</span><br><span class="line">   综上所述，通过大学经历和实践经验，我具备一定的文字处理能力，熟悉基本的办公软件应用，有一定的沟通能力，做事有条理，有项目经验，身心健康。</span><br><span class="line">   最后，谢谢各位考官能在百忙之中给我这次面试机会，希望我能加入贵公司，在实践中不断学习和进步。</span><br><span class="line">     </span><br></pre></td></tr></table></figure><h2 id="问题">问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请举一个你带领团队完成一项任务的例子</span><br><span class="line">    </span><br><span class="line">    班级每月开展的团学活动中，我都会先和团支书商量开展的党支部需要学习的具体内容。安排文体委员、组织委员商量学习后的班级活动，一些班级内部小游戏啊，提升班级活跃。我和团支书负责做ppt汇报，学习委员申请教室。班委之间互相协调配合。完成了这次团学活动。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">加班</span><br><span class="line"></span><br><span class="line">如果是个人效率问题，我一定会努力提高效率，在合理的时间内完成工作安排，绝不用加班来弥补自己的工作效率问题；如果是工作需要我也会加班，现在没有家庭负担，可以全身心的投入工作。但同样，我也会提高工作效率，减少不必要的加班。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你认为作为一名合格的管理者，应具备的基本素质有哪些?</span><br><span class="line">    </span><br><span class="line">第一我认为一个合格的管理人员需要健全的思维。这样解决问题时才能从全方面思考。第二我认为需要的专业知识。作为一个管理人员你就应该知道怎么样去管理人。第三我认为管理人员需要自信，如果你管理别人时都不自信，那么在其他人那里你可能就没有威严。第四我认为管理人员需要判断能力，管理人员作出的判断应该是正确的。不能作为一个管理人，连对错都分不清。第五管理人员需要执行能力，执行能力包括组织能力、良好工作习惯和勤奋。</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面接 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo写作</title>
      <link href="/posts/8b5b48fb.html"/>
      <url>/posts/8b5b48fb.html</url>
      
        <content type="html"><![CDATA[<p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> [layout] &lt;<span class="built_in">title</span>&gt;</span><br></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 <code>post</code>，可以通过修改 <code>_config.yml</code> 中的 <code>default_layout</code> 参数来指定默认布局。</p><h3 id="布局（Layout）">布局（Layout）</h3><p>Hexo 有三种默认布局：<code>post</code>、<code>page</code> 和 <code>draft</code>。在创建这三种不同类型的文件时，它们将会被保存到不同的路径；而您自定义的其他布局和 <code>post</code> 相同，都将储存到 <code>source/_posts</code> 文件夹。</p><table><thead><tr><th style="text-align:left">布局</th><th style="text-align:left">路径</th></tr></thead><tbody><tr><td style="text-align:left"><code>post</code></td><td style="text-align:left"><code>source/_posts</code></td></tr><tr><td style="text-align:left"><code>page</code></td><td style="text-align:left"><code>source</code></td></tr><tr><td style="text-align:left"><code>draft</code></td><td style="text-align:left"><code>source/_drafts</code></td></tr></tbody></table><blockquote><p>禁用布局</p><p>如果你不希望一篇文章（post/page）使用主题处理，请在它的 front-matter 中设置 <code>layout: false</code>。详情请参考<a href="https://hexo.io/zh-cn/docs/front-matter#%E5%B8%83%E5%B1%80">本节</a>。</p></blockquote><h3 id="文件名称">文件名称</h3><p>Hexo 默认以标题做为文件名称，但您可编辑 <code>new_post_name</code> 参数来改变默认的文件名称，举例来说，设为 <code>:year-:month-:day-:title.md</code> 可让您更方便的通过日期来管理文章。</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>:title</code></td><td style="text-align:left">标题（小写，空格将会被替换为短杠）</td></tr><tr><td style="text-align:left"><code>:year</code></td><td style="text-align:left">建立的年份，比如， <code>2015</code></td></tr><tr><td style="text-align:left"><code>:month</code></td><td style="text-align:left">建立的月份（有前导零），比如， <code>04</code></td></tr><tr><td style="text-align:left"><code>:i_month</code></td><td style="text-align:left">建立的月份（无前导零），比如， <code>4</code></td></tr><tr><td style="text-align:left"><code>:day</code></td><td style="text-align:left">建立的日期（有前导零），比如， <code>07</code></td></tr><tr><td style="text-align:left"><code>:i_day</code></td><td style="text-align:left">建立的日期（无前导零），比如， <code>7</code></td></tr></tbody></table><h3 id="草稿">草稿</h3><p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] <span class="tag">&lt;<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p><h2 id="模版（Scaffold）">模版（Scaffold）</h2><p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> <span class="type">photo</span> <span class="string">&quot;My Gallery&quot;</span></span><br></pre></td></tr></table></figure><p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找 <code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p><table><thead><tr><th style="text-align:left">变量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>layout</code></td><td style="text-align:left">布局</td></tr><tr><td style="text-align:left"><code>title</code></td><td style="text-align:left">标题</td></tr><tr><td style="text-align:left"><code>date</code></td><td style="text-align:left">文件建立日期</td></tr></tbody></table><h3 id="支持的格式">支持的格式</h3><p>Hexo 支持以任何格式书写文章，只要安装了相应的渲染插件。</p><p>例如，Hexo 默认安装了 <code>hexo-renderer-marked</code> 和 <code>hexo-renderer-ejs</code>，因此你不仅可以用 Markdown 写作，你还可以用 EJS 写作。如果你安装了 <code>hexo-renderer-pug</code>，你甚至可以用 Pug 模板语言书写文章。</p><p>只需要将文章的扩展名从 <code>md</code> 改成 <code>ejs</code>，Hexo 就会使用 <code>hexo-renderer-ejs</code> 渲染这个文件，其他格式同理。</p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DDD领域驱动模型</title>
      <link href="/posts/8ef9e73d.html"/>
      <url>/posts/8ef9e73d.html</url>
      
        <content type="html"><![CDATA[<h1>DDD领域驱动模型</h1><blockquote><p>领域驱动设计是一种解决业务复杂性的设计思想，不是一种标准规则的解决方法</p></blockquote><h2 id="DDD是什么">DDD是什么</h2><p>领域驱动设计（英语：Domain-driven design，缩写 <strong>DDD</strong>）是一种通过将实现连接到持续进化的模型[<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%9F%9F%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%23cite_note-definition-1">1]</a>来满足复杂需求的软件开发方法。领域驱动设计的前提是：</p><ul><li>把项目的主要重点放在核心领域（core domain）和域逻辑</li><li>把复杂的设计放在有界域（bounded context）的模型上</li><li>发起一个创造性的合作之间的技术和<a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/w/index.php%3Ftitle%3D%E5%9F%9F%E7%95%8C%E4%B8%93%E5%AE%B6%26action%3Dedit%26redlink%3D1">域界专家</a>以迭代地完善的概念模式，解决特定领域的问题</li></ul><p>领域驱动设计是一种由**域模型（墙裂推荐@阿白 的域模型系列）**来驱动着系统设计的思想，不是通过存储数据词典(DB表字段、ES Mapper字段等等)来驱动系统设计。<strong>领域模型是对业务模型的抽象，DDD是把业务模型翻译成系统架构设计的一种方式。</strong></p><hr><h2 id="DDD架构图">DDD架构图</h2><p><img src="https://raw.githubusercontent.com/nemuigaki/imgs/main/Notes/202303092344485.webp" alt="img"></p><hr><h2 id="术语">术语</h2><h3 id="“贫血模型”与“充血模型”">“贫血模型”与“充血模型”</h3><ul><li>贫血模型即事务脚本模式。</li><li>充血模型即领域模型模式。</li></ul><hr><h2 id="贫血模型">贫血模型</h2><p>贫血模型最早广泛应用源于EJB2，最强盛时期则是由Spring创造，将：</p><ul><li>“行为”（逻辑、过程）；</li><li>“状态”（数据，对应到语言就是对象成员变量）。</li></ul><p>分离到不同的对象中：</p><ul><li>只有状态的对象就是所谓的“贫血对象”（常称为VO——Value Object）；</li><li>只有行为的对象就是，我们常见的N层结构中的Logic/Service/Manager层（对应到EJB2中的Stateless Session Bean）。</li></ul><p>——曾经Spring的作者Rod Johnson也承认，Spring不过是在沿袭EJB2时代的“事务脚本”，也就是面向过程编程。</p><p><strong>贫血领域模型是一个存在已久的反模式，目前仍有许多拥趸者。</strong></p><p>贫血领域模型的根本问题是，它引入了领域模型设计的所有成本，却没有带来任何好处。最主要的成本是将对象映射到数据库中，从而产生了一个O/R（对象关系）映射层。</p><h3 id="优点"><strong>优点</strong></h3><p>简单：</p><ul><li>对于只有少量业务逻辑的应用来说，使用起来非常自然；</li><li>开发迅速，易于理解；</li><li>注意：也不能完全排斥这种方式。</li></ul><h3 id="缺点"><strong>缺点</strong></h3><p>无法良好的应对复杂逻辑：</p><ul><li>比如收入确认规则发生变化，例如在4月1号之前签订的合同要使用某规则……</li><li>和欧洲签订的合同使用另外一个规则……</li></ul><hr><h2 id="充血模型">充血模型</h2><p>面向对象设计的本质是：“一个对象是拥有状态和行为的”。</p><p>比如一个人：</p><ul><li>他眼睛什么样鼻子什么样这就是状态；</li><li>人可以去打游戏或是写程序，这就是行为。</li></ul><p>为什么要有一个“人Manager”这样的东西存在去帮人“打游戏”呢？举个简单的J2EE案例，设计一个与用户（User）相关功能。</p><p>传统的设计一般是：</p><ul><li>类：User+UserManager；</li><li>保存用户调用：userManager.save(User user)。</li></ul><p>充血的设计则可能会是：</p><ul><li>类：User；</li><li>保存用户调用：user.save()；</li><li>User有一个行为是：保存它自己。</li></ul><p>其实它们没有什么特别适用的方向，个人更倾向于总是使用充血模型，因为OOP总是比面向过程编程要有更丰富的语义、更合理的组织、更强的可维护性—当然也更难掌握。</p><p>因此实际工程场景中，是否使用，如何使用还依赖于设计者以及团队充血模型设计的理解和把握，因为现在绝大多数J2EE开发者都受贫血模型影响非常深。另外，实际工程场景中使用充血模型，还会碰到很多很多细节问题，其中最大的难关就是“如何设计充血模型”或者说“如何从复杂的业务中分离出恰到好处且包含语义的逻辑放到VO的行为中”。</p><p>如果一个对象包含其他对象，那就将职责继续委托下去，由具体的 POJO 执行业务逻辑，将策略模式更加细粒度，而不是写 ifelse。</p><h3 id="应用层（即Service层）"><strong>应用层（即Service层）</strong></h3><p>描述应用程序所要做的工作，并调度丰富的领域模型来完成它。这个层次的任务是描述业务逻辑，或和其它项目的应用层做交互。这层很薄，不包含任何业务规则或知识，仅用于调度和派发任务给下一层的领域模型。这层没有业务状态，但可以为用户或程序提供任务状态。</p><h3 id="领域层（或者叫模型层）"><strong>领域层（或者叫模型层）</strong></h3><p>表示业务逻辑、业务场景和规则。该层次会控制和使用业务状态，即使这些状态最终会交由持久化层来存储。总之，该层是软件核心。</p><p>服务层很薄——所有重要的业务逻辑都写在领域层。他在服务模式中复述了这一观点：如今人们常犯的错误是不愿花时间将业务逻辑放到合适的领域模型中，从而逐渐形成面向过程的程序设计。</p><p>我不清楚为什么这种反模式会那么常见。我怀疑是因为大多数人并没有使用过一个设计良好的领域模型，特别是那些以数据为中心的开发人员。此外，有些技术也会推动这种反模式，比如J2EE的Entity Bean，这会让我更倾向于使用POJO领域模型。</p><p>总之，如果你将大部分行为都放置在服务层，那么你就会失去领域模型带来的好处。如果你将所有行为都放在服务层，那你就无可救药了。</p><h1>传统架构对比DDD领域设计</h1><p>软件架构模式发展到现在可以主要经历了三个阶段：UI+DataBase的两层架构、UI+Service+DataBase的多层SOA架构、分布式微服务架构。</p><h2 id="一、传统架构的缺点">一、传统架构的缺点</h2><p>在前两种架构中，系统分析、设计和开发往往是独立、分阶段割裂进行的。</p><p>1、两层架构是面向数据库的架构，根本没有灵活性。</p><p>2、微服务盛行的今天，多层SOA架构已经完全不能满足微服务架构应用的需求，它存在这么一些问题</p><ol><li>臃肿的servcie</li><li>三层分层后文件的随意组装方式</li><li>技术导向分层，导致业务分离，不能快速定位。</li></ol><p>比如，在系统建设过程中，我们经常会看到这样的情形：A 负责提出需求，B 负责需求分析，C 负责系统设计，D 负责代码实现，这样的流程很长，经手的人也很多，很容易导致信息丢失。最后，就很容易导致需求、设计与代码实现的不一致，往往到了软件上线后，我们才发现很多功能并不是自己想要的，或者做出来的功能跟自己提出的需求偏差太大。</p><p>在这两种模式下，软件无法快速响应需求和业务的迅速变化，最终错失发展良机。此时，分布式微服务的出现就有点恰逢其时的意思了。</p><h2 id="二、DDD领域驱动">二、DDD领域驱动</h2><p>虽说分布式微服务有这么好的优点，但也不是适合所有的系统，而且也会有许多问题。</p><p>微服务的粒度应该多大呀？微服务到底应该如何拆分和设计呢？微服务的边界应该在哪里？这些都是微服务设计要解决的问题，但是很久以来都没有一套系统的理论和方法可以指导微服务的拆分，综合来看，我认为微服务拆分困境产生的根本原因就是不知道业务或者微服务的边界到底在什么地方。换句话说，确定了业务边界和应用边界，这个困境也就迎刃而解了。</p><p><strong>DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。</strong></p><p>领域驱动设计是一种以业务为导向的软件设计方法和思路。我们在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。</p><h2 id="1、DDD-包括战略设计和战术设计两部分。">1、DDD 包括战略设计和战术设计两部分。</h2><p>a、战略设计主要从业务视角出发，建立业务领域模型，划分领域边界，建立通用语言的限界上下文，限界上下文可以作为微服务设计的参考边界。</p><p>b、战术设计则从技术视角出发，侧重于领域模型的技术实现，完成软件开发和落地，包括：聚合根、实体、值对象、领域服务、应用服务和资源库等代码逻辑的设计和实现。</p><p>很多 DDD 初学者，学习 DDD 的主要目的，可能是为了开发微服务，因此更看重 DDD 的战术设计实现。殊不知 DDD 是一种从领域建模到微服务落地的全方位的解决方案。</p><p>战略设计时构建的领域模型，是微服务设计和开发的输入，它确定了微服务的边界、聚合、代码对象以及服务等关键领域对象。领域模型边界划分得清不清晰，领域对象定义得明不明确，会决定微服务的设计和开发质量。没有领域模型的输入，基于 DDD 的微服务的设计和开发将无从谈起。因此我们不仅要重视战术设计，更要重视战略设计。</p><h2 id="2、DDD的优势">2、DDD的优势</h2><ol><li>接触到需求第一步就是考虑领域模型，而不是将其切割成数据和行为，然后数据用数据库实现，行为使用服务实现，最后造成需求的首肢分离。DDD让你首先考虑的是业务语言，而不是数据。重点不同导致编程世界观不同。</li><li>DDD可以更加领域模型界限上下文边界快速拆分微服务，实现系统架构适应业务的快速变化，例如：系统的用户量并发量增长得很快，单体应用很快就支持不了，如果我们一开始就采用DDD领域驱动设计，那我们就能很快的把服务拆分成多个微服务，以适应快速增长的用户量。</li><li>DDD 是一套完整而系统的设计方法，它能带给你从战略设计到战术设计的标准设计过程，使得你的设计思路能够更加清晰，设计过程更加规范。</li><li>使用DDD可以降低服务的耦合性，让系统设计更加规范，即使是刚加入团队的新人也可以根据业务快速找到对应的代码模块，降低维护成本。</li><li>DDD 善于处理与领域相关的拥有高复杂度业务的产品开发，通过它可以建立一个核心而稳定的领域模型，有利于领域知识的传递与传承。</li><li>DDD 强调团队与领域专家的合作，能够帮助你的团队建立一个沟通良好的氛围，构建一致的架构体系。</li><li>DDD 的设计思想、原则与模式有助于提高你的架构设计能力。</li><li>无论是在新项目中设计微服务，还是将系统从单体架构演进到微服务，都可以遵循 DDD 的架构原则。</li></ol><h2 id="3、DDD设计原则">3、DDD设计原则</h2><ol><li>要领域驱动设计，而不是数据驱动设计，也不是界面驱动设计。</li><li>要边界清晰的微服务，而不是泥球小单体。</li><li>要职能清晰的分层，而不是什么都放的大箩筐。</li><li>要做自己能 hold 住的微服务，而不是过度拆分的微服务。</li></ol><h2 id="4、微服务拆分需要考虑哪些因素？">4、微服务拆分需要考虑哪些因素？</h2><p>理论上一个限界上下文内的领域模型可以被设计为微服务，但是由于领域建模主要从业务视角出发，没有考虑非业务因素，比如需求变更频率、高性能、安全、团队以及技术异构等因素，而这些非业务因素对于领域模型的系统落地也会起到决定性作用，因此在微服务拆分时我们需要重点考虑它们。我列出了以下主要因素供你参考。</p><h3 id="4-1、基于领域模型">4.1、基于领域模型</h3><p>基于领域模型进行拆分，围绕业务领域按职责单一性、功能完整性拆分。</p><h3 id="4-2、基于业务需求变化频率">4.2、基于业务需求变化频率</h3><p>识别领域模型中的业务需求变动频繁的功能，考虑业务变更频率与相关度，将业务需求变动较高和功能相对稳定的业务进行分离。这是因为需求的经常性变动必然会导致代码的频繁修改和版本发布，这种分离可以有效降低频繁变动的敏态业务对稳态业务的影响。</p><h3 id="4-3、基于应用性能">4.3、基于应用性能</h3><p>识别领域模型中性能压力较大的功能。因为性能要求高的功能可能会拖累其它功能，在资源要求上也会有区别，为了避免对整体性能和资源的影响，我们可以把在性能方面有较高要求的功能拆分出去。</p><h3 id="4-4、基于组织架构和团队规模">4.4、基于组织架构和团队规模</h3><p>除非有意识地优化组织架构，否则微服务的拆分应尽量避免带来团队和组织架构的调整，避免由于功能的重新划分，而增加大量且不必要的团队之间的沟通成本。拆分后的微服务项目团队规模保持在 10～12 人左右为宜。</p><h3 id="4-5、基于安全边界">4.5、基于安全边界</h3><p>有特殊安全要求的功能，应从领域模型中拆分独立，避免相互影响。</p><h3 id="4-6、基于技术异构">4.6、基于技术异构</h3><p>领域模型中有些功能虽然在同一个业务域内，但在技术实现时可能会存在较大的差异，也就是说领域模型内部不同的功能存在技术异构的问题。由于业务场景或者技术条件的限制，<a href="http://xn--jpr775b5jkzjbb61a.NET">有的可能用.NET</a>，有的则是 Java，有的甚至大数据架构。对于这些存在技术异构的功能，可以考虑按照技术边界进行拆分。</p>]]></content>
      
      
      <categories>
          
          <category> 架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 架构设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% cell xaoxuu, https://xaoxuu.com, https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a><a class="button" href='https://xaoxuu.com' title='xaoxuu'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/avatar/avatar.png'>xaoxuu</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_pro.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/qrcode/heartmate_lite.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard fomalhaut1998 %&#125; | &#123;% ghcard fomalhaut1998, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=buefy %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=onedark %&#125; | &#123;% ghcard fomalhaut1998, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard fomalhaut1998, theme=algolia %&#125; | &#123;% ghcard fomalhaut1998, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/fomalhaut1998"><img src="https://github-readme-stats.vercel.app/api/?username=fomalhaut1998&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site xaoxuu, url=https://xaoxuu.com, screenshot=https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg, avatar=https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site inkss, url=https://inkss.cn, screenshot=https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg, avatar=https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site MHuiG, url=https://blog.mhuig.top, screenshot=https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png, avatar=https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Colsrch, url=https://colsrch.top, screenshot=https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png, avatar=https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site Linhk1606, url=https://linhk1606.github.io, screenshot=https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png, avatar=https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://fomalhaut1998.com"><div class="img"><img src="https://i.loli.net/2020/08/21/VuSwWZ1xAeUHEBC.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/fomalhaut1998/cdn-assets/avatar/avatar.png"/><span class="title">fomalhaut1998</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://inkss.cn"><div class="img"><img src="https://i.loli.net/2020/08/21/Vzbu3i8fXs6Nh5Y.jpg"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/inkss/common@master/static/web/avatar.jpg"/><span class="title">inkss</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://blog.mhuig.top"><div class="img"><img src="https://i.loli.net/2020/08/22/d24zpPlhLYWX6D1.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/MHuiG/imgbed@master/data/p.png"/><span class="title">MHuiG</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://colsrch.top"><div class="img"><img src="https://i.loli.net/2020/08/22/dFRWXm52OVu8qfK.png"/></div><div class="info"><img src="https://cdn.jsdelivr.net/gh/Colsrch/images/Colsrch/avatar.jpg"/><span class="title">Colsrch</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://linhk1606.github.io"><div class="img"><img src="https://i.loli.net/2020/08/21/3PmGLCKicnfow1x.png"/></div><div class="info"><img src="https://i.loli.net/2020/02/09/PN7I5RJfFtA93r2.png"/><span class="title">Linhk1606</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/0000.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/aru-l/5150.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper-minimalist/2020/025.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup MC 在Rikkaの六花服务器里留下的足迹 &#x27;/gallery/MC/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup Gundam 哦咧哇gundam哒！ &#x27;/gallery/Gundam/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png %&#125;</span><br><span class="line">&#123;% galleryGroup I-am-Akilar 某种意义上也算自拍吧 &#x27;/gallery/I-am-Akilar/&#x27; https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">MC</div>  <p>在Rikkaの六花服务器里留下的足迹</p>  <a href='/gallery/MC/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907110508327.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Gundam</div>  <p>哦咧哇gundam哒！</p>  <a href='/gallery/Gundam/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.cbd.int/akilar-candyassets@1.0.36/image/20200907113116651.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">I-am-Akilar</div>  <p>某种意义上也算自拍吧</p>  <a href='/gallery/I-am-Akilar/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://cdn.jsdelivr.net/gh/volantis-x/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://cdn.jsdelivr.net/gh/volantis-x/cdn-emoji/tieba/%E6%BB%91%E7%A8%BD.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'Amap'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows网卡断流、高PING、丢包问题</title>
      <link href="/posts/ad41f714.html"/>
      <url>/posts/ad41f714.html</url>
      
        <content type="html"><![CDATA[<h1>解决你困扰已久的台式机无线WiFi网卡断流、高PING、丢包的问题</h1><blockquote><p><a href="https://cloud.tencent.com/developer/article/1635388">解决你困扰已久的台式机无线WiFi网卡断流、高PING、丢包的问题 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p></blockquote><h1>方法一 重新启用WLAN AutoConfig服务</h1><p>Win键 + R，弹出“运行”窗口，然后输入“services.msc&quot;</p><p>打开后找到”WLAN AutoConfig&quot;，停止后再启用就好了。</p><h1>方法二 禁用自动扫描WiFi网络</h1><p>新建一个记事本文件，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">title Fix <span class="keyword">for</span> Wireless Ping Spikes (self.GlobalOffensive)</span><br><span class="line"><span class="built_in">echo</span> submitted by Clyq, bat by Ment-0</span><br><span class="line"><span class="built_in">echo</span> ------------------------------------------------------------------</span><br><span class="line"><span class="built_in">echo</span> Stop your Wireless Card from searching nearby networks and</span><br><span class="line"><span class="built_in">echo</span> updating your signal quality when you<span class="string">&#x27;re not asking it to, </span></span><br><span class="line"><span class="string">echo which is what is causing the spikes.</span></span><br><span class="line"><span class="string">echo ------------------------------------------------------------------</span></span><br><span class="line"><span class="string">echo You will need to turn it back on if you disconnect or need to be </span></span><br><span class="line"><span class="string">echo able to find nearby networks again. </span></span><br><span class="line"><span class="string">echo Good Luck!</span></span><br><span class="line"><span class="string">echo ------------------------------------------------------------------</span></span><br><span class="line"><span class="string">pause</span></span><br><span class="line"><span class="string">:MENU</span></span><br><span class="line"><span class="string">cls</span></span><br><span class="line"><span class="string">echo ------------------------------------------------------------------</span></span><br><span class="line"><span class="string">echo -------------------Fix for Wireless Ping Spikes-------------------</span></span><br><span class="line"><span class="string">echo ------------------------------------------------------------------</span></span><br><span class="line"><span class="string">echo Option 1: Disable searching for networks and updating quality.</span></span><br><span class="line"><span class="string">echo Option 2: Enable searching for networks and updating quality.</span></span><br><span class="line"><span class="string">echo Option 3: Exit.</span></span><br><span class="line"><span class="string">SET /P M=Type 1, 2 OR 3 then press ENTER:</span></span><br><span class="line"><span class="string">IF %M%==1 GOTO DISABLE</span></span><br><span class="line"><span class="string">IF %M%==2 GOTO ENABLE</span></span><br><span class="line"><span class="string">IF %M%==3 GOTO END</span></span><br><span class="line"><span class="string">:DISABLE</span></span><br><span class="line"><span class="string">cls</span></span><br><span class="line"><span class="string">netsh wlan show settings</span></span><br><span class="line"><span class="string">echo.</span></span><br><span class="line"><span class="string">echo The last line should be like: Auto configuration logic is </span></span><br><span class="line"><span class="string">echo enabled on interface &quot;WiFi&quot;</span></span><br><span class="line"><span class="string">echo.</span></span><br><span class="line"><span class="string">echo If so, type what is says after interface.</span></span><br><span class="line"><span class="string">echo EXAMPLE if interface=&quot;WiFi&quot; then you type: WiFi</span></span><br><span class="line"><span class="string">SET /P input=Type here:</span></span><br><span class="line"><span class="string">netsh wlan set autoconfig enabled=no interface=&quot;%INPUT%&quot;</span></span><br><span class="line"><span class="string">pause</span></span><br><span class="line"><span class="string">GOTO MENU</span></span><br><span class="line"><span class="string">:ENABLE</span></span><br><span class="line"><span class="string">cls</span></span><br><span class="line"><span class="string">netsh wlan show settings</span></span><br><span class="line"><span class="string">echo.</span></span><br><span class="line"><span class="string">echo The last line should be like: Auto configuration logic is </span></span><br><span class="line"><span class="string">echo disabled on interface &quot;WiFi&quot;</span></span><br><span class="line"><span class="string">echo.</span></span><br><span class="line"><span class="string">echo If so, type what is says after interface.</span></span><br><span class="line"><span class="string">echo EXAMPLE if interface=&quot;WiFi&quot; then you type: WiFi</span></span><br><span class="line"><span class="string">SET /P input=Type here:</span></span><br><span class="line"><span class="string">netsh wlan set autoconfig enabled=yes interface=&quot;%INPUT%&quot;</span></span><br><span class="line"><span class="string">pause</span></span><br><span class="line"><span class="string">GOTO MENU</span></span><br><span class="line"><span class="string">:END</span></span><br><span class="line"><span class="string">exit</span></span><br></pre></td></tr></table></figure><p>命名为“禁用WiFi自动扫描”，后缀名为“.bat”。</p><p>连接到网络之后，打开此批处理文件，按任意键继续，再按1回车，最后输出接口“WLAN”即可。</p><p><img src="C:/Sadalsuud/Documents/Notes/imgs/1620.jpeg" alt="img"></p><p><img src="C:/Sadalsuud/Documents/Notes/imgs/1620-16779971840651.jpeg" alt="img"></p><p><img src="C:/Sadalsuud/Documents/Notes/imgs/1620-16779971840652.jpeg" alt="img"></p><p>如果要连接其他无线网络，则要启用自动扫描，这时按2回车，最后再输出接口“WLAN”即可。</p><p>需要注意的是，关闭自动扫描后重启并不会开启自动扫描。</p><h1>参考</h1><p><a href="https://www.zhihu.com/question/31994010/answer/277076802">USB无线网卡每隔固定时间就丢包或者高延时怎么破？</a></p>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
